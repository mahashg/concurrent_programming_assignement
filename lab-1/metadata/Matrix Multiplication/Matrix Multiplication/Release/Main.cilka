/* proudly generated by cpfe 1,1,0,8504 */
#include "cilki/cilkdefs.cki"
#line 1 ".\\Main.cilk"
#pragma warning ( push )
#pragma warning ( disable: 4355 )
#line 103 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#pragma comment ( linker, "/manifestdependency:\"type=\'win32\' " "name=\'" "Microsoft.VC90" ".CRT\' " "version=\'" "9.0.21022.8" "\' " "processorArchitecture=\'x86\' " "publicKeyToken=\'" "1fc8b3b9a1e18e3b" "\'\"" )
#line 156
#pragma pack ( push, 8 )
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"
#pragma pack ( push, 8 )
#line 52
extern "C" { typedef unsigned __w64 uintptr_t; }
#line 61
extern "C" { typedef char *va_list; }
#line 151
#pragma pack ( pop )
#line 478 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
typedef unsigned size_t; 
#line 485
extern "C" { typedef size_t rsize_t; }
#line 494
extern "C" { typedef int __w64 intptr_t; }
#line 512
extern "C" { typedef int __w64 ptrdiff_t; }
#line 523
extern "C" { typedef unsigned short wint_t; }
extern "C" { typedef unsigned short wctype_t; }
#line 548
extern "C" { typedef int errcode; }




extern "C" { typedef int errno_t; }



extern "C" { typedef long __w64 __time32_t; }




extern "C" { typedef __int64 __time64_t; }
#line 570
extern "C" { typedef __time64_t time_t; }
#line 2025
struct threadlocaleinfostruct; 
struct threadmbcinfostruct; 
extern "C" { typedef threadlocaleinfostruct *pthreadlocinfo; }
extern "C" { typedef threadmbcinfostruct *pthreadmbcinfo; }
struct __lc_time_data; 
#line 2035
extern "C" { typedef 
#line 2031
struct localeinfo_struct { friend struct __cilk_s;

pthreadlocinfo locinfo; 
pthreadmbcinfo mbcinfo; 
} _locale_tstruct; }extern "C" { typedef localeinfo_struct *_locale_t; }
#line 2042
extern "C" { typedef 
#line 2038
struct tagLC_ID { friend struct __cilk_s;
unsigned short wLanguage; 
unsigned short wCountry; 
unsigned short wCodePage; 
} LC_ID; }extern "C" { typedef tagLC_ID *LPLC_ID; }
#line 2071
extern "C" { typedef 
#line 2047
struct threadlocaleinfostruct { friend struct __cilk_s;
int refcount; 
unsigned lc_codepage; 
unsigned lc_collate_cp; 
unsigned long lc_handle[6]; 
LC_ID lc_id[6]; 
struct __T6797592 { friend struct __cilk_s;
char *locale; 
__wchar_t *wlocale; 
int *refcount; 
int *wrefcount; 
} lc_category[6]; 
int lc_clike; 
int mb_cur_max; 
int *lconv_intl_refcount; 
int *lconv_num_refcount; 
int *lconv_mon_refcount; 
struct lconv *lconv; 
int *ctype1_refcount; 
unsigned short *ctype1; 
const unsigned short *pctype; 
const unsigned char *pclmap; 
const unsigned char *pcumap; 
__lc_time_data *lc_time_curr; 
} threadlocinfo; }
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\use_ansi.h"
#pragma comment ( lib, "msvcprt" )
#line 63
#pragma comment ( linker, "/manifestdependency:\"type=\'win32\' " "name=\'" "Microsoft.VC90" ".CRT\' " "version=\'" "9.0.21022.8" "\' " "processorArchitecture=\'x86\' " "publicKeyToken=\'" "1fc8b3b9a1e18e3b" "\'\"" )
#line 2109 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"
#pragma pack ( push, 8 )
#line 524
namespace std { 
typedef bool _Bool; 
}
#line 542
typedef __int64 _Longlong; 
typedef unsigned __int64 _ULonglong; 
#line 565
namespace std { 



#pragma warning(push)
#pragma warning(disable:4412)
class __declspec( dllimport ) _Lockit { friend struct __cilk_s;__CILK_METADATA(_Lockit, __CILK_VBASE_DETECT)
#line 591
public: explicit __thiscall _Lockit(); 
explicit __thiscall _Lockit(int); 
__thiscall ~_Lockit(); 


static void __cdecl _Lockit_ctor(int); 
static void __cdecl _Lockit_dtor(int); 


private: static void __cdecl _Lockit_ctor(_Lockit *); 
static void __cdecl _Lockit_ctor(_Lockit *, int); 
static void __cdecl _Lockit_dtor(_Lockit *); 

_Lockit(const _Lockit &); 
_Lockit &operator=(const _Lockit &); 

int _Locktype; 
#line 624
}; 
#line 718
class __declspec( dllimport ) _Mutex { friend struct __cilk_s;
#line 742
public: __thiscall _Mutex(); 
__thiscall ~_Mutex(); 
void __thiscall _Lock(); 
void __thiscall _Unlock(); 



private: static void __cdecl _Mutex_ctor(_Mutex *); 
static void __cdecl _Mutex_dtor(_Mutex *); 
static void __cdecl _Mutex_Lock(_Mutex *); 
static void __cdecl _Mutex_Unlock(_Mutex *); 

_Mutex(const _Mutex &); 
_Mutex &operator=(const _Mutex &); 
void *_Mtx; 
#line 768
}; 

class __declspec( dllimport ) _Init_locks { friend struct __cilk_s;
#line 786
public: __thiscall _Init_locks(); 
__thiscall ~_Init_locks(); 



private: static void __cdecl _Init_locks_ctor(_Init_locks *); 
static void __cdecl _Init_locks_dtor(_Init_locks *); 
#line 804
}; 
#pragma warning(pop)
}
#line 815
extern __declspec( dllimport ) void __cdecl _Atexit(void (__cdecl *)(void)); 

typedef int _Mbstatet; 
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\climits"
#pragma warning(disable: 4514)
#line 826 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"
#pragma pack ( pop )
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
#pragma pack ( push, 8 )
#line 59
extern "C" { struct _iobuf { friend struct __cilk_s;
char *_ptr; 
int _cnt; 
char *_base; 
int _flag; 
int _file; 
int _charbuf; 
int _bufsiz; 
char *_tmpfname; 
}; }
extern "C" { typedef _iobuf FILE; }
#line 132
extern "C" { extern __declspec( dllimport ) FILE *__cdecl __iob_func(); } 
#line 148
extern "C" { typedef __int64 fpos_t; }
#line 189
extern "C" { extern __declspec( dllimport ) int __cdecl _filbuf(FILE *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _flsbuf(int, FILE *); } 




extern "C" { extern __declspec( dllimport ) FILE *__cdecl _fsopen(const char *, const char *, int); } 


extern "C" { extern __declspec( dllimport ) void __cdecl clearerr(FILE *); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl clearerr_s(FILE *); } 

extern "C" { extern __declspec( dllimport ) int __cdecl fclose(FILE *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _fcloseall(); } 




extern "C" { extern __declspec( dllimport ) FILE *__cdecl _fdopen(int, const char *); } 


extern "C" { extern __declspec( dllimport ) int __cdecl feof(FILE *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl ferror(FILE *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl fflush(FILE *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl fgetc(FILE *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _fgetchar(); } 
extern "C" { extern __declspec( dllimport ) int __cdecl fgetpos(FILE *, fpos_t *); } 
extern "C" { extern __declspec( dllimport ) char *__cdecl fgets(char *, int, FILE *); } 




extern "C" { extern __declspec( dllimport ) int __cdecl _fileno(FILE *); } 
#line 230
extern "C" { extern __declspec( dllimport ) char *__cdecl _tempnam(const char *, const char *); } 
#line 236
extern "C" { extern __declspec( dllimport ) int __cdecl _flushall(); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using fopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) FILE *__cdecl fopen(const char *, const char *); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl fopen_s(FILE **, const char *, const char *); } 

extern "C" { extern __declspec( dllimport ) int __cdecl fprintf(FILE *, const char *, ...); } 

extern "C" { extern __declspec( dllimport ) int __cdecl fprintf_s(FILE *, const char *, ...); } 

extern "C" { extern __declspec( dllimport ) int __cdecl fputc(int, FILE *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _fputchar(int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl fputs(const char *, FILE *); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl fread(void *, size_t, size_t, FILE *); } 

extern "C" { extern __declspec( dllimport ) size_t __cdecl fread_s(void *, size_t, size_t, size_t, FILE *); } 

extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using freopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) FILE *__cdecl freopen(const char *, const char *, FILE *); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl freopen_s(FILE **, const char *, const char *, FILE *); } 

extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using fscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl fscanf(FILE *, const char *, ...); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _fscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _fscanf_l(FILE *, const char *, _locale_t, ...); } 
#pragma warning(push)
#pragma warning(disable:6530)

extern "C" { extern __declspec( dllimport ) int __cdecl fscanf_s(FILE *, const char *, ...); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _fscanf_s_l(FILE *, const char *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl fsetpos(FILE *, const fpos_t *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl fseek(FILE *, long, int); } 
extern "C" { extern __declspec( dllimport ) long __cdecl ftell(FILE *); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _fseeki64(FILE *, __int64, int); } 
extern "C" { extern __declspec( dllimport ) __int64 __cdecl _ftelli64(FILE *); } 

extern "C" { extern __declspec( dllimport ) size_t __cdecl fwrite(const void *, size_t, size_t, FILE *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl getc(FILE *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl getchar(); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _getmaxstdio(); } 

extern "C" { extern __declspec( dllimport ) char *__cdecl gets_s(char *, rsize_t); } 

template<size_t _Size> inline char *__cdecl gets_s(char (&)[_Size]); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using gets_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl gets(char *); } 
extern "C" { extern int __cdecl _getw(FILE *); } 


extern "C" { extern __declspec( dllimport ) void __cdecl perror(const char *); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _pclose(FILE *); } 
extern "C" { extern __declspec( dllimport ) FILE *__cdecl _popen(const char *, const char *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl printf(const char *, ...); } 

extern "C" { extern __declspec( dllimport ) int __cdecl printf_s(const char *, ...); } 

extern "C" { extern __declspec( dllimport ) int __cdecl putc(int, FILE *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl putchar(int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl puts(const char *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _putw(int, FILE *); } 


extern "C" { extern __declspec( dllimport ) int __cdecl remove(const char *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl rename(const char *, const char *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _unlink(const char *); } 

extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _unlink. See online help for details.")) int __cdecl unlink(const char *); } 


extern "C" { extern __declspec( dllimport ) void __cdecl rewind(FILE *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _rmtmp(); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using scanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl scanf(const char *, ...); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _scanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _scanf_l(const char *, _locale_t, ...); } 

extern "C" { extern __declspec( dllimport ) int __cdecl scanf_s(const char *, ...); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _scanf_s_l(const char *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using setvbuf instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) void __cdecl setbuf(FILE *, char *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _setmaxstdio(int); } 
extern "C" { extern __declspec( dllimport ) unsigned __cdecl _set_output_format(unsigned); } 
extern "C" { extern __declspec( dllimport ) unsigned __cdecl _get_output_format(); } 
extern "C" { extern __declspec( dllimport ) int __cdecl setvbuf(FILE *, char *, int, size_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _snprintf_s(char *, size_t, size_t, const char *, ...); } 
__pragma( warning(push)) __pragma( warning(disable: 4793)) template<size_t _Size> inline int __cdecl _snprintf_s(char (&)[_Size], size_t, const char *, ...); __pragma( warning(pop)) 

extern "C" { extern __declspec( dllimport ) int __cdecl sprintf_s(char *, size_t, const char *, ...); } 

__pragma( warning(push)) __pragma( warning(disable: 4793)) template<size_t _Size> inline int __cdecl sprintf_s(char (&)[_Size], const char *, ...); __pragma( warning(pop)) 
extern "C" { extern __declspec( dllimport ) int __cdecl _scprintf(const char *, ...); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using sscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl sscanf(const char *, const char *, ...); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _sscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _sscanf_l(const char *, const char *, _locale_t, ...); } 

extern "C" { extern __declspec( dllimport ) int __cdecl sscanf_s(const char *, const char *, ...); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _sscanf_s_l(const char *, const char *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _snscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _snscanf(const char *, size_t, const char *, ...); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _snscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _snscanf_l(const char *, size_t, const char *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _snscanf_s(const char *, size_t, const char *, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _snscanf_s_l(const char *, size_t, const char *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using tmpfile_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) FILE *__cdecl tmpfile(); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl tmpfile_s(FILE **); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl tmpnam_s(char *, rsize_t); } 

template<size_t _Size> inline errno_t __cdecl tmpnam_s(char (&)[_Size]); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using tmpnam_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl tmpnam(char *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl ungetc(int, FILE *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl vfprintf(FILE *, const char *, va_list); } 

extern "C" { extern __declspec( dllimport ) int __cdecl vfprintf_s(FILE *, const char *, va_list); } 

extern "C" { extern __declspec( dllimport ) int __cdecl vprintf(const char *, va_list); } 

extern "C" { extern __declspec( dllimport ) int __cdecl vprintf_s(const char *, va_list); } 

extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using vsnprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl vsnprintf(char *, size_t, const char *, va_list); } 

extern "C" { extern __declspec( dllimport ) int __cdecl vsnprintf_s(char *, size_t, size_t, const char *, va_list); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _vsnprintf_s(char *, size_t, size_t, const char *, va_list); } 
template<size_t _Size> inline int __cdecl _vsnprintf_s(char (&)[_Size], size_t, const char *, va_list); 
#pragma warning(push)
#pragma warning(disable:4793)
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _snprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _snprintf(char *, size_t, const char *, ...); } extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _vsnprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _vsnprintf(char *, size_t, const char *, va_list); } 
#pragma warning(pop)

extern "C" { extern __declspec( dllimport ) int __cdecl vsprintf_s(char *, size_t, const char *, va_list); } 

template<size_t _Size> inline int __cdecl vsprintf_s(char (&)[_Size], const char *, va_list); 
#pragma warning(push)
#pragma warning(disable:4793)
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using sprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl sprintf(char *, const char *, ...); } extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using vsprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl vsprintf(char *, const char *, va_list); } 
#pragma warning(pop)
extern "C" { extern __declspec( dllimport ) int __cdecl _vscprintf(const char *, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _snprintf_c(char *, size_t, const char *, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vsnprintf_c(char *, size_t, const char *, va_list); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _fprintf_p(FILE *, const char *, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _printf_p(const char *, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _sprintf_p(char *, size_t, const char *, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vfprintf_p(FILE *, const char *, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vprintf_p(const char *, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vsprintf_p(char *, size_t, const char *, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _scprintf_p(const char *, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vscprintf_p(const char *, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _set_printf_count_output(int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _get_printf_count_output(); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _printf_l(const char *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _printf_p_l(const char *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _printf_s_l(const char *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vprintf_l(const char *, _locale_t, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vprintf_p_l(const char *, _locale_t, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vprintf_s_l(const char *, _locale_t, va_list); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _fprintf_l(FILE *, const char *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _fprintf_p_l(FILE *, const char *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _fprintf_s_l(FILE *, const char *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vfprintf_l(FILE *, const char *, _locale_t, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vfprintf_p_l(FILE *, const char *, _locale_t, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vfprintf_s_l(FILE *, const char *, _locale_t, va_list); } 

extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _sprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _sprintf_l(char *, const char *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _sprintf_p_l(char *, size_t, const char *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _sprintf_s_l(char *, size_t, const char *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _vsprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _vsprintf_l(char *, const char *, _locale_t, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vsprintf_p_l(char *, size_t, const char *, _locale_t, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vsprintf_s_l(char *, size_t, const char *, _locale_t, va_list); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _scprintf_l(const char *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _scprintf_p_l(const char *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vscprintf_l(const char *, _locale_t, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vscprintf_p_l(const char *, _locale_t, va_list); } 

extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _snprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _snprintf_l(char *, size_t, const char *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _snprintf_c_l(char *, size_t, const char *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _snprintf_s_l(char *, size_t, size_t, const char *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _vsnprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _vsnprintf_l(char *, size_t, const char *, _locale_t, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vsnprintf_c_l(char *, size_t, const char *, _locale_t, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vsnprintf_s_l(char *, size_t, size_t, const char *, _locale_t, va_list); } 
#line 427
extern "C" { extern __declspec( dllimport ) FILE *__cdecl _wfsopen(const __wchar_t *, const __wchar_t *, int); } 


extern "C" { extern __declspec( dllimport ) wint_t __cdecl fgetwc(FILE *); } 
extern "C" { extern __declspec( dllimport ) wint_t __cdecl _fgetwchar(); } 
extern "C" { extern __declspec( dllimport ) wint_t __cdecl fputwc(__wchar_t, FILE *); } 
extern "C" { extern __declspec( dllimport ) wint_t __cdecl _fputwchar(__wchar_t); } 
extern "C" { extern __declspec( dllimport ) wint_t __cdecl getwc(FILE *); } 
extern "C" { inline __declspec( dllimport noinline ) wint_t __cdecl getwchar(); } 
extern "C" { extern __declspec( dllimport ) wint_t __cdecl putwc(__wchar_t, FILE *); } 
extern "C" { inline __declspec( dllimport noinline ) wint_t __cdecl putwchar(__wchar_t); } 
extern "C" { extern __declspec( dllimport ) wint_t __cdecl ungetwc(wint_t, FILE *); } 

extern "C" { extern __declspec( dllimport ) __wchar_t *__cdecl fgetws(__wchar_t *, int, FILE *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl fputws(const __wchar_t *, FILE *); } 
extern "C" { extern __declspec( dllimport ) __wchar_t *__cdecl _getws_s(__wchar_t *, size_t); } 
template<size_t _Size> inline __wchar_t *__cdecl _getws_s(__wchar_t (&)[_Size]); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _getws_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl _getws(__wchar_t *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _putws(const __wchar_t *); } 

extern "C" { extern __declspec( dllimport ) int __cdecl fwprintf(FILE *, const __wchar_t *, ...); } 

extern "C" { extern __declspec( dllimport ) int __cdecl fwprintf_s(FILE *, const __wchar_t *, ...); } 

extern "C" { extern __declspec( dllimport ) int __cdecl wprintf(const __wchar_t *, ...); } 

extern "C" { extern __declspec( dllimport ) int __cdecl wprintf_s(const __wchar_t *, ...); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _scwprintf(const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl vfwprintf(FILE *, const __wchar_t *, va_list); } 

extern "C" { extern __declspec( dllimport ) int __cdecl vfwprintf_s(FILE *, const __wchar_t *, va_list); } 

extern "C" { extern __declspec( dllimport ) int __cdecl vwprintf(const __wchar_t *, va_list); } 

extern "C" { extern __declspec( dllimport ) int __cdecl vwprintf_s(const __wchar_t *, va_list); } 



extern "C" { extern __declspec( dllimport ) int __cdecl swprintf_s(__wchar_t *, size_t, const __wchar_t *, ...); } 

__pragma( warning(push)) __pragma( warning(disable: 4793)) template<size_t _Size> inline int __cdecl swprintf_s(__wchar_t (&)[_Size], const __wchar_t *, ...); __pragma( warning(pop)) 

extern "C" { extern __declspec( dllimport ) int __cdecl vswprintf_s(__wchar_t *, size_t, const __wchar_t *, va_list); } 

template<size_t _Size> inline int __cdecl vswprintf_s(__wchar_t (&)[_Size], const __wchar_t *, va_list); 

extern "C" { extern __declspec( dllimport ) int __cdecl _swprintf_c(__wchar_t *, size_t, const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vswprintf_c(__wchar_t *, size_t, const __wchar_t *, va_list); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _snwprintf_s(__wchar_t *, size_t, size_t, const __wchar_t *, ...); } 
__pragma( warning(push)) __pragma( warning(disable: 4793)) template<size_t _Size> inline int __cdecl _snwprintf_s(__wchar_t (&)[_Size], size_t, const __wchar_t *, ...); __pragma( warning(pop)) 
extern "C" { extern __declspec( dllimport ) int __cdecl _vsnwprintf_s(__wchar_t *, size_t, size_t, const __wchar_t *, va_list); } 
template<size_t _Size> inline int __cdecl _vsnwprintf_s(__wchar_t (&)[_Size], size_t, const __wchar_t *, va_list); 
#pragma warning(push)
#pragma warning(disable:4793)
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _snwprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _snwprintf(__wchar_t *, size_t, const __wchar_t *, ...); } extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _vsnwprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _vsnwprintf(__wchar_t *, size_t, const __wchar_t *, va_list); } 
#pragma warning(pop)

extern "C" { extern __declspec( dllimport ) int __cdecl _fwprintf_p(FILE *, const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wprintf_p(const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vfwprintf_p(FILE *, const __wchar_t *, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vwprintf_p(const __wchar_t *, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _swprintf_p(__wchar_t *, size_t, const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vswprintf_p(__wchar_t *, size_t, const __wchar_t *, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _scwprintf_p(const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vscwprintf_p(const __wchar_t *, va_list); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _wprintf_l(const __wchar_t *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wprintf_p_l(const __wchar_t *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wprintf_s_l(const __wchar_t *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vwprintf_l(const __wchar_t *, _locale_t, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vwprintf_p_l(const __wchar_t *, _locale_t, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vwprintf_s_l(const __wchar_t *, _locale_t, va_list); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _fwprintf_l(FILE *, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _fwprintf_p_l(FILE *, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _fwprintf_s_l(FILE *, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vfwprintf_l(FILE *, const __wchar_t *, _locale_t, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vfwprintf_p_l(FILE *, const __wchar_t *, _locale_t, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vfwprintf_s_l(FILE *, const __wchar_t *, _locale_t, va_list); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _swprintf_c_l(__wchar_t *, size_t, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _swprintf_p_l(__wchar_t *, size_t, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _swprintf_s_l(__wchar_t *, size_t, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vswprintf_c_l(__wchar_t *, size_t, const __wchar_t *, _locale_t, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vswprintf_p_l(__wchar_t *, size_t, const __wchar_t *, _locale_t, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vswprintf_s_l(__wchar_t *, size_t, const __wchar_t *, _locale_t, va_list); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _scwprintf_l(const __wchar_t *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _scwprintf_p_l(const __wchar_t *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vscwprintf_p_l(const __wchar_t *, _locale_t, va_list); } 

extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _snwprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _snwprintf_l(__wchar_t *, size_t, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _snwprintf_s_l(__wchar_t *, size_t, size_t, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _vsnwprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _vsnwprintf_l(__wchar_t *, size_t, const __wchar_t *, _locale_t, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vsnwprintf_s_l(__wchar_t *, size_t, size_t, const __wchar_t *, _locale_t, va_list); } 
#line 537
#pragma warning(push)
#pragma warning(disable:4141 4996 4793)
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) int __cdecl _swprintf(__wchar_t *, const __wchar_t *, ...); } extern "C" { extern __declspec( dllimport ) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) int __cdecl _vswprintf(__wchar_t *, const __wchar_t *, va_list); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) int __cdecl __swprintf_l(__wchar_t *, const __wchar_t *, _locale_t, ...); } extern "C" { extern __declspec( dllimport ) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) int __cdecl __vswprintf_l(__wchar_t *, const __wchar_t *, _locale_t, va_list); } 
#pragma warning(pop)
#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\swprintf.inl"
#pragma warning( push )
#pragma warning( disable : 4793 4412 )
extern "C" { static __declspec( noinline ) __inline int swprintf(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, ...) 
{ 
auto va_list _Arglist; 
auto int _Ret; 
_Arglist = (va_list)(&(reinterpret_cast< const char &>(_Format))) + (((sizeof(_Format) + sizeof(int)) - (1)) & (~(sizeof(int) - (1)))); 
_Ret = _vswprintf_c_l(_String, _Count, _Format, 0, _Arglist); 
_Arglist = ((va_list)0); 
return _Ret; 
} } 
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4412 )
extern "C" { static __declspec( noinline ) __inline int __cdecl vswprintf(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, va_list _Ap) 
{ 
return _vswprintf_c_l(_String, _Count, _Format, 0, _Ap); 
} } 
#pragma warning( pop )




#pragma warning( push )
#pragma warning( disable : 4793 4412 )
extern "C" { static __declspec( noinline ) __inline int _swprintf_l(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, _locale_t _Plocinfo, ...) 
{ 
auto va_list _Arglist; 
auto int _Ret; 
_Arglist = (va_list)(&(reinterpret_cast< const char &>(_Plocinfo))) + (((sizeof(_Plocinfo) + sizeof(int)) - (1)) & (~(sizeof(int) - (1)))); 
_Ret = _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Arglist); 
_Arglist = ((va_list)0); 
return _Ret; 
} } 
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4412 )
extern "C" { static __declspec( noinline ) __inline int __cdecl _vswprintf_l(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, _locale_t _Plocinfo, va_list _Ap) 
{ 
return _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Ap); 
} } 
#pragma warning( pop )


#pragma warning( push )
#pragma warning( disable : 4996 )

#pragma warning( push )
#pragma warning( disable : 4793 4141 )
__declspec( noinline ) __inline __declspec(deprecated("This function or variable may be unsafe. Consider using swprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int swprintf(__wchar_t *_String, const __wchar_t *_Format, ...) 
{ 
auto va_list _Arglist; 
_Arglist = (va_list)(&(reinterpret_cast< const char &>(_Format))) + (((sizeof(_Format) + sizeof(int)) - (1)) & (~(sizeof(int) - (1)))); 
auto int _Ret = _vswprintf(_String, _Format, _Arglist); 
_Arglist = ((va_list)0); 
return _Ret; 
} 
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4141 )
__declspec( noinline ) __inline __declspec(deprecated("This function or variable may be unsafe. Consider using vswprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl vswprintf(__wchar_t *_String, const __wchar_t *_Format, va_list _Ap) 
{ 
return _vswprintf(_String, _Format, _Ap); 
} 
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4793 4141 )
__declspec( noinline ) __inline __declspec(deprecated("This function or variable may be unsafe. Consider using _swprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int _swprintf_l(__wchar_t *_String, const __wchar_t *_Format, _locale_t _Plocinfo, ...) 
{ 
auto va_list _Arglist; 
_Arglist = (va_list)(&(reinterpret_cast< const char &>(_Plocinfo))) + (((sizeof(_Plocinfo) + sizeof(int)) - (1)) & (~(sizeof(int) - (1)))); 
auto int _Ret = __vswprintf_l(_String, _Format, _Plocinfo, _Arglist); 
_Arglist = ((va_list)0); 
return _Ret; 
} 
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4141 )
__declspec( noinline ) __inline __declspec(deprecated("This function or variable may be unsafe. Consider using _vswprintf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _vswprintf_l(__wchar_t *_String, const __wchar_t *_Format, _locale_t _Plocinfo, va_list _Ap) 
{ 
return __vswprintf_l(_String, _Format, _Plocinfo, _Ap); 
} 
#pragma warning( pop )

#pragma warning( pop )
#line 561 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
extern "C" { extern __declspec( dllimport ) __wchar_t *__cdecl _wtempnam(const __wchar_t *, const __wchar_t *); } 
#line 567
extern "C" { extern __declspec( dllimport ) int __cdecl _vscwprintf(const __wchar_t *, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vscwprintf_l(const __wchar_t *, _locale_t, va_list); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using fwscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl fwscanf(FILE *, const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _fwscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _fwscanf_l(FILE *, const __wchar_t *, _locale_t, ...); } 

extern "C" { extern __declspec( dllimport ) int __cdecl fwscanf_s(FILE *, const __wchar_t *, ...); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _fwscanf_s_l(FILE *, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using swscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl swscanf(const __wchar_t *, const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _swscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _swscanf_l(const __wchar_t *, const __wchar_t *, _locale_t, ...); } 

extern "C" { extern __declspec( dllimport ) int __cdecl swscanf_s(const __wchar_t *, const __wchar_t *, ...); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _swscanf_s_l(const __wchar_t *, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _snwscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _snwscanf(const __wchar_t *, size_t, const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _snwscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _snwscanf_l(const __wchar_t *, size_t, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _snwscanf_s(const __wchar_t *, size_t, const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _snwscanf_s_l(const __wchar_t *, size_t, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using wscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl wscanf(const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _wscanf_l(const __wchar_t *, _locale_t, ...); } 

extern "C" { extern __declspec( dllimport ) int __cdecl wscanf_s(const __wchar_t *, ...); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _wscanf_s_l(const __wchar_t *, _locale_t, ...); } 
#pragma warning(pop)

extern "C" { extern __declspec( dllimport ) FILE *__cdecl _wfdopen(int, const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wfopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) FILE *__cdecl _wfopen(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wfopen_s(FILE **, const __wchar_t *, const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wfreopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) FILE *__cdecl _wfreopen(const __wchar_t *, const __wchar_t *, FILE *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wfreopen_s(FILE **, const __wchar_t *, const __wchar_t *, FILE *); } 



extern "C" { extern __declspec( dllimport ) void __cdecl _wperror(const __wchar_t *); } 

extern "C" { extern __declspec( dllimport ) FILE *__cdecl _wpopen(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wremove(const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wtmpnam_s(__wchar_t *, size_t); } 
template<size_t _Size> inline errno_t __cdecl _wtmpnam_s(__wchar_t (&)[_Size]); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wtmpnam_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl _wtmpnam(__wchar_t *); } 

extern "C" { extern __declspec( dllimport ) wint_t __cdecl _fgetwc_nolock(FILE *); } 
extern "C" { extern __declspec( dllimport ) wint_t __cdecl _fputwc_nolock(__wchar_t, FILE *); } 
extern "C" { extern __declspec( dllimport ) wint_t __cdecl _ungetwc_nolock(wint_t, FILE *); } 
#line 619
extern "C" { inline __declspec( dllimport noinline ) wint_t __cdecl getwchar() 
{ return fgetwc(__iob_func() + 0); } } 
extern "C" { inline __declspec( dllimport noinline ) wint_t __cdecl putwchar(__wchar_t _C) 
{ return fputwc(_C, __iob_func() + 1); } } 
#line 669
extern "C" { extern __declspec( dllimport ) void __cdecl _lock_file(FILE *); } 
extern "C" { extern __declspec( dllimport ) void __cdecl _unlock_file(FILE *); } 
#line 677
extern "C" { extern __declspec( dllimport ) int __cdecl _fclose_nolock(FILE *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _fflush_nolock(FILE *); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl _fread_nolock(void *, size_t, size_t, FILE *); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl _fread_nolock_s(void *, size_t, size_t, size_t, FILE *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _fseek_nolock(FILE *, long, int); } 
extern "C" { extern __declspec( dllimport ) long __cdecl _ftell_nolock(FILE *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _fseeki64_nolock(FILE *, __int64, int); } 
extern "C" { extern __declspec( dllimport ) __int64 __cdecl _ftelli64_nolock(FILE *); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl _fwrite_nolock(const void *, size_t, size_t, FILE *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _ungetc_nolock(int, FILE *); } 
#line 713
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _tempnam. See online help for details.")) char *__cdecl tempnam(const char *, const char *); } 
#line 719
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _fcloseall. See online help for details.")) int __cdecl fcloseall(); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _fdopen. See online help for details.")) FILE *__cdecl fdopen(int, const char *); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _fgetchar. See online help for details.")) int __cdecl fgetchar(); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _fileno. See online help for details.")) int __cdecl fileno(FILE *); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _flushall. See online help for details.")) int __cdecl flushall(); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _fputchar. See online help for details.")) int __cdecl fputchar(int); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _getw. See online help for details.")) int __cdecl getw(FILE *); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _putw. See online help for details.")) int __cdecl putw(int, FILE *); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _rmtmp. See online help for details.")) int __cdecl rmtmp(); } 
#line 736
#pragma pack ( pop )
#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\cstdio"
typedef FILE _iobuf; 



namespace std { 
using ::_iobuf;

using ::size_t;using ::fpos_t;using ::FILE;
using ::clearerr;using ::fclose;using ::feof;
using ::ferror;using ::fflush;using ::fgetc;
using ::fgetpos;using ::fgets;using ::fopen;
using ::fprintf;using ::fputc;using ::fputs;
using ::fread;using ::freopen;using ::fscanf;
using ::fseek;using ::fsetpos;using ::ftell;
using ::fwrite;using ::getc;using ::getchar;
using ::gets;using ::perror;
using ::putc;using ::putchar;
using ::printf;using ::puts;using ::remove;
using ::rename;using ::rewind;using ::scanf;
using ::setbuf;using ::setvbuf;using ::sprintf;
using ::sscanf;using ::tmpfile;using ::tmpnam;
using ::ungetc;using ::vfprintf;using ::vprintf;
using ::vsprintf;


}
#line 31 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"
#pragma pack ( push, 8 )
#line 56
extern "C" { typedef int (__cdecl *_onexit_t)(void); }
#line 82
extern "C" { typedef 
#line 79
struct _div_t { friend struct __cilk_s;
int quot; 
int rem; 
} div_t; }




extern "C" { typedef 
#line 84
struct _ldiv_t { friend struct __cilk_s;__CILK_METADATA(_ldiv_t, __CILK_VBASE_DETECT)
long quot; 
long rem; 
} ldiv_t; }
#line 101
#pragma pack ( 4 )


extern "C" { typedef 
#line 102
struct _LDOUBLE { friend struct __cilk_s;
unsigned char ld[10]; 
} _LDOUBLE; }
#pragma pack ( )
#line 123
extern "C" { typedef 
#line 121
struct _CRT_DOUBLE { friend struct __cilk_s;
double x; 
} _CRT_DOUBLE; }



extern "C" { typedef 
#line 125
struct _CRT_FLOAT { friend struct __cilk_s;
float f; 
} _CRT_FLOAT; }
#line 138
extern "C" { typedef 
#line 133
struct _LONGDOUBLE { friend struct __cilk_s;



long double x; 
} _LONGDOUBLE; }



#pragma pack ( 4 )


extern "C" { typedef 
#line 143
struct _LDBL12 { friend struct __cilk_s;
unsigned char ld12[12]; 
} _LDBL12; }
#pragma pack ( )
#line 166
extern "C" __declspec( dllimport ) int __mb_cur_max; 




extern "C" { extern __declspec( dllimport ) int __cdecl ___mb_cur_max_func(); } 
extern "C" { extern __declspec( dllimport ) int __cdecl ___mb_cur_max_l_func(_locale_t); } 
#line 211
extern "C" { typedef void (__cdecl *_purecall_handler)(void); }


extern "C" { extern __declspec( dllimport ) _purecall_handler __cdecl _set_purecall_handler(_purecall_handler); } 
extern "C" { extern __declspec( dllimport ) _purecall_handler __cdecl _get_purecall_handler(); } 
#line 239
extern "C" { typedef void (__cdecl *_invalid_parameter_handler)(const __wchar_t *, const __wchar_t *, const __wchar_t *, unsigned, uintptr_t); }


extern "C" { extern __declspec( dllimport ) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(_invalid_parameter_handler); } 
extern "C" { extern __declspec( dllimport ) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(); } 
#line 267
extern "C" { extern __declspec( dllimport ) int *__cdecl _errno(); } 


extern "C" { extern errno_t __cdecl _set_errno(int); } 
extern "C" { extern errno_t __cdecl _get_errno(int *); } 


extern "C" { extern __declspec( dllimport ) unsigned long *__cdecl __doserrno(); } 


extern "C" { extern errno_t __cdecl _set_doserrno(unsigned long); } 
extern "C" { extern errno_t __cdecl _get_doserrno(unsigned long *); } 


extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using strerror instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char **__cdecl __sys_errlist(); } 


extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using strerror instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int *__cdecl __sys_nerr(); } 




extern "C" { extern __declspec( dllimport ) int *__cdecl __p___argc(); } 
extern "C" { extern __declspec( dllimport ) char ***__cdecl __p___argv(); } 
extern "C" { extern __declspec( dllimport ) __wchar_t ***__cdecl __p___wargv(); } 
extern "C" { extern __declspec( dllimport ) char ***__cdecl __p__environ(); } 
extern "C" { extern __declspec( dllimport ) __wchar_t ***__cdecl __p__wenviron(); } 
extern "C" { extern __declspec( dllimport ) char **__cdecl __p__pgmptr(); } 
extern "C" { extern __declspec( dllimport ) __wchar_t **__cdecl __p__wpgmptr(); } 
#line 301
extern "C" __declspec( dllimport ) int __argc; 
extern "C" __declspec( dllimport ) char **__argv; 
extern "C" __declspec( dllimport ) __wchar_t **__wargv; 
#line 317
extern "C" __declspec( dllimport ) char **_environ; 
extern "C" __declspec( dllimport ) __wchar_t **_wenviron; 


extern "C" __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _get_pgmptr instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *_pgmptr; 
extern "C" __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _get_wpgmptr instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *_wpgmptr; 
#line 339
extern "C" { extern errno_t __cdecl _get_pgmptr(char **); } 
extern "C" { extern errno_t __cdecl _get_wpgmptr(__wchar_t **); } 



extern "C" __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _get_fmode instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int _fmode; 
#line 350
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _set_fmode(int); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _get_fmode(int *); } 
#line 360
template<class _CountofType, size_t _SizeOfArray> extern char (*__countof_helper(_CountofType (&)[_SizeOfArray]))[_SizeOfArray]; template<class _CountofType, size_t _SizeOfArray> extern char (* /* __cilk */ __cdecl __cilkfun___countof_helper(__cilk_box<_CountofType (&)[_SizeOfArray] > ))[_SizeOfArray]; 
#line 371
extern "C" { extern __declspec( dllimport ) void __cdecl exit(int); } 
extern "C" { extern __declspec( dllimport ) void __cdecl _exit(int); } 
extern "C" { extern __declspec( dllimport ) void __cdecl abort(); } 


extern "C" { extern __declspec( dllimport ) unsigned __cdecl _set_abort_behavior(unsigned, unsigned); } 



extern "C" { extern int __cdecl abs(int); } 
extern "C" { extern long __cdecl labs(long); } 


extern "C" { extern __int64 __cdecl _abs64(__int64); } 
#line 412
extern "C" { extern int __cdecl atexit(void (__cdecl *)(void)); } 



extern "C" { extern __declspec( dllimport ) double __cdecl atof(const char *); } 
extern "C" { extern __declspec( dllimport ) double __cdecl _atof_l(const char *, _locale_t); } 

extern "C" { extern __declspec( dllimport ) int __cdecl atoi(const char *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _atoi_l(const char *, _locale_t); } 
extern "C" { extern __declspec( dllimport ) long __cdecl atol(const char *); } 
extern "C" { extern __declspec( dllimport ) long __cdecl _atol_l(const char *, _locale_t); } 



extern "C" { extern __declspec( dllimport ) void *__cdecl bsearch_s(const void *, const void *, rsize_t, rsize_t, int (__cdecl *)(void *, const void *, const void *), void *); } 



extern "C" { extern __declspec( dllimport ) void *__cdecl bsearch(const void *, const void *, size_t, size_t, int (__cdecl *)(const void *, const void *)); } 




extern "C" { extern __declspec( dllimport ) void __cdecl qsort_s(void *, rsize_t, rsize_t, int (__cdecl *)(void *, const void *, const void *), void *); } 



extern "C" { extern __declspec( dllimport ) void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)(const void *, const void *)); } 



extern "C" { extern unsigned short __cdecl _byteswap_ushort(unsigned short); } 
extern "C" { extern unsigned long __cdecl _byteswap_ulong(unsigned long); } 
extern "C" { extern unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64); } 
extern "C" { extern __declspec( dllimport ) div_t __cdecl div(int, int); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _dupenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl getenv(const char *); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl getenv_s(size_t *, char *, rsize_t, const char *); } 

template<size_t _Size> inline errno_t __cdecl getenv_s(size_t *, char (&)[_Size], const char *); 
#line 457
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _dupenv_s(char **, size_t *, const char *); } 
#line 463
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _itoa_s(int, char *, size_t, int); } 
template<size_t _Size> inline errno_t __cdecl _itoa_s(int, char (&)[_Size], int); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _itoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl _itoa(int, char *, int); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _i64toa_s(__int64, char *, size_t, int); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _i64toa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl _i64toa(__int64, char *, int); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _ui64toa_s(unsigned __int64, char *, size_t, int); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _ui64toa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl _ui64toa(unsigned __int64, char *, int); } 
extern "C" { extern __declspec( dllimport ) __int64 __cdecl _atoi64(const char *); } 
extern "C" { extern __declspec( dllimport ) __int64 __cdecl _atoi64_l(const char *, _locale_t); } 
extern "C" { extern __declspec( dllimport ) __int64 __cdecl _strtoi64(const char *, char **, int); } 
extern "C" { extern __declspec( dllimport ) __int64 __cdecl _strtoi64_l(const char *, char **, int, _locale_t); } 
extern "C" { extern __declspec( dllimport ) unsigned __int64 __cdecl _strtoui64(const char *, char **, int); } 
extern "C" { extern __declspec( dllimport ) unsigned __int64 __cdecl _strtoui64_l(const char *, char **, int, _locale_t); } 
extern "C" { extern __declspec( dllimport ) ldiv_t __cdecl ldiv(long, long); } 



inline __declspec( noinline ) ldiv_t div(long _A1, long _A2) 
{ 
return ldiv(_A1, _A2); 
} 


extern "C" { extern __declspec( dllimport ) errno_t __cdecl _ltoa_s(long, char *, size_t, int); } 
template<size_t _Size> inline errno_t __cdecl _ltoa_s(long, char (&)[_Size], int); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _ltoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl _ltoa(long, char *, int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl mblen(const char *, size_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _mblen_l(const char *, size_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl _mbstrlen(const char *); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl _mbstrlen_l(const char *, _locale_t); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl _mbstrnlen(const char *, size_t); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl _mbstrnlen_l(const char *, size_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl mbtowc(__wchar_t *, const char *, size_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _mbtowc_l(__wchar_t *, const char *, size_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl mbstowcs_s(size_t *, __wchar_t *, size_t, const char *, size_t); } 
template<size_t _Size> inline errno_t __cdecl mbstowcs_s(size_t *, __wchar_t (&)[_Size], const char *, size_t); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using mbstowcs_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) size_t __cdecl mbstowcs(__wchar_t *, const char *, size_t); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl _mbstowcs_s_l(size_t *, __wchar_t *, size_t, const char *, size_t, _locale_t); } 
template<size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(size_t *, __wchar_t (&)[_Size], const char *, size_t, _locale_t); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _mbstowcs_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) size_t __cdecl _mbstowcs_l(__wchar_t *, const char *, size_t, _locale_t); } 

extern "C" { extern __declspec( dllimport ) int __cdecl rand(); } 




extern "C" { extern __declspec( dllimport ) int __cdecl _set_error_mode(int); } 

extern "C" { extern __declspec( dllimport ) void __cdecl srand(unsigned); } 
extern "C" { extern __declspec( dllimport ) double __cdecl strtod(const char *, char **); } 
extern "C" { extern __declspec( dllimport ) double __cdecl _strtod_l(const char *, char **, _locale_t); } 
extern "C" { extern __declspec( dllimport ) long __cdecl strtol(const char *, char **, int); } 
extern "C" { extern __declspec( dllimport ) long __cdecl _strtol_l(const char *, char **, int, _locale_t); } 
extern "C" { extern __declspec( dllimport ) unsigned long __cdecl strtoul(const char *, char **, int); } 
extern "C" { extern __declspec( dllimport ) unsigned long __cdecl _strtoul_l(const char *, char **, int, _locale_t); } 


extern "C" { extern __declspec( dllimport ) int __cdecl system(const char *); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl _ultoa_s(unsigned long, char *, size_t, int); } 
template<size_t _Size> inline errno_t __cdecl _ultoa_s(unsigned long, char (&)[_Size], int); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _ultoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl _ultoa(unsigned long, char *, int); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using wctomb_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl wctomb(char *, __wchar_t); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wctomb_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _wctomb_l(char *, __wchar_t, _locale_t); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl wctomb_s(int *, char *, rsize_t, __wchar_t); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wctomb_s_l(int *, char *, size_t, __wchar_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl wcstombs_s(size_t *, char *, size_t, const __wchar_t *, size_t); } 
template<size_t _Size> inline errno_t __cdecl wcstombs_s(size_t *, char (&)[_Size], const __wchar_t *, size_t); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using wcstombs_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) size_t __cdecl wcstombs(char *, const __wchar_t *, size_t); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wcstombs_s_l(size_t *, char *, size_t, const __wchar_t *, size_t, _locale_t); } 
template<size_t _Size> inline errno_t __cdecl _wcstombs_s_l(size_t *, char (&)[_Size], const __wchar_t *, size_t, _locale_t); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcstombs_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) size_t __cdecl _wcstombs_l(char *, const __wchar_t *, size_t, _locale_t); } 
#line 599
extern "C" { extern __declspec( dllimport noalias restrict ) void *__cdecl calloc(size_t, size_t); } 
extern "C" { extern __declspec( dllimport noalias ) void __cdecl free(void *); } 
extern "C" { extern __declspec( dllimport noalias restrict ) void *__cdecl malloc(size_t); } 
extern "C" { extern __declspec( dllimport noalias restrict ) void *__cdecl realloc(void *, size_t); } 
extern "C" { extern __declspec( dllimport noalias restrict ) void *__cdecl _recalloc(void *, size_t, size_t); } 
extern "C" { extern __declspec( dllimport noalias ) void __cdecl _aligned_free(void *); } 
extern "C" { extern __declspec( dllimport noalias restrict ) void *__cdecl _aligned_malloc(size_t, size_t); } 
extern "C" { extern __declspec( dllimport noalias restrict ) void *__cdecl _aligned_offset_malloc(size_t, size_t, size_t); } 
extern "C" { extern __declspec( dllimport noalias restrict ) void *__cdecl _aligned_realloc(void *, size_t, size_t); } 
extern "C" { extern __declspec( dllimport noalias restrict ) void *__cdecl _aligned_recalloc(void *, size_t, size_t, size_t); } 
extern "C" { extern __declspec( dllimport noalias restrict ) void *__cdecl _aligned_offset_realloc(void *, size_t, size_t, size_t); } 
extern "C" { extern __declspec( dllimport noalias restrict ) void *__cdecl _aligned_offset_recalloc(void *, size_t, size_t, size_t, size_t); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl _aligned_msize(void *, size_t, size_t); } 
#line 638
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _itow_s(int, __wchar_t *, size_t, int); } 
template<size_t _Size> inline errno_t __cdecl _itow_s(int, __wchar_t (&)[_Size], int); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _itow_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl _itow(int, __wchar_t *, int); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _ltow_s(long, __wchar_t *, size_t, int); } 
template<size_t _Size> inline errno_t __cdecl _ltow_s(long, __wchar_t (&)[_Size], int); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _ltow_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl _ltow(long, __wchar_t *, int); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _ultow_s(unsigned long, __wchar_t *, size_t, int); } 
template<size_t _Size> inline errno_t __cdecl _ultow_s(unsigned long, __wchar_t (&)[_Size], int); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _ultow_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl _ultow(unsigned long, __wchar_t *, int); } 
extern "C" { extern __declspec( dllimport ) double __cdecl wcstod(const __wchar_t *, __wchar_t **); } 
extern "C" { extern __declspec( dllimport ) double __cdecl _wcstod_l(const __wchar_t *, __wchar_t **, _locale_t); } 
extern "C" { extern __declspec( dllimport ) long __cdecl wcstol(const __wchar_t *, __wchar_t **, int); } 
extern "C" { extern __declspec( dllimport ) long __cdecl _wcstol_l(const __wchar_t *, __wchar_t **, int, _locale_t); } 
extern "C" { extern __declspec( dllimport ) unsigned long __cdecl wcstoul(const __wchar_t *, __wchar_t **, int); } 
extern "C" { extern __declspec( dllimport ) unsigned long __cdecl _wcstoul_l(const __wchar_t *, __wchar_t **, int, _locale_t); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wdupenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl _wgetenv(const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wgetenv_s(size_t *, __wchar_t *, size_t, const __wchar_t *); } 
template<size_t _Size> inline errno_t __cdecl _wgetenv_s(size_t *, __wchar_t (&)[_Size], const __wchar_t *); 
#line 662
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wdupenv_s(__wchar_t **, size_t *, const __wchar_t *); } 
#line 670
extern "C" { extern __declspec( dllimport ) int __cdecl _wsystem(const __wchar_t *); } 

extern "C" { extern __declspec( dllimport ) double __cdecl _wtof(const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) double __cdecl _wtof_l(const __wchar_t *, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wtoi(const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wtoi_l(const __wchar_t *, _locale_t); } 
extern "C" { extern __declspec( dllimport ) long __cdecl _wtol(const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) long __cdecl _wtol_l(const __wchar_t *, _locale_t); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl _i64tow_s(__int64, __wchar_t *, size_t, int); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _i64tow_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl _i64tow(__int64, __wchar_t *, int); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _ui64tow_s(unsigned __int64, __wchar_t *, size_t, int); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _ui64tow_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl _ui64tow(unsigned __int64, __wchar_t *, int); } 
extern "C" { extern __declspec( dllimport ) __int64 __cdecl _wtoi64(const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) __int64 __cdecl _wtoi64_l(const __wchar_t *, _locale_t); } 
extern "C" { extern __declspec( dllimport ) __int64 __cdecl _wcstoi64(const __wchar_t *, __wchar_t **, int); } 
extern "C" { extern __declspec( dllimport ) __int64 __cdecl _wcstoi64_l(const __wchar_t *, __wchar_t **, int, _locale_t); } 
extern "C" { extern __declspec( dllimport ) unsigned __int64 __cdecl _wcstoui64(const __wchar_t *, __wchar_t **, int); } 
extern "C" { extern __declspec( dllimport ) unsigned __int64 __cdecl _wcstoui64_l(const __wchar_t *, __wchar_t **, int, _locale_t); } 
#line 708
extern "C" { extern __declspec( dllimport ) char *__cdecl _fullpath(char *, const char *, size_t); } 
#line 716
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _ecvt_s(char *, size_t, double, int, int *, int *); } 
template<size_t _Size> inline errno_t __cdecl _ecvt_s(char (&)[_Size], double, int, int *, int *); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _ecvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl _ecvt(double, int, int *, int *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _fcvt_s(char *, size_t, double, int, int *, int *); } 
template<size_t _Size> inline errno_t __cdecl _fcvt_s(char (&)[_Size], double, int, int *, int *); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _fcvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl _fcvt(double, int, int *, int *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _gcvt_s(char *, size_t, double, int); } 
template<size_t _Size> inline errno_t __cdecl _gcvt_s(char (&)[_Size], double, int); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _gcvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl _gcvt(double, int, char *); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _atodbl(_CRT_DOUBLE *, char *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _atoldbl(_LDOUBLE *, char *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _atoflt(_CRT_FLOAT *, char *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _atodbl_l(_CRT_DOUBLE *, char *, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _atoldbl_l(_LDOUBLE *, char *, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _atoflt_l(_CRT_FLOAT *, char *, _locale_t); } 
extern "C" { extern unsigned long __cdecl _lrotl(unsigned long, int); } 
extern "C" { extern unsigned long __cdecl _lrotr(unsigned long, int); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _makepath_s(char *, size_t, const char *, const char *, const char *, const char *); } 

template<size_t _Size> inline errno_t __cdecl _makepath_s(char (&)[_Size], const char *, const char *, const char *, const char *); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _makepath_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) void __cdecl _makepath(char *, const char *, const char *, const char *, const char *); } 
#line 764
extern "C" { extern _onexit_t __cdecl _onexit(_onexit_t); } 
#line 772
#pragma warning (push)
#pragma warning (disable:6540)
extern "C" { extern __declspec( dllimport ) int __cdecl _putenv(const char *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _putenv_s(const char *, const char *); } 
extern "C" { extern unsigned __cdecl _rotl(unsigned, int); } 
extern "C" { extern unsigned __int64 __cdecl _rotl64(unsigned __int64, int); } 
extern "C" { extern unsigned __cdecl _rotr(unsigned, int); } 
extern "C" { extern unsigned __int64 __cdecl _rotr64(unsigned __int64, int); } 
#pragma warning (pop)

extern "C" { extern __declspec( dllimport ) errno_t __cdecl _searchenv_s(const char *, const char *, char *, size_t); } 
template<size_t _Size> inline errno_t __cdecl _searchenv_s(const char *, const char *, char (&)[_Size]); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _searchenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) void __cdecl _searchenv(const char *, const char *, char *); } 

extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _splitpath_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) void __cdecl _splitpath(const char *, char *, char *, char *, char *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _splitpath_s(const char *, char *, size_t, char *, size_t, char *, size_t, char *, size_t); } 




template<size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s(const char *, char (&)[_DriveSize], char (&)[_DirSize], char (&)[_NameSize], char (&)[_ExtSize]); 

extern "C" { extern __declspec( dllimport ) void __cdecl _swab(char *, char *, int); } 
#line 805
extern "C" { extern __declspec( dllimport ) __wchar_t *__cdecl _wfullpath(__wchar_t *, const __wchar_t *, size_t); } 
#line 811
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wmakepath_s(__wchar_t *, size_t, const __wchar_t *, const __wchar_t *, const __wchar_t *, const __wchar_t *); } 

template<size_t _Size> inline errno_t __cdecl _wmakepath_s(__wchar_t (&)[_Size], const __wchar_t *, const __wchar_t *, const __wchar_t *, const __wchar_t *); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wmakepath_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) void __cdecl _wmakepath(__wchar_t *, const __wchar_t *, const __wchar_t *, const __wchar_t *, const __wchar_t *); } 




extern "C" { extern __declspec( dllimport ) int __cdecl _wputenv(const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wputenv_s(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wsearchenv_s(const __wchar_t *, const __wchar_t *, __wchar_t *, size_t); } 
template<size_t _Size> inline errno_t __cdecl _wsearchenv_s(const __wchar_t *, const __wchar_t *, __wchar_t (&)[_Size]); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wsearchenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) void __cdecl _wsearchenv(const __wchar_t *, const __wchar_t *, __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wsplitpath_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) void __cdecl _wsplitpath(const __wchar_t *, __wchar_t *, __wchar_t *, __wchar_t *, __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wsplitpath_s(const __wchar_t *, __wchar_t *, size_t, __wchar_t *, size_t, __wchar_t *, size_t, __wchar_t *, size_t); } 




template<size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s(const __wchar_t *, __wchar_t (&)[_DriveSize], __wchar_t (&)[_DirSize], __wchar_t (&)[_NameSize], __wchar_t (&)[_ExtSize]); 
#line 836
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using SetErrorMode instead. See online help for details.")) void __cdecl _seterrormode(int); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Beep instead. See online help for details.")) void __cdecl _beep(unsigned, unsigned); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Sleep instead. See online help for details.")) void __cdecl _sleep(unsigned long); } 
#line 857
#pragma warning(push)
#pragma warning(disable: 4141)
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _ecvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl ecvt(double, int, int *, int *); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _fcvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl fcvt(double, int, int *, int *); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _fcvt_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl gcvt(double, int, char *); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _itoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl itoa(int, char *, int); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _ltoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl ltoa(long, char *, int); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _putenv. See online help for details.")) int __cdecl putenv(const char *); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _swab. See online help for details.")) void __cdecl swab(char *, char *, int); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _ultoa_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl ultoa(unsigned long, char *, int); } 
#pragma warning(pop)
extern "C" { extern _onexit_t __cdecl onexit(_onexit_t); } 
#line 880
#pragma pack ( pop )
#line 19 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\cstdlib"
namespace std { 

using ::div_t;using ::ldiv_t;

using ::abort;using ::abs;using ::atexit;
using ::atof;using ::atoi;using ::atol;
using ::bsearch;using ::calloc;using ::div;
using ::exit;using ::free;using ::getenv;
using ::labs;using ::ldiv;using ::malloc;
using ::mblen;using ::mbstowcs;using ::mbtowc;
using ::qsort;using ::rand;using ::realloc;
using ::srand;using ::strtod;using ::strtol;
using ::strtoul;using ::system;
using ::wcstombs;using ::wctomb;


}
#line 48 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"
extern "C" { extern __declspec( dllimport ) void *__cdecl _memccpy(void *, const void *, int, size_t); } 
extern "C" { extern __declspec( dllimport ) const void *__cdecl memchr(const void *, int, size_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _memicmp(const void *, const void *, size_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _memicmp_l(const void *, const void *, size_t, _locale_t); } 
extern "C" { extern int __cdecl memcmp(const void *, const void *, size_t); } 
extern "C" { extern void *__cdecl memcpy(void *, const void *, size_t); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl memcpy_s(void *, rsize_t, const void *, rsize_t); } 

extern "C" { extern void *__cdecl memset(void *, int, size_t); } 



extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _memccpy. See online help for details.")) void *__cdecl memccpy(void *, const void *, int, size_t); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _memicmp. See online help for details.")) int __cdecl memicmp(const void *, const void *, size_t); } 




extern "C" { extern __declspec( dllimport ) errno_t __cdecl _strset_s(char *, size_t, int); } 
template<size_t _Size> inline errno_t __cdecl _strset_s(char (&)[_Size], int); 
extern "C" { extern __declspec(deprecated("This function or variable may be unsafe. Consider using _strset_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl _strset(char *, int); } 

extern "C" __declspec( dllimport ) errno_t __cdecl strcpy_s(char *, rsize_t, const char *); 

template<size_t _Size> inline errno_t __cdecl strcpy_s(char (&)[_Size], const char *); 
extern "C" { extern __declspec(deprecated("This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl strcpy(char *, const char *); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl strcat_s(char *, rsize_t, const char *); } 

template<size_t _Size> inline errno_t __cdecl strcat_s(char (&)[_Size], const char *); 
extern "C" { extern __declspec(deprecated("This function or variable may be unsafe. Consider using strcat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl strcat(char *, const char *); } 
extern "C" { extern int __cdecl strcmp(const char *, const char *); } 
extern "C" size_t __cdecl strlen(const char *); 
extern "C" { extern __declspec( dllimport ) size_t __cdecl strnlen(const char *, size_t); } 

extern "C" { static __declspec( noinline ) __inline size_t __cdecl strnlen_s(const char *_Str, size_t _MaxCount) 
{ 
return (_Str == (0)) ? (0) : strnlen(_Str, _MaxCount); 
} } 


extern "C" { extern __declspec( dllimport ) errno_t __cdecl memmove_s(void *, rsize_t, const void *, rsize_t); } 
#line 96
extern "C" { extern __declspec( dllimport ) void *__cdecl memmove(void *, const void *, size_t); } 
#line 104
extern "C" { extern __declspec( dllimport ) char *__cdecl _strdup(const char *); } 
#line 110
extern "C" { extern __declspec( dllimport ) const char *__cdecl strchr(const char *, int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _stricmp(const char *, const char *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _strcmpi(const char *, const char *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _stricmp_l(const char *, const char *, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl strcoll(const char *, const char *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _strcoll_l(const char *, const char *, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _stricoll(const char *, const char *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _stricoll_l(const char *, const char *, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _strncoll(const char *, const char *, size_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _strncoll_l(const char *, const char *, size_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _strnicoll(const char *, const char *, size_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _strnicoll_l(const char *, const char *, size_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl strcspn(const char *, const char *); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _strerror_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl _strerror(const char *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _strerror_s(char *, size_t, const char *); } 
template<size_t _Size> inline errno_t __cdecl _strerror_s(char (&)[_Size], const char *); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using strerror_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl strerror(int); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl strerror_s(char *, size_t, int); } 

template<size_t _Size> inline errno_t __cdecl strerror_s(char (&)[_Size], int); 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _strlwr_s(char *, size_t); } 
template<size_t _Size> inline errno_t __cdecl _strlwr_s(char (&)[_Size]); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _strlwr_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl _strlwr(char *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _strlwr_s_l(char *, size_t, _locale_t); } 
template<size_t _Size> inline errno_t __cdecl _strlwr_s_l(char (&)[_Size], _locale_t); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _strlwr_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl _strlwr_l(char *, _locale_t); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl strncat_s(char *, rsize_t, const char *, rsize_t); } 

template<size_t _Size> inline errno_t __cdecl strncat_s(char (&)[_Size], const char *, size_t); 
#pragma warning(push)
#pragma warning(disable:6059)

extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using strncat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl strncat(char *, const char *, size_t); } 
#pragma warning(pop)



extern "C" { extern __declspec( dllimport ) int __cdecl strncmp(const char *, const char *, size_t); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _strnicmp(const char *, const char *, size_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _strnicmp_l(const char *, const char *, size_t, _locale_t); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl strncpy_s(char *, rsize_t, const char *, rsize_t); } 

template<size_t _Size> inline errno_t __cdecl strncpy_s(char (&)[_Size], const char *, size_t); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using strncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl strncpy(char *, const char *, size_t); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _strnset_s(char *, size_t, int, size_t); } 
template<size_t _Size> inline errno_t __cdecl _strnset_s(char (&)[_Size], int, size_t); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _strnset_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl _strnset(char *, int, size_t); } 
extern "C" { extern __declspec( dllimport ) const char *__cdecl strpbrk(const char *, const char *); } 
extern "C" { extern __declspec( dllimport ) const char *__cdecl strrchr(const char *, int); } 
extern "C" { extern __declspec( dllimport ) char *__cdecl _strrev(char *); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl strspn(const char *, const char *); } 
extern "C" { extern __declspec( dllimport ) const char *__cdecl strstr(const char *, const char *); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using strtok_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl strtok(char *, const char *); } 

extern "C" { extern __declspec( dllimport ) char *__cdecl strtok_s(char *, const char *, char **); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl _strupr_s(char *, size_t); } 
template<size_t _Size> inline errno_t __cdecl _strupr_s(char (&)[_Size]); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _strupr_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl _strupr(char *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _strupr_s_l(char *, size_t, _locale_t); } 
template<size_t _Size> inline errno_t __cdecl _strupr_s_l(char (&)[_Size], _locale_t); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _strupr_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl _strupr_l(char *, _locale_t); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl strxfrm(char *, const char *, size_t); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl _strxfrm_l(char *, const char *, size_t, _locale_t); } 
#line 183
inline __declspec( noinline ) char *__cdecl strchr(char *_Str, int _Ch) 
{ return (char *)strchr((const char *)_Str, _Ch); } 
inline __declspec( noinline ) char *__cdecl strpbrk(char *_Str, const char *_Control) 
{ return (char *)strpbrk((const char *)_Str, _Control); } 
inline __declspec( noinline ) char *__cdecl strrchr(char *_Str, int _Ch) 
{ return (char *)strrchr((const char *)_Str, _Ch); } 
inline __declspec( noinline ) char *__cdecl strstr(char *_Str, const char *_SubStr) 
{ return (char *)strstr((const char *)_Str, _SubStr); } 



inline __declspec( noinline ) void *__cdecl memchr(void *_Pv, int _C, size_t _N) 
{ return (void *)memchr((const void *)_Pv, _C, _N); } 
#line 207
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _strdup. See online help for details.")) char *__cdecl strdup(const char *); } 
#line 214
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _strcmpi. See online help for details.")) int __cdecl strcmpi(const char *, const char *); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _stricmp. See online help for details.")) int __cdecl stricmp(const char *, const char *); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _strlwr. See online help for details.")) char *__cdecl strlwr(char *); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _strnicmp. See online help for details.")) int __cdecl strnicmp(const char *, const char *, size_t); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _strnset. See online help for details.")) char *__cdecl strnset(char *, int, size_t); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _strrev. See online help for details.")) char *__cdecl strrev(char *); } 
extern "C" { extern __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _strset. See online help for details.")) char *__cdecl strset(char *, int); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _strupr. See online help for details.")) char *__cdecl strupr(char *); } 
#line 235
extern "C" { extern __declspec( dllimport ) __wchar_t *__cdecl _wcsdup(const __wchar_t *); } 
#line 242
extern "C" { extern __declspec( dllimport ) errno_t __cdecl wcscat_s(__wchar_t *, rsize_t, const __wchar_t *); } 

template<size_t _Size> inline errno_t __cdecl wcscat_s(__wchar_t (&)[_Size], const __wchar_t *); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using wcscat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl wcscat(__wchar_t *, const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) const __wchar_t *__cdecl wcschr(const __wchar_t *, __wchar_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl wcscmp(const __wchar_t *, const __wchar_t *); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl wcscpy_s(__wchar_t *, rsize_t, const __wchar_t *); } 

template<size_t _Size> inline errno_t __cdecl wcscpy_s(__wchar_t (&)[_Size], const __wchar_t *); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using wcscpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl wcscpy(__wchar_t *, const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl wcscspn(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl wcslen(const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl wcsnlen(const __wchar_t *, size_t); } 

extern "C" { static __declspec( noinline ) __inline size_t __cdecl wcsnlen_s(const __wchar_t *_Src, size_t _MaxCount) 
{ 
return (_Src == (0)) ? (0) : wcsnlen(_Src, _MaxCount); 
} } 


extern "C" { extern __declspec( dllimport ) errno_t __cdecl wcsncat_s(__wchar_t *, rsize_t, const __wchar_t *, rsize_t); } 

template<size_t _Size> inline errno_t __cdecl wcsncat_s(__wchar_t (&)[_Size], const __wchar_t *, size_t); 
#pragma warning(push)
#pragma warning(disable:6059)
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using wcsncat_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl wcsncat(__wchar_t *, const __wchar_t *, size_t); } 
#pragma warning(pop)
extern "C" { extern __declspec( dllimport ) int __cdecl wcsncmp(const __wchar_t *, const __wchar_t *, size_t); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl wcsncpy_s(__wchar_t *, rsize_t, const __wchar_t *, rsize_t); } 

template<size_t _Size> inline errno_t __cdecl wcsncpy_s(__wchar_t (&)[_Size], const __wchar_t *, size_t); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using wcsncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl wcsncpy(__wchar_t *, const __wchar_t *, size_t); } 
extern "C" { extern __declspec( dllimport ) const __wchar_t *__cdecl wcspbrk(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) const __wchar_t *__cdecl wcsrchr(const __wchar_t *, __wchar_t); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl wcsspn(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) const __wchar_t *__cdecl wcsstr(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using wcstok_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl wcstok(__wchar_t *, const __wchar_t *); } 

extern "C" { extern __declspec( dllimport ) __wchar_t *__cdecl wcstok_s(__wchar_t *, const __wchar_t *, __wchar_t **); } 

extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcserror_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl _wcserror(int); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wcserror_s(__wchar_t *, size_t, int); } 
template<size_t _Size> inline errno_t __cdecl _wcserror_s(__wchar_t (&)[_Size], int); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using __wcserror_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl __wcserror(const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl __wcserror_s(__wchar_t *, size_t, const __wchar_t *); } 
template<size_t _Size> inline errno_t __cdecl __wcserror_s(__wchar_t (&)[_Size], const __wchar_t *); 

extern "C" { extern __declspec( dllimport ) int __cdecl _wcsicmp(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wcsicmp_l(const __wchar_t *, const __wchar_t *, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wcsnicmp(const __wchar_t *, const __wchar_t *, size_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wcsnicmp_l(const __wchar_t *, const __wchar_t *, size_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wcsnset_s(__wchar_t *, size_t, __wchar_t, size_t); } 
template<size_t _Size> inline errno_t __cdecl _wcsnset_s(__wchar_t (&)[_Size], __wchar_t, size_t); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcsnset_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl _wcsnset(__wchar_t *, __wchar_t, size_t); } 
extern "C" { extern __declspec( dllimport ) __wchar_t *__cdecl _wcsrev(__wchar_t *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wcsset_s(__wchar_t *, size_t, __wchar_t); } 
template<size_t _Size> inline errno_t __cdecl _wcsset_s(__wchar_t (&)[_Size], __wchar_t); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcsset_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl _wcsset(__wchar_t *, __wchar_t); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wcslwr_s(__wchar_t *, size_t); } 
template<size_t _Size> inline errno_t __cdecl _wcslwr_s(__wchar_t (&)[_Size]); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcslwr_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl _wcslwr(__wchar_t *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wcslwr_s_l(__wchar_t *, size_t, _locale_t); } 
template<size_t _Size> inline errno_t __cdecl _wcslwr_s_l(__wchar_t (&)[_Size], _locale_t); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcslwr_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl _wcslwr_l(__wchar_t *, _locale_t); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wcsupr_s(__wchar_t *, size_t); } 
template<size_t _Size> inline errno_t __cdecl _wcsupr_s(__wchar_t (&)[_Size]); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcsupr_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl _wcsupr(__wchar_t *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wcsupr_s_l(__wchar_t *, size_t, _locale_t); } 
template<size_t _Size> inline errno_t __cdecl _wcsupr_s_l(__wchar_t (&)[_Size], _locale_t); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wcsupr_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl _wcsupr_l(__wchar_t *, _locale_t); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl wcsxfrm(__wchar_t *, const __wchar_t *, size_t); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl _wcsxfrm_l(__wchar_t *, const __wchar_t *, size_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl wcscoll(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wcscoll_l(const __wchar_t *, const __wchar_t *, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wcsicoll(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wcsicoll_l(const __wchar_t *, const __wchar_t *, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wcsncoll(const __wchar_t *, const __wchar_t *, size_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wcsncoll_l(const __wchar_t *, const __wchar_t *, size_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wcsnicoll(const __wchar_t *, const __wchar_t *, size_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wcsnicoll_l(const __wchar_t *, const __wchar_t *, size_t, _locale_t); } 
#line 330
inline __declspec( noinline ) __wchar_t *__cdecl wcschr(__wchar_t *_Str, __wchar_t _Ch) 
{ return (__wchar_t *)wcschr((const __wchar_t *)_Str, _Ch); } 
inline __declspec( noinline ) __wchar_t *__cdecl wcspbrk(__wchar_t *_Str, const __wchar_t *_Control) 
{ return (__wchar_t *)wcspbrk((const __wchar_t *)_Str, _Control); } 
inline __declspec( noinline ) __wchar_t *__cdecl wcsrchr(__wchar_t *_Str, __wchar_t _Ch) 
{ return (__wchar_t *)wcsrchr((const __wchar_t *)_Str, _Ch); } 
inline __declspec( noinline ) __wchar_t *__cdecl wcsstr(__wchar_t *_Str, const __wchar_t *_SubStr) 
{ return (__wchar_t *)wcsstr((const __wchar_t *)_Str, _SubStr); } 
#line 349
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _wcsdup. See online help for details.")) __wchar_t *__cdecl wcsdup(const __wchar_t *); } 
#line 359
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _wcsicmp. See online help for details.")) int __cdecl wcsicmp(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _wcsnicmp. See online help for details.")) int __cdecl wcsnicmp(const __wchar_t *, const __wchar_t *, size_t); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _wcsnset. See online help for details.")) __wchar_t *__cdecl wcsnset(__wchar_t *, __wchar_t, size_t); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _wcsrev. See online help for details.")) __wchar_t *__cdecl wcsrev(__wchar_t *); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _wcsset. See online help for details.")) __wchar_t *__cdecl wcsset(__wchar_t *, __wchar_t); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _wcslwr. See online help for details.")) __wchar_t *__cdecl wcslwr(__wchar_t *); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _wcsupr. See online help for details.")) __wchar_t *__cdecl wcsupr(__wchar_t *); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _wcsicoll. See online help for details.")) int __cdecl wcsicoll(const __wchar_t *, const __wchar_t *); } 
#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\cstring"
namespace std { 
using ::memchr;using ::memcmp;

using ::memcpy;using ::memmove;using ::memset;
using ::strcat;using ::strchr;using ::strcmp;
using ::strcoll;using ::strcpy;using ::strcspn;
using ::strerror;using ::strlen;using ::strncat;
using ::strncmp;using ::strncpy;using ::strpbrk;
using ::strrchr;using ::strspn;using ::strstr;
using ::strtok;using ::strxfrm;

}
#line 68 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stddef.h"
extern "C" { extern __declspec( dllimport ) unsigned long __cdecl __threadid(); } 

extern "C" { extern __declspec( dllimport ) uintptr_t __cdecl __threadhandle(); } 
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\cstddef"
namespace std { 
using ::ptrdiff_t;
}
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xstddef"
#pragma warning(push,3)
#line 13
#pragma pack ( push, 8 )



namespace std { 
#line 92
enum _Uninitialized { 

_Noinit}; 
}

#pragma warning(pop)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\exception"
#pragma warning(push,3)
#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xstddef"
#pragma pack ( pop )
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\exception"
#pragma pack ( push, 8 )
#line 23
namespace std { 
#line 36
}
#line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\eh.h"
#pragma pack ( push, 8 )
#line 35
typedef void (__cdecl *terminate_function)(void); 
typedef void (__cdecl *terminate_handler)(void); 
typedef void (__cdecl *unexpected_function)(void); 
typedef void (__cdecl *unexpected_handler)(void); 
#line 53
struct _EXCEPTION_POINTERS; 

typedef void (__cdecl *_se_translator_function)(unsigned, _EXCEPTION_POINTERS *); 


extern __declspec( dllimport ) void __cdecl terminate(); 
extern __declspec( dllimport ) void __cdecl unexpected(); 

extern __declspec( dllimport ) int __cdecl _is_exception_typeof(const class type_info &, _EXCEPTION_POINTERS *); 



extern __declspec( dllimport ) terminate_function __cdecl set_terminate(terminate_function); 
extern "C" __declspec( dllimport ) terminate_function __cdecl _get_terminate(); 
extern __declspec( dllimport ) unexpected_function __cdecl set_unexpected(unexpected_function); 
extern "C" __declspec( dllimport ) unexpected_function __cdecl _get_unexpected(); 




extern __declspec( dllimport ) _se_translator_function __cdecl _set_se_translator(_se_translator_function); 

extern __declspec( dllimport ) bool __cdecl __uncaught_exception(); 
#line 91
#pragma pack ( pop )
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\malloc.h"
#pragma pack ( push, 8 )
#line 66
extern "C" { typedef 
#line 62
struct _heapinfo { friend struct __cilk_s;
int *_pentry; 
size_t _size; 
int _useflag; 
} _HEAPINFO; }
#line 73
extern "C" __declspec(deprecated("This function or variable may be unsafe. Consider using _get_amblksiz instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) unsigned _amblksiz; 
#line 149
extern "C" { extern __declspec( dllimport ) int __cdecl _resetstkoflw(); } 



extern "C" { extern __declspec( dllimport ) unsigned long __cdecl _set_malloc_crt_max_wait(unsigned long); } 
#line 164
extern "C" { extern __declspec( dllimport ) void *__cdecl _expand(void *, size_t); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl _msize(void *); } 
#line 172
extern "C" { extern void *__cdecl _alloca(size_t); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl _get_sbh_threshold(); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _set_sbh_threshold(size_t); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _set_amblksiz(size_t); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _get_amblksiz(size_t *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _heapadd(void *, size_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _heapchk(); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _heapmin(); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _heapset(unsigned); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _heapwalk(_HEAPINFO *); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl _heapused(size_t *, size_t *); } 

extern "C" { extern __declspec( dllimport ) intptr_t __cdecl _get_heap_handle(); } 
#line 198
extern "C" { typedef char __static_assert_t[(sizeof(unsigned) <= (8))]; }


#pragma warning(push)
#pragma warning(disable:6540)
extern "C" { __inline void *_MarkAllocaS(void *_Ptr, unsigned _Marker) 
{ 
if (_Ptr) 
{ 
(*((unsigned *)_Ptr)) = _Marker; 
_Ptr = (char *)_Ptr + 8; 
}  
return _Ptr; 
} } 
#pragma warning(pop)
#line 238
extern "C" { __declspec( noinline noalias ) __inline void __cdecl _freea(void *_Memory) 
{ 
auto unsigned _Marker; 
if (_Memory) 
{ 
_Memory = (char *)_Memory - 8; 
_Marker = *((unsigned *)_Memory); 
if (_Marker == (56797)) 
{ 
free(_Memory); 
}  
#line 255
}  
} } 
#line 292
#pragma pack ( pop )
#line 82 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\exception"
typedef const char *__exString; 
extern "C" size_t __cdecl strlen(const char *); 

extern "C" __declspec( dllimport ) errno_t __cdecl strcpy_s(char *, size_t, const char *); 
#line 92
namespace std { 

class __declspec( dllimport ) exception { friend struct __cilk_s;__CILK_METADATA(exception, __CILK_VBASE_DETECT)
#line 195
public: exception(); 
exception(const char *const &); 
exception(const char *const &, int); 
exception(const exception &); 
exception &operator=(const exception &); 
virtual ~exception(); 
virtual const char *what() const; 


private: const char *_m_what; 
int _m_doFree; 
}; 

using ::set_terminate;using ::terminate_handler;using ::terminate;using ::set_unexpected;using ::unexpected_handler;using ::unexpected;

typedef void (__cdecl *_Prhand)(const exception &); 
#line 216
extern __declspec( dllimport ) bool __cdecl uncaught_exception(); 


}
#line 333
namespace std { 
#line 339
class bad_exception : public exception { friend struct __cilk_s;__CILK_METADATA(bad_exception, __CILK_VBASE_DETECT)


public: inline __declspec( noinline ) bad_exception(const char * = ("bad exception")) throw(); 
#line 348
inline virtual __declspec( noinline ) ~bad_exception() throw(); 
#line 360
}; 
#line 342
inline __declspec( noinline ) bad_exception::bad_exception(const char *_Message) throw() : exception(_Message) 


{ 
} 

inline __declspec( noinline ) bad_exception::~bad_exception() throw() 
{ 
} 
#line 363
static const char *_bad_alloc_Message = ("bad allocation"); 


class bad_alloc : public exception { friend struct __cilk_s;__CILK_METADATA(bad_alloc, __CILK_VBASE_DETECT)


public: inline __declspec( noinline ) bad_alloc(const char *) throw(); 




inline __declspec( noinline ) bad_alloc() throw(); 




inline virtual __declspec( noinline ) ~bad_alloc() throw(); 
#line 391
}; 
#line 369
inline __declspec( noinline ) bad_alloc::bad_alloc(const char *_Message) throw() : exception(_Message) 

{ 
} 

inline __declspec( noinline ) bad_alloc::bad_alloc() throw() : exception(_bad_alloc_Message, 1) 

{ 
} 

inline __declspec( noinline ) bad_alloc::~bad_alloc() throw() 
{ 
} 
#line 394
}
#line 413
#pragma warning(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\new"
#pragma warning(push,3)
#line 414 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\exception"
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\new"
#pragma pack ( push, 8 )
#line 25
namespace std { 
#line 33
typedef void (__cdecl *new_handler)(void); 




struct nothrow_t { friend struct __cilk_s;

}; 

extern const nothrow_t nothrow; 



extern __declspec( dllimport ) new_handler __cdecl set_new_handler(new_handler) throw(); 

}


extern void __cdecl operator delete(void *) throw(); 
#pragma warning (suppress: 4985)
extern void *__cdecl operator new(size_t); 



inline void *__cdecl operator new(size_t __T12072560, void *_Where) throw() 
{ 
return _Where; 
} 

inline void __cdecl operator delete(void *__T12073212, void *__T12073304) throw() 
{ 
} 




inline void *__cdecl operator new[](size_t __T12073780, void *_Where) throw() 
{ 
return _Where; 
} 

inline void __cdecl operator delete[](void *__T12074432, void *__T12074524) throw() 
{ 
} 


extern void __cdecl operator delete[](void *) throw(); 

extern void *__cdecl operator new[](size_t); 




extern void *__cdecl operator new(size_t, const std::nothrow_t &) throw(); 


extern void *__cdecl operator new[](size_t, const std::nothrow_t &) throw(); 


extern void __cdecl operator delete(void *, const std::nothrow_t &) throw(); 


extern void __cdecl operator delete[](void *, const std::nothrow_t &) throw(); 
#line 101
using std::new_handler;




#pragma warning(pop)
#pragma pack ( pop )
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\wchar.h"
#pragma pack ( push, 8 )
#line 88
extern "C" { typedef unsigned long _fsize_t; }
#line 94
extern "C" { struct _wfinddata32_t { friend struct __cilk_s;
unsigned attrib; 
__time32_t time_create; 
__time32_t time_access; 
__time32_t time_write; 
_fsize_t size; 
__wchar_t name[260]; 
}; }

extern "C" { struct _wfinddata32i64_t { friend struct __cilk_s;
unsigned attrib; 
__time32_t time_create; 
__time32_t time_access; 
__time32_t time_write; 
__int64 size; 
__wchar_t name[260]; 
}; }

extern "C" { struct _wfinddata64i32_t { friend struct __cilk_s;
unsigned attrib; 
__time64_t time_create; 
__time64_t time_access; 
__time64_t time_write; 
_fsize_t size; 
__wchar_t name[260]; 
}; }

extern "C" { struct _wfinddata64_t { friend struct __cilk_s;
unsigned attrib; 
__time64_t time_create; 
__time64_t time_access; 
__time64_t time_write; 
__int64 size; 
__wchar_t name[260]; 
}; }
#line 187
extern "C" { extern __declspec( dllimport ) const unsigned short *__cdecl __pctype_func(); } 

extern "C" __declspec( dllimport ) const unsigned short *_pctype; 
#line 200
extern "C" __declspec( dllimport ) const unsigned short _wctype[]; 


extern "C" { extern __declspec( dllimport ) const wctype_t *__cdecl __pwctype_func(); } 

extern "C" __declspec( dllimport ) const wctype_t *_pwctype; 
#line 235
extern "C" { extern __declspec( dllimport ) int __cdecl iswalpha(wint_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _iswalpha_l(wint_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl iswupper(wint_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _iswupper_l(wint_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl iswlower(wint_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _iswlower_l(wint_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl iswdigit(wint_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _iswdigit_l(wint_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl iswxdigit(wint_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _iswxdigit_l(wint_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl iswspace(wint_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _iswspace_l(wint_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl iswpunct(wint_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _iswpunct_l(wint_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl iswalnum(wint_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _iswalnum_l(wint_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl iswprint(wint_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _iswprint_l(wint_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl iswgraph(wint_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _iswgraph_l(wint_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl iswcntrl(wint_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _iswcntrl_l(wint_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl iswascii(wint_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl isleadbyte(int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _isleadbyte_l(int, _locale_t); } 

extern "C" { extern __declspec( dllimport ) wint_t __cdecl towupper(wint_t); } 
extern "C" { extern __declspec( dllimport ) wint_t __cdecl _towupper_l(wint_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) wint_t __cdecl towlower(wint_t); } 
extern "C" { extern __declspec( dllimport ) wint_t __cdecl _towlower_l(wint_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl iswctype(wint_t, wctype_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _iswctype_l(wint_t, wctype_t, _locale_t); } 

extern "C" { extern __declspec( dllimport ) int __cdecl __iswcsymf(wint_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _iswcsymf_l(wint_t, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl __iswcsym(wint_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _iswcsym_l(wint_t, _locale_t); } 

extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using iswctype instead. See online help for details.")) int __cdecl is_wctype(wint_t, wctype_t); } 
#line 291
extern "C" { extern __declspec( dllimport ) __wchar_t *__cdecl _wgetcwd(__wchar_t *, int); } 
extern "C" { extern __declspec( dllimport ) __wchar_t *__cdecl _wgetdcwd(int, __wchar_t *, int); } 
extern "C" { extern __wchar_t *__cdecl _wgetdcwd_nolock(int, __wchar_t *, int); } 
#line 301
extern "C" { extern __declspec( dllimport ) int __cdecl _wchdir(const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wmkdir(const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wrmdir(const __wchar_t *); } 
#line 310
extern "C" { extern __declspec( dllimport ) int __cdecl _waccess(const __wchar_t *, int); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _waccess_s(const __wchar_t *, int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wchmod(const __wchar_t *, int); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wsopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _wcreat(const __wchar_t *, int); } 
extern "C" { extern __declspec( dllimport ) intptr_t __cdecl _wfindfirst32(const __wchar_t *, _wfinddata32_t *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wfindnext32(intptr_t, _wfinddata32_t *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wunlink(const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wrename(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wmktemp_s(__wchar_t *, size_t); } 
template<size_t _Size> inline errno_t __cdecl _wmktemp_s(__wchar_t (&)[_Size]); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wmktemp_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl _wmktemp(__wchar_t *); } 

extern "C" { extern __declspec( dllimport ) intptr_t __cdecl _wfindfirst32i64(const __wchar_t *, _wfinddata32i64_t *); } 
extern "C" { extern __declspec( dllimport ) intptr_t __cdecl _wfindfirst64i32(const __wchar_t *, _wfinddata64i32_t *); } 
extern "C" { extern __declspec( dllimport ) intptr_t __cdecl _wfindfirst64(const __wchar_t *, _wfinddata64_t *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wfindnext32i64(intptr_t, _wfinddata32i64_t *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wfindnext64i32(intptr_t, _wfinddata64i32_t *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wfindnext64(intptr_t, _wfinddata64_t *); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wsopen_s(int *, const __wchar_t *, int, int, int); } 
#line 339
extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wsopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _wopen(const __wchar_t *, int, int = 0); 
extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wsopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _wsopen(const __wchar_t *, int, int, int = 0); 
#line 351
extern "C" { extern __declspec( dllimport ) __wchar_t *__cdecl _wsetlocale(int, const __wchar_t *); } 
#line 360
extern "C" { extern __declspec( dllimport ) intptr_t __cdecl _wexecl(const __wchar_t *, const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) intptr_t __cdecl _wexecle(const __wchar_t *, const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) intptr_t __cdecl _wexeclp(const __wchar_t *, const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) intptr_t __cdecl _wexeclpe(const __wchar_t *, const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) intptr_t __cdecl _wexecv(const __wchar_t *, const __wchar_t *const *); } 
extern "C" { extern __declspec( dllimport ) intptr_t __cdecl _wexecve(const __wchar_t *, const __wchar_t *const *, const __wchar_t *const *); } 

extern "C" { extern __declspec( dllimport ) intptr_t __cdecl _wexecvp(const __wchar_t *, const __wchar_t *const *); } 
extern "C" { extern __declspec( dllimport ) intptr_t __cdecl _wexecvpe(const __wchar_t *, const __wchar_t *const *, const __wchar_t *const *); } 

extern "C" { extern __declspec( dllimport ) intptr_t __cdecl _wspawnl(int, const __wchar_t *, const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) intptr_t __cdecl _wspawnle(int, const __wchar_t *, const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) intptr_t __cdecl _wspawnlp(int, const __wchar_t *, const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) intptr_t __cdecl _wspawnlpe(int, const __wchar_t *, const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) intptr_t __cdecl _wspawnv(int, const __wchar_t *, const __wchar_t *const *); } 
extern "C" { extern __declspec( dllimport ) intptr_t __cdecl _wspawnve(int, const __wchar_t *, const __wchar_t *const *, const __wchar_t *const *); } 

extern "C" { extern __declspec( dllimport ) intptr_t __cdecl _wspawnvp(int, const __wchar_t *, const __wchar_t *const *); } 
extern "C" { extern __declspec( dllimport ) intptr_t __cdecl _wspawnvpe(int, const __wchar_t *, const __wchar_t *const *, const __wchar_t *const *); } 
#line 458
extern "C" { typedef unsigned short _ino_t; }


extern "C" { typedef unsigned short ino_t; }
#line 467
extern "C" { typedef unsigned _dev_t; }


extern "C" { typedef unsigned dev_t; }
#line 476
extern "C" { typedef long _off_t; }


extern "C" { typedef long off_t; }
#line 486
extern "C" { struct _stat32 { friend struct __cilk_s;
_dev_t st_dev; 
_ino_t st_ino; 
unsigned short st_mode; 
short st_nlink; 
short st_uid; 
short st_gid; 
_dev_t st_rdev; 
_off_t st_size; 
__time32_t st_atime; 
__time32_t st_mtime; 
__time32_t st_ctime; 
}; }



extern "C" { struct stat { friend struct __cilk_s;
_dev_t st_dev; 
_ino_t st_ino; 
unsigned short st_mode; 
short st_nlink; 
short st_uid; 
short st_gid; 
_dev_t st_rdev; 
_off_t st_size; 
time_t st_atime; 
time_t st_mtime; 
time_t st_ctime; 
}; }



extern "C" { struct _stat32i64 { friend struct __cilk_s;
_dev_t st_dev; 
_ino_t st_ino; 
unsigned short st_mode; 
short st_nlink; 
short st_uid; 
short st_gid; 
_dev_t st_rdev; 
__int64 st_size; 
__time32_t st_atime; 
__time32_t st_mtime; 
__time32_t st_ctime; 
}; }

extern "C" { struct _stat64i32 { friend struct __cilk_s;
_dev_t st_dev; 
_ino_t st_ino; 
unsigned short st_mode; 
short st_nlink; 
short st_uid; 
short st_gid; 
_dev_t st_rdev; 
_off_t st_size; 
__time64_t st_atime; 
__time64_t st_mtime; 
__time64_t st_ctime; 
}; }

extern "C" { struct _stat64 { friend struct __cilk_s;
_dev_t st_dev; 
_ino_t st_ino; 
unsigned short st_mode; 
short st_nlink; 
short st_uid; 
short st_gid; 
_dev_t st_rdev; 
__int64 st_size; 
__time64_t st_atime; 
__time64_t st_mtime; 
__time64_t st_ctime; 
}; }
#line 592
extern "C" { extern __declspec( dllimport ) int __cdecl _wstat32(const __wchar_t *, _stat32 *); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _wstat32i64(const __wchar_t *, _stat32i64 *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wstat64i32(const __wchar_t *, _stat64i32 *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _wstat64(const __wchar_t *, _stat64 *); } 
#line 612
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _cgetws_s(__wchar_t *, size_t, size_t *); } 
template<size_t _Size> inline errno_t __cdecl _cgetws_s(__wchar_t (&)[_Size], size_t *); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _cgetws_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl _cgetws(__wchar_t *); } 
extern "C" { extern __declspec( dllimport ) wint_t __cdecl _getwch(); } 
extern "C" { extern __declspec( dllimport ) wint_t __cdecl _getwche(); } 
extern "C" { extern __declspec( dllimport ) wint_t __cdecl _putwch(__wchar_t); } 
extern "C" { extern __declspec( dllimport ) wint_t __cdecl _ungetwch(wint_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _cputws(const __wchar_t *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _cwprintf(const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _cwprintf_s(const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _cwscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _cwscanf(const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _cwscanf_s_l instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _cwscanf_l(const __wchar_t *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _cwscanf_s(const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _cwscanf_s_l(const __wchar_t *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vcwprintf(const __wchar_t *, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vcwprintf_s(const __wchar_t *, va_list); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _cwprintf_p(const __wchar_t *, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vcwprintf_p(const __wchar_t *, va_list); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _cwprintf_l(const __wchar_t *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _cwprintf_s_l(const __wchar_t *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vcwprintf_l(const __wchar_t *, _locale_t, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vcwprintf_s_l(const __wchar_t *, _locale_t, va_list); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _cwprintf_p_l(const __wchar_t *, _locale_t, ...); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _vcwprintf_p_l(const __wchar_t *, _locale_t, va_list); } 

extern "C" { extern wint_t __cdecl _putwch_nolock(__wchar_t); } 
extern "C" { extern wint_t __cdecl _getwch_nolock(); } 
extern "C" { extern wint_t __cdecl _getwche_nolock(); } 
extern "C" { extern wint_t __cdecl _ungetwch_nolock(wint_t); } 
#line 1122
extern "C" { struct tm { friend struct __cilk_s;
int tm_sec; 
int tm_min; 
int tm_hour; 
int tm_mday; 
int tm_mon; 
int tm_year; 
int tm_wday; 
int tm_yday; 
int tm_isdst; 
}; }
#line 1140
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wasctime_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl _wasctime(const tm *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wasctime_s(__wchar_t *, size_t, const tm *); } 
template<size_t _Size> inline errno_t __cdecl _wasctime_s(__wchar_t (&)[_Size], const tm *); 

extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wctime32_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl _wctime32(const __time32_t *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wctime32_s(__wchar_t *, size_t, const __time32_t *); } 
template<size_t _Size> inline errno_t __cdecl _wctime32_s(__wchar_t (&)[_Size], const __time32_t *); 

extern "C" { extern __declspec( dllimport ) size_t __cdecl wcsftime(__wchar_t *, size_t, const __wchar_t *, const tm *); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl _wcsftime_l(__wchar_t *, size_t, const __wchar_t *, const tm *, _locale_t); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wstrdate_s(__wchar_t *, size_t); } 
template<size_t _Size> inline errno_t __cdecl _wstrdate_s(__wchar_t (&)[_Size]); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wstrdate_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl _wstrdate(__wchar_t *); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wstrtime_s(__wchar_t *, size_t); } 
template<size_t _Size> inline errno_t __cdecl _wstrtime_s(__wchar_t (&)[_Size]); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wstrtime_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl _wstrtime(__wchar_t *); } 

extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _wctime64_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __wchar_t *__cdecl _wctime64(const __time64_t *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _wctime64_s(__wchar_t *, size_t, const __time64_t *); } 
template<size_t _Size> inline errno_t __cdecl _wctime64_s(__wchar_t (&)[_Size], const __time64_t *); 
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\wtime.inl"
#pragma warning(push)
#pragma warning(disable:4996)
#line 46
extern "C" { static __declspec( noinline ) __inline __wchar_t *__cdecl _wctime(const time_t *_Time) 
{ 
#pragma warning( push )
#pragma warning( disable : 4996 )
return _wctime64(_Time); 
#pragma warning( pop )
} } 

extern "C" { static __declspec( noinline ) __inline errno_t __cdecl _wctime_s(__wchar_t *_Buffer, size_t _SizeInWords, const time_t *_Time) 
{ 
return _wctime64_s(_Buffer, _SizeInWords, _Time); 
} } 


#pragma warning(pop)
#line 1171 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\wchar.h"
extern "C" { typedef int mbstate_t; }
extern "C" { typedef __wchar_t _Wint_t; }

extern "C" { extern __declspec( dllimport ) wint_t __cdecl btowc(int); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl mbrlen(const char *, size_t, mbstate_t *); } 

extern "C" { extern __declspec( dllimport ) size_t __cdecl mbrtowc(__wchar_t *, const char *, size_t, mbstate_t *); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl mbsrtowcs_s(size_t *, __wchar_t *, size_t, const char **, size_t, mbstate_t *); } 
template<size_t _Size> inline errno_t __cdecl mbsrtowcs_s(size_t *, __wchar_t (&)[_Size], const char **, size_t, mbstate_t *); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using mbsrtowcs_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) size_t __cdecl mbsrtowcs(__wchar_t *, const char **, size_t, mbstate_t *); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl wcrtomb_s(size_t *, char *, size_t, __wchar_t, mbstate_t *); } 

template<size_t _Size> inline errno_t __cdecl wcrtomb_s(size_t *, char (&)[_Size], __wchar_t, mbstate_t *); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using wcrtomb_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) size_t __cdecl wcrtomb(char *, __wchar_t, mbstate_t *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl wcsrtombs_s(size_t *, char *, size_t, const __wchar_t **, size_t, mbstate_t *); } 

template<size_t _Size> inline errno_t __cdecl wcsrtombs_s(size_t *, char (&)[_Size], const __wchar_t **, size_t, mbstate_t *); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using wcsrtombs_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) size_t __cdecl wcsrtombs(char *, const __wchar_t **, size_t, mbstate_t *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl wctob(wint_t); } 
#line 1199
extern "C" { extern __declspec( dllimport ) void *__cdecl memmove(void *, const void *, size_t); } 

extern "C" { extern void *__cdecl memcpy(void *, const void *, size_t); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl memcpy_s(void *, rsize_t, const void *, rsize_t); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl memmove_s(void *, rsize_t, const void *, rsize_t); } 

extern "C" { __inline int __cdecl fwide(FILE *_F, int _M) 
{ (void)_F; return _M; } } 
extern "C" { __inline int __cdecl mbsinit(const mbstate_t *_P) 
{ return (_P == (0)) || (*_P == 0); } } 
extern "C" { __inline const __wchar_t *__cdecl wmemchr(const __wchar_t *_S, __wchar_t _C, size_t _N) 
{ for (; (0) < _N; (++_S), (--_N)) { 
if (*_S == _C) { 
return _S; }  }  
return 0; } } 
extern "C" { __inline int __cdecl wmemcmp(const __wchar_t *_S1, const __wchar_t *_S2, size_t _N) 
{ for (; (0) < _N; ((++_S1), (++_S2)), (--_N)) { 
if (*_S1 != *_S2) { 
return (*_S1 < *_S2) ? (-1) : (+1); }  }  
return 0; } } 

extern "C" { __inline __wchar_t *__cdecl wmemcpy(__wchar_t *_S1, const __wchar_t *_S2, size_t _N) 
{ 
#pragma warning( push )
#pragma warning( disable : 4996 6386 )
return (__wchar_t *)memcpy(_S1, _S2, _N * sizeof(__wchar_t)); 
#pragma warning( pop )
} } 


extern "C" { __declspec( noinline ) __inline errno_t __cdecl wmemcpy_s(__wchar_t *_S1, rsize_t _N1, const __wchar_t *_S2, rsize_t _N) 
{ 
#pragma warning( push )
#pragma warning( disable : 6386 )
return memcpy_s(_S1, _N1 * sizeof(__wchar_t), _S2, _N * sizeof(__wchar_t)); 
} } 
#pragma warning( pop )


extern "C" { __declspec( noinline ) __inline __wchar_t *__cdecl wmemmove(__wchar_t *_S1, const __wchar_t *_S2, size_t _N) 
{ 
#pragma warning( push )
#pragma warning( disable : 4996 6386 )
#pragma warning( disable : 6387)

return (__wchar_t *)memmove(_S1, _S2, _N * sizeof(__wchar_t)); 
#pragma warning( pop )
} } 


extern "C" { __declspec( noinline ) __inline errno_t __cdecl wmemmove_s(__wchar_t *_S1, rsize_t _N1, const __wchar_t *_S2, rsize_t _N) 
{ 
#pragma warning( push )
#pragma warning( disable : 6386 )
return memmove_s(_S1, _N1 * sizeof(__wchar_t), _S2, _N * sizeof(__wchar_t)); 
#pragma warning( pop )
} } 


extern "C" { __inline __wchar_t *__cdecl wmemset(__wchar_t *_S, __wchar_t _C, size_t _N) 
{ 
auto __wchar_t *_Su = _S; 
for (; (0) < _N; (++_Su), (--_N)) 
{ 
(*_Su) = _C; 
}  
return _S; 
} } 



inline __wchar_t *__cdecl wmemchr(__wchar_t *_S, __wchar_t _C, size_t _N) 
{ return (__wchar_t *)wmemchr((const __wchar_t *)_S, _C, _N); } 
#line 1282
#pragma pack ( pop )
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\cwchar"
typedef mbstate_t _Mbstatet; 




typedef mbstate_t _Mbstatet; 


namespace std { 
using ::_Mbstatet;

using ::mbstate_t;
using ::tm;using ::wint_t;


using ::btowc;using ::fgetwc;using ::fgetws;using ::fputwc;
using ::fputws;using ::fwide;using ::fwprintf;
using ::fwscanf;using ::getwc;using ::getwchar;
using ::mbrlen;using ::mbrtowc;using ::mbsrtowcs;
using ::mbsinit;using ::putwc;using ::putwchar;
using ::swprintf;using ::swscanf;using ::ungetwc;
using ::vfwprintf;using ::vswprintf;using ::vwprintf;
using ::wcrtomb;using ::wprintf;using ::wscanf;
using ::wcsrtombs;using ::wcstol;using ::wcscat;
using ::wcschr;using ::wcscmp;using ::wcscoll;
using ::wcscpy;using ::wcscspn;using ::wcslen;
using ::wcsncat;using ::wcsncmp;using ::wcsncpy;
using ::wcspbrk;using ::wcsrchr;using ::wcsspn;

using ::wcstod;using ::wcstoul;using ::wcsstr;

using ::wcstok;using ::wcsxfrm;using ::wctob;
using ::wmemchr;using ::wmemcmp;using ::wmemcpy;
using ::wmemmove;using ::wmemset;using ::wcsftime;


}
#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdbg.h"
#pragma pack ( push, 8 )
#line 46
extern "C" { typedef void *_HFILE; }
#line 65
extern "C" { typedef int (__cdecl *_CRT_REPORT_HOOK)(int, char *, int *); }
extern "C" { typedef int (__cdecl *_CRT_REPORT_HOOKW)(int, __wchar_t *, int *); }
#line 97
extern "C" { typedef int (__cdecl *_CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int); }
#line 158
extern "C" { typedef void (__cdecl *_CRT_DUMP_CLIENT)(void *, size_t); }
#line 166
struct _CrtMemBlockHeader; 
#line 174
extern "C" { typedef 
#line 167
struct _CrtMemState { friend struct __cilk_s;

_CrtMemBlockHeader *pBlockHeader; 
size_t lCounts[5]; 
size_t lSizes[5]; 
size_t lHighWaterCount; 
size_t lTotalCount; 
} _CrtMemState; }
#line 1122
#pragma warning(suppress: 4985)
extern void *__cdecl operator new[](size_t); 


extern void *__cdecl operator new(size_t, int, const char *, int); 
#line 1133
#pragma warning(suppress: 4985)
extern void *__cdecl operator new[](size_t, int, const char *, int); 
#line 1144
extern void __cdecl operator delete[](void *); 

inline void __cdecl operator delete(void *_P, int __T12394008, const char *__T12394100, int __T12394192) 
{ ::operator delete(_P); } 
inline void __cdecl operator delete[](void *_P, int __T12394972, const char *__T12395064, int __T12395156) 
{ ::operator delete[](_P); } 
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\iosfwd"
#pragma warning(push,3)
#line 1219 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdbg.h"
#pragma pack ( pop )
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\iosfwd"
#pragma pack ( push, 8 )


namespace std { 
#line 24
typedef long streamoff; 
typedef int streamsize; 
#line 41
extern __declspec( dllimport ) fpos_t _Fpz; 
extern __declspec( dllimport ) const streamoff _BADOFF; 



template<class _Statetype> 
class fpos { friend struct __cilk_s;__CILK_METADATA(fpos, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef std::fpos< _Statetype>  _Myt; 


inline fpos(typename __cilk_maybe_box<fpos, long >::type  = (__cilk_maybe_box<fpos, streamoff >::type (0))); 




inline fpos(_Statetype, fpos_t); inline  /* __cilk */ __thiscall fpos(__cilk_box<_Statetype > , __cilk_box<__int64 > ); 




inline _Statetype state() const; inline _Statetype  /* __cilk */ __thiscall __cilkfun_state() const; 




inline void state(_Statetype); inline void  /* __cilk */ __thiscall __cilkfun_state(__cilk_box<_Statetype > ); 




inline fpos_t seekpos() const; inline fpos_t  /* __cilk */ __thiscall __cilkfun_seekpos() const; 




inline operator streamoff() const; 




inline streamoff operator-(const _Myt &) const; inline streamoff  /* __cilk */ __thiscall __cilk_op_minus(__cilk_box<const _Myt & > ) const; 




inline _Myt &operator+=(streamoff); inline _Myt & /* __cilk */ __thiscall __cilk_op_plus_assign(__cilk_box<long > ); 
#line 93
inline _Myt &operator-=(streamoff); inline _Myt & /* __cilk */ __thiscall __cilk_op_minus_assign(__cilk_box<long > ); 
#line 99
inline _Myt operator+(streamoff) const; inline _Myt  /* __cilk */ __thiscall __cilk_op_plus(__cilk_box<long > ) const; 
#line 105
inline _Myt operator-(streamoff) const; inline _Myt  /* __cilk */ __thiscall __cilk_op_minus(__cilk_box<long > ) const; 
#line 111
inline bool operator==(const _Myt &) const; inline bool  /* __cilk */ __thiscall __cilk_op_eq(__cilk_box<const _Myt & > ) const; 




inline bool operator!=(const _Myt &) const; inline bool  /* __cilk */ __thiscall __cilk_op_ne(__cilk_box<const _Myt & > ) const; 
#line 122
private: static const _Statetype _Stz; 
streamoff _Myoff; 
fpos_t _Fpos; 
_Statetype _Mystate; 
}; 
#line 137
typedef fpos< int>  streampos; 
typedef streampos wstreampos; 


struct _Unsecure_char_traits_tag { friend struct __cilk_s;

}; 
struct _Secure_char_traits_tag { friend struct __cilk_s;__CILK_METADATA(_Secure_char_traits_tag, __CILK_VBASE_DETECT)

}; 
#line 153
struct _Char_traits_base { friend struct __cilk_s;

typedef _Unsecure_char_traits_tag _Secure_char_traits; 
}; 




template<class _Elem> 
struct char_traits : public _Char_traits_base { friend struct __cilk_s;__CILK_METADATA(char_traits, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef _Elem char_type; 
typedef long int_type; 
typedef streampos pos_type; 
typedef streamoff off_type; 
typedef _Mbstatet state_type; 

static inline void assign(_Elem &, const _Elem &); static inline void  /* __cilk */ __cdecl __cilkfun_assign(__cilk_box<_Elem & > , __cilk_box<const _Elem & > ); 




static inline bool eq(const _Elem &, const _Elem &); static inline bool  /* __cilk */ __cdecl __cilkfun_eq(__cilk_box<const _Elem & > , __cilk_box<const _Elem & > ); 




static inline bool lt(const _Elem &, const _Elem &); static inline bool  /* __cilk */ __cdecl __cilkfun_lt(__cilk_box<const _Elem & > , __cilk_box<const _Elem & > ); 




static inline int compare(const _Elem *, const _Elem *, size_t); static inline int  /* __cilk */ __cdecl __cilkfun_compare(__cilk_box<const _Elem * > , __cilk_box<const _Elem * > , __cilk_box<unsigned > ); 
#line 197
static inline size_t length(const _Elem *); static inline size_t  /* __cilk */ __cdecl __cilkfun_length(__cilk_box<const _Elem * > ); 
#line 207
static inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) _Elem *copy(_Elem *, const _Elem *, size_t); static inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) _Elem * /* __cilk */ __cdecl __cilkfun_copy(__cilk_box<_Elem * > , __cilk_box<const _Elem * > , __cilk_box<unsigned > ); 
#line 214
static inline _Elem *_Copy_s(_Elem *, size_t, const _Elem *, size_t); static inline _Elem * /* __cilk */ __cdecl __cilkfun__Copy_s(__cilk_box<_Elem * > , __cilk_box<unsigned > , __cilk_box<const _Elem * > , __cilk_box<unsigned > ); 
#line 226
static inline const _Elem *find(const _Elem *, size_t, const _Elem &); static inline const _Elem * /* __cilk */ __cdecl __cilkfun_find(__cilk_box<const _Elem * > , __cilk_box<unsigned > , __cilk_box<const _Elem & > ); 
#line 237
static inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) _Elem *move(_Elem *, const _Elem *, size_t); static inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) _Elem * /* __cilk */ __cdecl __cilkfun_move(__cilk_box<_Elem * > , __cilk_box<const _Elem * > , __cilk_box<unsigned > ); 
#line 244
static inline _Elem *_Move_s(_Elem *, size_t, const _Elem *, size_t); static inline _Elem * /* __cilk */ __cdecl __cilkfun__Move_s(__cilk_box<_Elem * > , __cilk_box<unsigned > , __cilk_box<const _Elem * > , __cilk_box<unsigned > ); 
#line 260
static inline _Elem *assign(_Elem *, size_t, _Elem); static inline _Elem * /* __cilk */ __cdecl __cilkfun_assign(__cilk_box<_Elem * > , __cilk_box<unsigned > , __cilk_box<_Elem > ); 
#line 270
static inline _Elem to_char_type(const int_type &); static inline _Elem  /* __cilk */ __cdecl __cilkfun_to_char_type(__cilk_box<const int_type & > ); 




static inline int_type to_int_type(const _Elem &); static inline int_type  /* __cilk */ __cdecl __cilkfun_to_int_type(__cilk_box<const _Elem & > ); 




static inline bool eq_int_type(const int_type &, const int_type &); static inline bool  /* __cilk */ __cdecl __cilkfun_eq_int_type(__cilk_box<const int_type & > , __cilk_box<const int_type & > ); 
#line 286
static inline int_type eof(); static inline int_type  /* __cilk */ __cdecl __cilkfun_eof(); 




static inline int_type not_eof(const int_type &); static inline int_type  /* __cilk */ __cdecl __cilkfun_not_eof(__cilk_box<const int_type & > ); 



}; 


template<> struct __declspec( dllimport ) char_traits< __wchar_t>  : public _Char_traits_base { friend struct __cilk_s;__CILK_METADATA(char_traits, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef __wchar_t _Elem; 
typedef _Elem char_type; 
typedef wint_t int_type; 
typedef streampos pos_type; 
typedef streamoff off_type; 
typedef _Mbstatet state_type; 

static inline void assign(_Elem &, const _Elem &); 




static inline bool eq(const _Elem &, const _Elem &); 




static inline bool lt(const _Elem &, const _Elem &); 




static inline int compare(const _Elem *, const _Elem *, size_t); 
#line 331
static inline __declspec( noinline ) size_t length(const _Elem *); 
#line 338
static inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) _Elem *copy(_Elem *, const _Elem *, size_t); 
#line 345
static inline _Elem *_Copy_s(_Elem *, size_t, const _Elem *, size_t); 
#line 354
static inline const _Elem *find(const _Elem *, size_t, const _Elem &); 
#line 362
static inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) _Elem *move(_Elem *, const _Elem *, size_t); 
#line 369
static inline _Elem *_Move_s(_Elem *, size_t, const _Elem *, size_t); 
#line 378
static inline _Elem *assign(_Elem *, size_t, _Elem); 
#line 384
static inline _Elem to_char_type(const int_type &); 




static inline int_type to_int_type(const _Elem &); 




static inline bool eq_int_type(const int_type &, const int_type &); 
#line 400
static inline int_type eof(); 




static inline int_type not_eof(const int_type &); 



}; 
#line 308
inline void char_traits< __wchar_t> ::assign(_Elem &_Left, const _Elem &_Right) 
{ 
_Left = _Right; 
} 

inline bool char_traits< __wchar_t> ::eq(const _Elem &_Left, const _Elem &_Right) 
{ 
return _Left == _Right; 
} 

inline bool char_traits< __wchar_t> ::lt(const _Elem &_Left, const _Elem &_Right) 
{ 
return _Left < _Right; 
} 

inline int char_traits< __wchar_t> ::compare(const _Elem *_First1, const _Elem *_First2, size_t 
_Count) 
{ 


return ::wmemcmp(_First1, _First2, _Count); 
} 

inline __declspec( noinline ) size_t char_traits< __wchar_t> ::length(const _Elem *_First) 
{ 

return ::wcslen(_First); 
} 


inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) char_traits< __wchar_t> ::_Elem *char_traits< __wchar_t> ::copy(_Elem *_First1, const _Elem *_First2, size_t 
_Count) 
{ 

return _Copy_s(_First1, _Count, _First2, _Count); 
} 

inline char_traits< __wchar_t> ::_Elem *char_traits< __wchar_t> ::_Copy_s(_Elem *_First1, size_t _Size_in_words, const _Elem *_First2, size_t 
_Count) 
{ 


::wmemcpy_s(_First1, _Size_in_words, _First2, _Count); 
return _First1; 
} 

inline const char_traits< __wchar_t> ::_Elem *char_traits< __wchar_t> ::find(const _Elem *_First, size_t _Count, const _Elem &
_Ch) 
{ 

return (const _Elem *)::wmemchr(_First, _Ch, _Count); 
} 


inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) char_traits< __wchar_t> ::_Elem *char_traits< __wchar_t> ::move(_Elem *_First1, const _Elem *_First2, size_t 
_Count) 
{ 

return _Move_s(_First1, _Count, _First2, _Count); 
} 

inline char_traits< __wchar_t> ::_Elem *char_traits< __wchar_t> ::_Move_s(_Elem *_First1, size_t _Size_in_words, const _Elem *_First2, size_t 
_Count) 
{ 


::wmemmove_s(_First1, _Size_in_words, _First2, _Count); 
return _First1; 
} 

inline char_traits< __wchar_t> ::_Elem *char_traits< __wchar_t> ::assign(_Elem *_First, size_t _Count, _Elem _Ch) 
{ 

return (_Elem *)::wmemset(_First, _Ch, _Count); 
} 

inline char_traits< __wchar_t> ::_Elem char_traits< __wchar_t> ::to_char_type(const int_type &_Meta) 
{ 
return _Meta; 
} 

inline char_traits< __wchar_t> ::int_type char_traits< __wchar_t> ::to_int_type(const _Elem &_Ch) 
{ 
return _Ch; 
} 

inline bool char_traits< __wchar_t> ::eq_int_type(const int_type &_Left, const int_type &
_Right) 
{ 
return _Left == _Right; 
} 

inline char_traits< __wchar_t> ::int_type char_traits< __wchar_t> ::eof() 
{ 
return (wint_t)65535; 
} 

inline char_traits< __wchar_t> ::int_type char_traits< __wchar_t> ::not_eof(const int_type &_Meta) 
{ 
return (_Meta != eof()) ? (_Meta) : (!(eof())); 
} 




template<> struct __declspec( dllimport ) char_traits< char>  : public _Char_traits_base { friend struct __cilk_s;__CILK_METADATA(char_traits, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef char _Elem; 
typedef _Elem char_type; 
typedef int int_type; 
typedef streampos pos_type; 
typedef streamoff off_type; 
typedef _Mbstatet state_type; 

static inline void assign(_Elem &, const _Elem &); 




static inline bool eq(const _Elem &, const _Elem &); 




static inline bool lt(const _Elem &, const _Elem &); 




static inline int compare(const _Elem *, const _Elem *, size_t); 
#line 446
static inline size_t length(const _Elem *); 
#line 453
static inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) _Elem *copy(_Elem *, const _Elem *, size_t); 
#line 460
static inline __declspec( noinline ) _Elem *_Copy_s(_Elem *, size_t, const _Elem *, size_t); 
#line 469
static inline __declspec( noinline ) const _Elem *find(const _Elem *, size_t, const _Elem &); 
#line 477
static inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) _Elem *move(_Elem *, const _Elem *, size_t); 
#line 484
static inline __declspec( noinline ) _Elem *_Move_s(_Elem *, size_t, const _Elem *, size_t); 
#line 493
static inline _Elem *assign(_Elem *, size_t, _Elem); 
#line 499
static inline _Elem to_char_type(const int_type &); 




static inline int_type to_int_type(const _Elem &); 




static inline bool eq_int_type(const int_type &, const int_type &); 
#line 515
static inline int_type eof(); 




static inline int_type not_eof(const int_type &); 



}; 
#line 423
inline void char_traits< char> ::assign(_Elem &_Left, const _Elem &_Right) 
{ 
_Left = _Right; 
} 

inline bool char_traits< char> ::eq(const _Elem &_Left, const _Elem &_Right) 
{ 
return _Left == _Right; 
} 

inline bool char_traits< char> ::lt(const _Elem &_Left, const _Elem &_Right) 
{ 
return _Left < _Right; 
} 

inline int char_traits< char> ::compare(const _Elem *_First1, const _Elem *_First2, size_t 
_Count) 
{ 


return ::memcmp(_First1, _First2, _Count); 
} 

inline size_t char_traits< char> ::length(const _Elem *_First) 
{ 

return ::strlen(_First); 
} 


inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) char_traits< char> ::_Elem *char_traits< char> ::copy(_Elem *_First1, const _Elem *_First2, size_t 
_Count) 
{ 

return _Copy_s(_First1, _Count, _First2, _Count); 
} 

inline __declspec( noinline ) char_traits< char> ::_Elem *char_traits< char> ::_Copy_s(_Elem *_First1, size_t _Size_in_bytes, const _Elem *_First2, size_t 
_Count) 
{ 


::memcpy_s(_First1, _Size_in_bytes, _First2, _Count); 
return _First1; 
} 

inline __declspec( noinline ) const char_traits< char> ::_Elem *char_traits< char> ::find(const _Elem *_First, size_t _Count, const _Elem &
_Ch) 
{ 

return (const _Elem *)::memchr(_First, _Ch, _Count); 
} 


inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) char_traits< char> ::_Elem *char_traits< char> ::move(_Elem *_First1, const _Elem *_First2, size_t 
_Count) 
{ 

return _Move_s(_First1, _Count, _First2, _Count); 
} 

inline __declspec( noinline ) char_traits< char> ::_Elem *char_traits< char> ::_Move_s(_Elem *_First1, size_t _Size_in_bytes, const _Elem *_First2, size_t 
_Count) 
{ 


::memmove_s(_First1, _Size_in_bytes, _First2, _Count); 
return _First1; 
} 

inline char_traits< char> ::_Elem *char_traits< char> ::assign(_Elem *_First, size_t _Count, _Elem _Ch) 
{ 

return (_Elem *)::memset(_First, _Ch, _Count); 
} 

inline char_traits< char> ::_Elem char_traits< char> ::to_char_type(const int_type &_Meta) 
{ 
return (_Elem)(_Meta); 
} 

inline char_traits< char> ::int_type char_traits< char> ::to_int_type(const _Elem &_Ch) 
{ 
return (unsigned char)(_Ch); 
} 

inline bool char_traits< char> ::eq_int_type(const int_type &_Left, const int_type &
_Right) 
{ 
return _Left == _Right; 
} 

inline char_traits< char> ::int_type char_traits< char> ::eof() 
{ 
return -1; 
} 

inline char_traits< char> ::int_type char_traits< char> ::not_eof(const int_type &_Meta) 
{ 
return (_Meta != eof()) ? (_Meta) : (!(eof())); 
} 



template<class _Traits> 
class _Inherits_from_char_traits_base { friend struct __cilk_s;__CILK_METADATA(_Inherits_from_char_traits_base, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef char _True; 
class _False { friend struct __cilk_s;__CILK_METADATA(_False, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;private: char _Dummy[2]; }; 
private: static _True _Inherits(_Char_traits_base); static _True  /* __cilk */ __cdecl __cilkfun__Inherits(__cilk_box<_Char_traits_base > ); 
static _False _Inherits(...); static _False  /* __cilk */ __cdecl __cilkfun__Inherits(__cilk_vararg_box<void> __cilk_va = 0); 
static _Traits _Make_traits(); static _Traits  /* __cilk */ __cdecl __cilkfun__Make_traits(); 


public: enum { _Exists = (sizeof((_Inherits(_Make_traits()))) == sizeof(_True))}; 
}; 

template<class _Traits, bool _Inherits_from_char_traits_base> 
class _Char_traits_category_helper { friend struct __cilk_s;__CILK_METADATA(_Char_traits_category_helper, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef _Unsecure_char_traits_tag _Secure_char_traits; 
}; 



template<class _Elem> 
class _Char_traits_category_helper< char_traits< _Elem> , true>  { friend struct __cilk_s;__CILK_METADATA(_Char_traits_category_helper, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef _Secure_char_traits_tag _Secure_char_traits; 
}; 

template<class _Traits> 
class _Char_traits_category_helper< _Traits, true>  { friend struct __cilk_s;__CILK_METADATA(_Char_traits_category_helper, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef typename _Traits::_Secure_char_traits _Secure_char_traits; 
}; 

template<class _Traits> 
class _Char_traits_category { friend struct __cilk_s;__CILK_METADATA(_Char_traits_category, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef typename _Char_traits_category_helper< _Traits, _Inherits_from_char_traits_base< _Traits> ::_Exists> ::_Secure_char_traits _Secure_char_traits; 
}; 



template<class _Traits> inline typename _Char_traits_category< _Traits> ::_Secure_char_traits 

_Char_traits_cat(); 
#line 572
template<class _Traits> inline typename _Char_traits_category< _Traits> ::_Secure_char_traits  /* __cilk */ __cdecl 

__cilkfun__Char_traits_cat(); 
#line 580
namespace _Traits_helper { 



template<class _Traits> inline typename _Traits::char_type *

copy_s(typename _Traits::char_type *, size_t, const typename _Traits::char_type *, size_t); 
#line 584
template<class _Traits> inline typename _Traits::char_type * /* __cilk */ __cdecl 

__cilkfun_copy_s(__cilk_box<typename _Traits::char_type * > , __cilk_box<unsigned > , __cilk_box<const typename _Traits::char_type * > , __cilk_box<unsigned > ); 
#line 592
template<class _Traits> inline typename _Traits::char_type *

copy_s(typename _Traits::char_type *, size_t, const typename _Traits::char_type *, size_t, _Secure_char_traits_tag); 
#line 592
template<class _Traits> inline typename _Traits::char_type * /* __cilk */ __cdecl 

__cilkfun_copy_s(__cilk_box<typename _Traits::char_type * > , __cilk_box<unsigned > , __cilk_box<const typename _Traits::char_type * > , __cilk_box<unsigned > , __cilk_box<_Secure_char_traits_tag > ); 
#line 601
template<class _Traits> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename _Traits::char_type *


copy_s(typename _Traits::char_type *, size_t, const typename _Traits::char_type *, size_t, _Unsecure_char_traits_tag); 
#line 601
template<class _Traits> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename _Traits::char_type * /* __cilk */ __cdecl 


__cilkfun_copy_s(__cilk_box<typename _Traits::char_type * > , __cilk_box<unsigned > , __cilk_box<const typename _Traits::char_type * > , __cilk_box<unsigned > , __cilk_box<_Unsecure_char_traits_tag > ); 
#line 611
template<class _Traits> inline typename _Traits::char_type *

move_s(typename _Traits::char_type *, size_t, const typename _Traits::char_type *, size_t); 
#line 611
template<class _Traits> inline typename _Traits::char_type * /* __cilk */ __cdecl 

__cilkfun_move_s(__cilk_box<typename _Traits::char_type * > , __cilk_box<unsigned > , __cilk_box<const typename _Traits::char_type * > , __cilk_box<unsigned > ); 
#line 619
template<class _Traits> inline typename _Traits::char_type *

move_s(typename _Traits::char_type *, size_t, const typename _Traits::char_type *, size_t, _Secure_char_traits_tag); 
#line 619
template<class _Traits> inline typename _Traits::char_type * /* __cilk */ __cdecl 

__cilkfun_move_s(__cilk_box<typename _Traits::char_type * > , __cilk_box<unsigned > , __cilk_box<const typename _Traits::char_type * > , __cilk_box<unsigned > , __cilk_box<_Secure_char_traits_tag > ); 
#line 628
template<class _Traits> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename _Traits::char_type *


move_s(typename _Traits::char_type *, size_t, const typename _Traits::char_type *, size_t, _Unsecure_char_traits_tag); 
#line 628
template<class _Traits> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename _Traits::char_type * /* __cilk */ __cdecl 


__cilkfun_move_s(__cilk_box<typename _Traits::char_type * > , __cilk_box<unsigned > , __cilk_box<const typename _Traits::char_type * > , __cilk_box<unsigned > , __cilk_box<_Unsecure_char_traits_tag > ); 
#line 637
}


template<class _Ty> class allocator; 

class __declspec( dllimport ) ios_base; 
template<class _Elem, class 
_Traits> class basic_ios; 

template<class _Elem, class 
_Traits> class istreambuf_iterator; 

template<class _Elem, class 
_Traits> class ostreambuf_iterator; 

template<class _Elem, class 
_Traits> class basic_streambuf; 

template<class _Elem, class 
_Traits> class basic_istream; 

template<class _Elem, class 
_Traits> class basic_ostream; 

template<class _Elem, class 
_Traits> class basic_iostream; 

template<class _Elem, class 
_Traits, class 
_Alloc> class basic_stringbuf; 

template<class _Elem, class 
_Traits, class 
_Alloc> class basic_istringstream; 

template<class _Elem, class 
_Traits, class 
_Alloc> class basic_ostringstream; 

template<class _Elem, class 
_Traits, class 
_Alloc> class basic_stringstream; 

template<class _Elem, class 
_Traits> class basic_filebuf; 

template<class _Elem, class 
_Traits> class basic_ifstream; 

template<class _Elem, class 
_Traits> class basic_ofstream; 

template<class _Elem, class 
_Traits> class basic_fstream; 



template<class _Elem, class 
_InIt> class num_get; 

template<class _Elem, class 
_OutIt> class num_put; 

template<class _Elem> class collate; 




typedef basic_ios< char, char_traits< char> >  ios; 
typedef basic_streambuf< char, char_traits< char> >  streambuf; 
typedef basic_istream< char, char_traits< char> >  istream; 
typedef basic_ostream< char, char_traits< char> >  ostream; 
typedef basic_iostream< char, char_traits< char> >  iostream; 

typedef basic_stringbuf< char, char_traits< char> , allocator< char> >  stringbuf; 

typedef basic_istringstream< char, char_traits< char> , allocator< char> >  istringstream; 

typedef basic_ostringstream< char, char_traits< char> , allocator< char> >  ostringstream; 

typedef basic_stringstream< char, char_traits< char> , allocator< char> >  stringstream; 
typedef basic_filebuf< char, char_traits< char> >  filebuf; 
typedef basic_ifstream< char, char_traits< char> >  ifstream; 
typedef basic_ofstream< char, char_traits< char> >  ofstream; 
typedef basic_fstream< char, char_traits< char> >  fstream; 


typedef basic_ios< __wchar_t, char_traits< __wchar_t> >  wios; 

typedef basic_streambuf< __wchar_t, char_traits< __wchar_t> >  wstreambuf; 
typedef basic_istream< __wchar_t, char_traits< __wchar_t> >  wistream; 
typedef basic_ostream< __wchar_t, char_traits< __wchar_t> >  wostream; 
typedef basic_iostream< __wchar_t, char_traits< __wchar_t> >  wiostream; 

typedef basic_stringbuf< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wstringbuf; 

typedef basic_istringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wistringstream; 

typedef basic_ostringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wostringstream; 

typedef basic_stringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wstringstream; 
typedef basic_filebuf< __wchar_t, char_traits< __wchar_t> >  wfilebuf; 
typedef basic_ifstream< __wchar_t, char_traits< __wchar_t> >  wifstream; 
typedef basic_ofstream< __wchar_t, char_traits< __wchar_t> >  wofstream; 
typedef basic_fstream< __wchar_t, char_traits< __wchar_t> >  wfstream; 
#line 747
typedef num_get< char, istreambuf_iterator< char, char_traits< char> > >  numget; 

typedef num_get< __wchar_t, istreambuf_iterator< __wchar_t, char_traits< __wchar_t> > >  wnumget; 

typedef num_put< char, ostreambuf_iterator< char, char_traits< char> > >  numput; 

typedef num_put< __wchar_t, ostreambuf_iterator< __wchar_t, char_traits< __wchar_t> > >  wnumput; 
typedef collate< char>  ncollate; 
typedef collate< __wchar_t>  wcollate; 


}


#pragma warning(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\utility"
#pragma warning(push,3)
#line 762 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\iosfwd"
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\utility"
#pragma pack ( push, 8 )



namespace std { 

template<class _Ty> inline void 
swap(_Ty &, _Ty &); 
#line 15
template<class _Ty> inline void  /* __cilk */ __cdecl 
__cilkfun_swap(__cilk_box<_Ty & > , __cilk_box<_Ty & > ); 
#line 28
template<class _Ty1, class 
_Ty2> struct pair { friend struct __cilk_s;__CILK_METADATA(pair, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef std::pair< _Ty1, _Ty2>  _Myt; 
typedef _Ty1 first_type; 
typedef _Ty2 second_type; 

inline pair(); 




inline pair(const _Ty1 &, const _Ty2 &); inline  /* __cilk */ __thiscall pair(__cilk_box<const _Ty1 & > , __cilk_box<const _Ty2 & > ); 




template<class _Other1, class 
_Other2> inline 
pair(const std::pair< _Other1, _Other2>  &); 
#line 45
template<class _Other1, class 
_Other2> inline  /* __cilk */ __thiscall 
pair(__cilk_box<const std::pair< _Other1, _Other2>  & > ); 




inline void swap(_Myt &); inline void  /* __cilk */ __thiscall __cilkfun_swap(__cilk_box<_Myt & > ); 
#line 61
_Ty1 first; 
_Ty2 second; 
}; 


template<class _Ty1, class 
_Ty2> inline bool 
operator==(const pair< _Ty1, _Ty2>  &, const pair< _Ty1, _Ty2>  &); 
#line 66
template<class _Ty1, class 
_Ty2> inline bool  /* __cilk */ __cdecl 
__cilk_op_eq(__cilk_box<const pair< _Ty1, _Ty2>  & > , __cilk_box<const pair< _Ty1, _Ty2>  & > ); 
#line 74
template<class _Ty1, class 
_Ty2> inline bool 
operator!=(const pair< _Ty1, _Ty2>  &, const pair< _Ty1, _Ty2>  &); 
#line 74
template<class _Ty1, class 
_Ty2> inline bool  /* __cilk */ __cdecl 
__cilk_op_ne(__cilk_box<const pair< _Ty1, _Ty2>  & > , __cilk_box<const pair< _Ty1, _Ty2>  & > ); 
#line 82
template<class _Ty1, class 
_Ty2> inline bool 
operator<(const pair< _Ty1, _Ty2>  &, const pair< _Ty1, _Ty2>  &); 
#line 82
template<class _Ty1, class 
_Ty2> inline bool  /* __cilk */ __cdecl 
__cilk_op_lt(__cilk_box<const pair< _Ty1, _Ty2>  & > , __cilk_box<const pair< _Ty1, _Ty2>  & > ); 
#line 91
template<class _Ty1, class 
_Ty2> inline bool 
operator>(const pair< _Ty1, _Ty2>  &, const pair< _Ty1, _Ty2>  &); 
#line 91
template<class _Ty1, class 
_Ty2> inline bool  /* __cilk */ __cdecl 
__cilk_op_gt(__cilk_box<const pair< _Ty1, _Ty2>  & > , __cilk_box<const pair< _Ty1, _Ty2>  & > ); 
#line 99
template<class _Ty1, class 
_Ty2> inline bool 
operator<=(const pair< _Ty1, _Ty2>  &, const pair< _Ty1, _Ty2>  &); 
#line 99
template<class _Ty1, class 
_Ty2> inline bool  /* __cilk */ __cdecl 
__cilk_op_le(__cilk_box<const pair< _Ty1, _Ty2>  & > , __cilk_box<const pair< _Ty1, _Ty2>  & > ); 
#line 107
template<class _Ty1, class 
_Ty2> inline bool 
operator>=(const pair< _Ty1, _Ty2>  &, const pair< _Ty1, _Ty2>  &); 
#line 107
template<class _Ty1, class 
_Ty2> inline bool  /* __cilk */ __cdecl 
__cilk_op_ge(__cilk_box<const pair< _Ty1, _Ty2>  & > , __cilk_box<const pair< _Ty1, _Ty2>  & > ); 
#line 115
template<class _Ty1, class 
_Ty2> inline pair< _Ty1, _Ty2>  
make_pair(_Ty1, _Ty2); 
#line 115
template<class _Ty1, class 
_Ty2> inline pair< _Ty1, _Ty2>   /* __cilk */ __cdecl 
__cilkfun_make_pair(__cilk_box<_Ty1 > , __cilk_box<_Ty2 > ); 




template<class _Ty1, class 
_Ty2> inline void 
swap(pair< _Ty1, _Ty2>  &, pair< _Ty1, _Ty2>  &); 
#line 122
template<class _Ty1, class 
_Ty2> inline void  /* __cilk */ __cdecl 
__cilkfun_swap(__cilk_box<pair< _Ty1, _Ty2>  & > , __cilk_box<pair< _Ty1, _Ty2>  & > ); 
#line 130
namespace rel_ops { 

template<class _Ty> inline bool 
operator!=(const _Ty &, const _Ty &); 
#line 132
template<class _Ty> inline bool  /* __cilk */ __cdecl 
__cilk_op_ne(__cilk_box<const _Ty & > , __cilk_box<const _Ty & > ); 




template<class _Ty> inline bool 
operator>(const _Ty &, const _Ty &); 
#line 138
template<class _Ty> inline bool  /* __cilk */ __cdecl 
__cilk_op_gt(__cilk_box<const _Ty & > , __cilk_box<const _Ty & > ); 




template<class _Ty> inline bool 
operator<=(const _Ty &, const _Ty &); 
#line 144
template<class _Ty> inline bool  /* __cilk */ __cdecl 
__cilk_op_le(__cilk_box<const _Ty & > , __cilk_box<const _Ty & > ); 




template<class _Ty> inline bool 
operator>=(const _Ty &, const _Ty &); 
#line 150
template<class _Ty> inline bool  /* __cilk */ __cdecl 
__cilk_op_ge(__cilk_box<const _Ty & > , __cilk_box<const _Ty & > ); 



}
}

#pragma warning(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xutility"
#pragma warning(push,3)
#line 159 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\utility"
#pragma pack ( pop )
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xutility"
#pragma pack ( push, 8 )



namespace std { 


struct _Unchecked_iterator_tag { friend struct __cilk_s;

}; 
struct _Range_checked_iterator_tag { friend struct __cilk_s;

}; 


struct _Unchanged_checked_iterator_base_type_tag { friend struct __cilk_s;

}; 

struct _Different_checked_iterator_base_type_tag { friend struct __cilk_s;

}; 


struct _Undefined_inner_type_tag { friend struct __cilk_s;

}; 


struct _Undefined_move_tag { friend struct __cilk_s;

}; 

struct _Swap_move_tag { friend struct __cilk_s;

}; 


class _Iterator_base_universal { friend struct __cilk_s;


public: typedef _Unchecked_iterator_tag _Checked_iterator_category; 
typedef _Unchanged_checked_iterator_base_type_tag _Checked_iterator_base_type; 
typedef _Undefined_inner_type_tag _Inner_type; 
}; 
#line 359
class _Container_base_aux; 

class _Aux_cont { friend struct __cilk_s;__CILK_METADATA(_Aux_cont, __CILK_VBASE_DETECT)


public: inline explicit _Aux_cont(const _Container_base_aux *const); 


inline const _Container_base_aux *_Getcont() const; 
#line 373
private: const _Container_base_aux *_Mycontainer; 
}; 
#line 364
inline _Aux_cont::_Aux_cont(const _Container_base_aux *const _Pcont) : _Mycontainer(_Pcont) 
{ } 

inline const _Container_base_aux *_Aux_cont::_Getcont() const 
{ 
return this->_Mycontainer; 
} 
#line 376
class _Container_base_aux { friend struct __cilk_s;__CILK_METADATA(_Container_base_aux, __CILK_VBASE_DETECT)


public: inline _Container_base_aux(); 




inline _Container_base_aux(const _Container_base_aux &); 




inline _Container_base_aux &operator=(const _Container_base_aux &); 
#line 395
inline void _Swap_aux(_Container_base_aux &); 
#line 401
inline ~_Container_base_aux(); 
#line 407
friend class _Iterator_base_aux; 

protected: _Aux_cont *_Myownedaux; 
}; 
#line 379
inline _Container_base_aux::_Container_base_aux() 
{ 

} 

inline _Container_base_aux::_Container_base_aux(const _Container_base_aux &__T12862592) 
{ 

} 

inline _Container_base_aux &_Container_base_aux::operator=(const _Container_base_aux &__T12863140) 
{ 

return *this; 
} 
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\utility"
template<> inline void swap(_Aux_cont *&, _Aux_cont *&); template<> inline void swap(_Aux_cont &, _Aux_cont &); 
#line 395 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xutility"
inline void _Container_base_aux::_Swap_aux(_Container_base_aux &_Right) 
{ 
std::swap(this->_Myownedaux, _Right._Myownedaux); 
std::swap(*(this->_Myownedaux), *(_Right._Myownedaux)); 
} 

inline _Container_base_aux::~_Container_base_aux() 
{ 

} 
#line 412
template<class _Alloc> 
class _Container_base_aux_alloc_real : public _Container_base_aux { friend struct __cilk_s;__CILK_METADATA(_Container_base_aux_alloc_real, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



protected: inline explicit _Container_base_aux_alloc_real(_Alloc); inline explicit  /* __cilk */ __thiscall _Container_base_aux_alloc_real(__cilk_box<_Alloc > ); 
#line 423
inline _Container_base_aux_alloc_real(const std::_Container_base_aux_alloc_real< _Alloc>  &); 
#line 429
inline std::_Container_base_aux_alloc_real< _Alloc>  &operator=(const std::_Container_base_aux_alloc_real< _Alloc>  &); 
#line 435
inline ~_Container_base_aux_alloc_real(); 
#line 442
typename _Alloc::template rebind< _Aux_cont> ::other _Alaux; 
}; 

class _Iterator_base_aux : public _Iterator_base_universal { friend struct __cilk_s;__CILK_METADATA(_Iterator_base_aux, __CILK_VBASE_DETECT)


public: inline _Iterator_base_aux(); 


inline void _Set_container(const _Container_base_aux *const); 




inline const _Container_base_aux *_Getmycont() const; 




inline bool _Same_container(const _Iterator_base_aux &) const; 




inline bool _Has_container() const; 
#line 472
private: const _Aux_cont *_Myaux; 
}; 
#line 448
inline _Iterator_base_aux::_Iterator_base_aux() : _Myaux((0)) 
{ } 

inline void _Iterator_base_aux::_Set_container(const _Container_base_aux *const _Pcont) 
{ 
(this->_Myaux) = _Pcont->_Myownedaux; 
} 

inline const _Container_base_aux *_Iterator_base_aux::_Getmycont() const 
{ 
return (this->_Myaux) ? (*(this->_Myaux))._Getcont() : (0); 
} 

inline bool _Iterator_base_aux::_Same_container(const _Iterator_base_aux &_Other) const 
{ 
return this->_Myaux == _Other._Myaux; 
} 

inline bool _Iterator_base_aux::_Has_container() const 
{ 
return this->_Myaux != (0); 
} 
#line 547
class __declspec( dllimport ) _Container_base_secure { friend struct __cilk_s;

}; 
#line 561
class _Iterator_base_secure : public _Iterator_base_universal { friend struct __cilk_s;__CILK_METADATA(_Iterator_base_secure, __CILK_VBASE_DETECT)



public: inline _Iterator_base_secure(); 




inline const _Container_base_secure *_Getmycont() const; 




inline bool _Same_container(const _Iterator_base_secure &) const; 




inline bool _Has_container() const; 




const _Container_base_secure *_Mycont; 
}; 
#line 565
inline _Iterator_base_secure::_Iterator_base_secure() : _Mycont((0)) 

{ 
} 

inline const _Container_base_secure *_Iterator_base_secure::_Getmycont() const 
{ 
return this->_Mycont; 
} 

inline bool _Iterator_base_secure::_Same_container(const _Iterator_base_secure &_Other) const 
{ 
return this->_Mycont == _Other._Mycont; 
} 

inline bool _Iterator_base_secure::_Has_container() const 
{ 
return this->_Mycont != (0); 
} 
#line 591
typedef _Container_base_aux _Container_base; 
typedef _Iterator_base_aux _Iterator_base; 
#line 613
template<class _Alloc> 
class _Container_base_aux_alloc_empty : public _Container_base { friend struct __cilk_s;__CILK_METADATA(_Container_base_aux_alloc_empty, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



protected: inline explicit _Container_base_aux_alloc_empty(_Alloc); inline explicit  /* __cilk */ __thiscall _Container_base_aux_alloc_empty(__cilk_box<_Alloc > ); 

inline _Container_base_aux_alloc_empty(const std::_Container_base_aux_alloc_empty< _Alloc>  &); 

inline std::_Container_base_aux_alloc_empty< _Alloc>  &operator=(const std::_Container_base_aux_alloc_empty< _Alloc>  &); 




inline ~_Container_base_aux_alloc_empty(); 
}; 
#line 642
struct input_iterator_tag { friend struct __cilk_s;

}; 

struct output_iterator_tag { friend struct __cilk_s;

}; 

struct forward_iterator_tag : public input_iterator_tag { friend struct __cilk_s;


}; 

struct bidirectional_iterator_tag : public forward_iterator_tag { friend struct __cilk_s;


}; 

struct random_access_iterator_tag : public bidirectional_iterator_tag { friend struct __cilk_s;


}; 

struct _Int_iterator_tag { friend struct __cilk_s;

}; 

struct _Float_iterator_tag { friend struct __cilk_s;

}; 


struct _Nonscalar_ptr_iterator_tag { friend struct __cilk_s;

}; 
struct _Scalar_ptr_iterator_tag { friend struct __cilk_s;

}; 


template<class _Category, class 
_Ty, class 
_Diff, class 
_Pointer, class 
_Reference> 
struct iterator : public _Iterator_base_universal { friend struct __cilk_s;__CILK_METADATA(iterator, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



typedef _Category iterator_category; 
typedef _Ty value_type; 
typedef _Diff difference_type; 
typedef _Diff distance_type; 
typedef _Pointer pointer; 
typedef _Reference reference; 
}; 

template<class _Category, class 
_Ty, class 
_Diff, class 
_Pointer, class 
_Reference, class 
_Base_class> 
struct _Iterator_with_base : public _Base_class { friend struct __cilk_s;__CILK_METADATA(_Iterator_with_base, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



typedef _Category iterator_category; 
typedef _Ty value_type; 
typedef _Diff difference_type; 
typedef _Diff distance_type; 
typedef _Pointer pointer; 
typedef _Reference reference; 
}; 

template<class _Ty, class 
_Diff, class 
_Pointer, class 
_Reference> 
struct _Bidit : public _Iterator_with_base< bidirectional_iterator_tag, _Ty, _Diff, _Pointer, _Reference, _Iterator_base_aux>  { friend struct __cilk_s;__CILK_METADATA(_Bidit, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



}; 

template<class _Ty, class 
_Diff, class 
_Pointer, class 
_Reference> 
struct _Ranit : public _Iterator_with_base< random_access_iterator_tag, _Ty, _Diff, _Pointer, _Reference, _Iterator_base_aux>  { friend struct __cilk_s;__CILK_METADATA(_Ranit, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



}; 

template<class _Ty, class 
_Diff, class 
_Pointer, class 
_Reference, class 
_Base_class> 
struct _Ranit_base : public _Base_class { friend struct __cilk_s;__CILK_METADATA(_Ranit_base, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



typedef random_access_iterator_tag iterator_category; 
typedef _Ty value_type; 
typedef _Diff difference_type; 
typedef _Diff distance_type; 
typedef _Pointer pointer; 
typedef _Reference reference; 
}; 

struct _Outit : public iterator< output_iterator_tag, void, void, void, void>  { friend struct __cilk_s;



}; 


template<class _Iter> 
struct iterator_traits { friend struct __cilk_s;__CILK_METADATA(iterator_traits, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef typename _Iter::iterator_category iterator_category; 
typedef typename _Iter::value_type value_type; 
typedef typename _Iter::difference_type difference_type; 
typedef difference_type distance_type; 
typedef typename _Iter::pointer pointer; 
typedef typename _Iter::reference reference; 
}; 

template<class _Ty> 
struct iterator_traits< _Ty *>  { friend struct __cilk_s;__CILK_METADATA(iterator_traits, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef random_access_iterator_tag iterator_category; 
typedef _Ty value_type; 
typedef ptrdiff_t difference_type; 
typedef ptrdiff_t distance_type; 
typedef _Ty *pointer; 
typedef _Ty &reference; 
}; 

template<class _Ty> 
struct iterator_traits< const _Ty *>  { friend struct __cilk_s;__CILK_METADATA(iterator_traits, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef random_access_iterator_tag iterator_category; 
typedef _Ty value_type; 
typedef ptrdiff_t difference_type; 
typedef ptrdiff_t distance_type; 
typedef const _Ty *pointer; 
typedef const _Ty &reference; 
}; 

template<> struct iterator_traits< bool>  { friend struct __cilk_s;__CILK_METADATA(iterator_traits, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Int_iterator_tag iterator_category; 
typedef _Bool value_type; 
typedef _Bool difference_type; 
typedef _Bool distance_type; 
typedef _Bool *pointer; 
typedef _Bool &reference; 
}; 

template<> struct iterator_traits< char>  { friend struct __cilk_s;__CILK_METADATA(iterator_traits, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Int_iterator_tag iterator_category; 
typedef char value_type; 
typedef char difference_type; 
typedef char distance_type; 
typedef char *pointer; 
typedef char &reference; 
}; 

template<> struct iterator_traits< signed char>  { friend struct __cilk_s;__CILK_METADATA(iterator_traits, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Int_iterator_tag iterator_category; 
typedef signed char value_type; 
typedef signed char difference_type; 
typedef signed char distance_type; 
typedef signed char *pointer; 
typedef signed char &reference; 
}; 

template<> struct iterator_traits< unsigned char>  { friend struct __cilk_s;__CILK_METADATA(iterator_traits, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Int_iterator_tag iterator_category; 
typedef unsigned char value_type; 
typedef unsigned char difference_type; 
typedef unsigned char distance_type; 
typedef unsigned char *pointer; 
typedef unsigned char &reference; 
}; 


template<> struct iterator_traits< __wchar_t>  { friend struct __cilk_s;__CILK_METADATA(iterator_traits, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Int_iterator_tag iterator_category; 
typedef __wchar_t value_type; 
typedef __wchar_t difference_type; 
typedef __wchar_t distance_type; 
typedef __wchar_t *pointer; 
typedef __wchar_t &reference; 
}; 


template<> struct iterator_traits< short>  { friend struct __cilk_s;__CILK_METADATA(iterator_traits, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Int_iterator_tag iterator_category; 
typedef short value_type; 
typedef short difference_type; 
typedef short distance_type; 
typedef short *pointer; 
typedef short &reference; 
}; 

template<> struct iterator_traits< unsigned short>  { friend struct __cilk_s;__CILK_METADATA(iterator_traits, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Int_iterator_tag iterator_category; 
typedef unsigned short value_type; 
typedef unsigned short difference_type; 
typedef unsigned short distance_type; 
typedef unsigned short *pointer; 
typedef unsigned short &reference; 
}; 

template<> struct iterator_traits< int>  { friend struct __cilk_s;__CILK_METADATA(iterator_traits, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Int_iterator_tag iterator_category; 
typedef int value_type; 
typedef int difference_type; 
typedef int distance_type; 
typedef int *pointer; 
typedef int &reference; 
}; 

template<> struct iterator_traits< unsigned>  { friend struct __cilk_s;__CILK_METADATA(iterator_traits, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Int_iterator_tag iterator_category; 
typedef unsigned value_type; 
typedef unsigned difference_type; 
typedef unsigned distance_type; 
typedef unsigned *pointer; 
typedef unsigned &reference; 
}; 

template<> struct iterator_traits< long>  { friend struct __cilk_s;__CILK_METADATA(iterator_traits, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Int_iterator_tag iterator_category; 
typedef long value_type; 
typedef long difference_type; 
typedef long distance_type; 
typedef long *pointer; 
typedef long &reference; 
}; 

template<> struct iterator_traits< unsigned long>  { friend struct __cilk_s;__CILK_METADATA(iterator_traits, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Int_iterator_tag iterator_category; 
typedef unsigned long value_type; 
typedef unsigned long difference_type; 
typedef unsigned long distance_type; 
typedef unsigned long *pointer; 
typedef unsigned long &reference; 
}; 

template<> struct iterator_traits< double>  { friend struct __cilk_s;__CILK_METADATA(iterator_traits, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Float_iterator_tag iterator_category; 
typedef double value_type; 
typedef double difference_type; 
typedef double distance_type; 
typedef double *pointer; 
typedef double &reference; 
}; 

template<> struct iterator_traits< float>  { friend struct __cilk_s;__CILK_METADATA(iterator_traits, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Float_iterator_tag iterator_category; 
typedef float value_type; 
typedef float difference_type; 
typedef float distance_type; 
typedef float *pointer; 
typedef float &reference; 
}; 


template<> struct iterator_traits< __int64>  { friend struct __cilk_s;__CILK_METADATA(iterator_traits, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Int_iterator_tag iterator_category; 
typedef __int64 value_type; 
typedef __int64 difference_type; 
typedef __int64 distance_type; 
typedef __int64 *pointer; 
typedef __int64 &reference; 
}; 

template<> struct iterator_traits< unsigned __int64>  { friend struct __cilk_s;__CILK_METADATA(iterator_traits, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Int_iterator_tag iterator_category; 
typedef unsigned __int64 value_type; 
typedef unsigned __int64 difference_type; 
typedef unsigned __int64 distance_type; 
typedef unsigned __int64 *pointer; 
typedef unsigned __int64 &reference; 
}; 



template<class _Iter> inline typename iterator_traits< _Iter> ::iterator_category 

_Iter_cat(const _Iter &); 
#line 949
template<class _Iter> inline typename iterator_traits< _Iter> ::iterator_category  /* __cilk */ __cdecl 

__cilkfun__Iter_cat(__cilk_box<const _Iter & > ); 
#line 960
template<class _Cat1, class _Cat2> 
class _Iter_random_helper { friend struct __cilk_s;__CILK_METADATA(_Iter_random_helper, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef forward_iterator_tag _Iter_random_cat; 
}; 


template<> class _Iter_random_helper< random_access_iterator_tag, random_access_iterator_tag>  { friend struct __cilk_s;__CILK_METADATA(_Iter_random_helper, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef random_access_iterator_tag _Iter_random_cat; 
}; 

template<class _Cat1, class _Cat2, class _Cat3> 
class _Iter_random_helper3 { friend struct __cilk_s;__CILK_METADATA(_Iter_random_helper3, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef forward_iterator_tag _Iter_random_cat; 
}; 


template<> class _Iter_random_helper3< random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag>  { friend struct __cilk_s;__CILK_METADATA(_Iter_random_helper3, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef random_access_iterator_tag _Iter_random_cat; 
}; 

template<class _Iter1, class _Iter2> inline typename _Iter_random_helper< typename iterator_traits< _Iter1> ::iterator_category, typename iterator_traits< _Iter2> ::iterator_category> ::_Iter_random_cat 



_Iter_random(const _Iter1 &, const _Iter2 &); 
#line 988
template<class _Iter1, class _Iter2> inline typename _Iter_random_helper< typename iterator_traits< _Iter1> ::iterator_category, typename iterator_traits< _Iter2> ::iterator_category> ::_Iter_random_cat  /* __cilk */ __cdecl 



__cilkfun__Iter_random(__cilk_box<const _Iter1 & > , __cilk_box<const _Iter2 & > ); 
#line 1000
template<class _Iter1, class _Iter2, class _Iter3> inline typename _Iter_random_helper3< typename iterator_traits< _Iter1> ::iterator_category, typename iterator_traits< _Iter2> ::iterator_category, typename iterator_traits< _Iter3> ::iterator_category> ::_Iter_random_cat 




_Iter_random(const _Iter1 &, const _Iter2 &, const _Iter3 &); 
#line 1000
template<class _Iter1, class _Iter2, class _Iter3> inline typename _Iter_random_helper3< typename iterator_traits< _Iter1> ::iterator_category, typename iterator_traits< _Iter2> ::iterator_category, typename iterator_traits< _Iter3> ::iterator_category> ::_Iter_random_cat  /* __cilk */ __cdecl 




__cilkfun__Iter_random(__cilk_box<const _Iter1 & > , __cilk_box<const _Iter2 & > , __cilk_box<const _Iter3 & > ); 
#line 1016
template<bool _Cond, class _Ty1, class _Ty2> 
class _If { friend struct __cilk_s;__CILK_METADATA(_If, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef _Ty2 _Result; 
}; 

template<class _Ty1, class _Ty2> 
class _If< true, _Ty1, _Ty2>  { friend struct __cilk_s;__CILK_METADATA(_If, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef _Ty1 _Result; 
}; 


template<bool _Secure_validation> 
class _Secure_validation_helper { friend struct __cilk_s;__CILK_METADATA(_Secure_validation_helper, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef _Unchecked_iterator_tag _Checked_iterator_category; 
}; 


template<> class _Secure_validation_helper< true>  { friend struct __cilk_s;__CILK_METADATA(_Secure_validation_helper, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef _Range_checked_iterator_tag _Checked_iterator_category; 
}; 



template<class _Iter, bool _Inherits_from_iterator_base> 
class _Checked_iterator_category_helper { friend struct __cilk_s;__CILK_METADATA(_Checked_iterator_category_helper, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef _Unchecked_iterator_tag _Checked_cat; 
}; 

template<class _Iter> 
class _Checked_iterator_category_helper< _Iter, true>  { friend struct __cilk_s;__CILK_METADATA(_Checked_iterator_category_helper, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef typename _Iter::_Checked_iterator_category _Checked_cat; 
}; 

template<class _Iter> 
class _Checked_iterator_category { friend struct __cilk_s;__CILK_METADATA(_Checked_iterator_category, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef typename _Checked_iterator_category_helper< _Iter, __is_base_of(_Iterator_base_universal, _Iter)> ::_Checked_cat _Checked_cat; 
}; 

template<class _Iter> inline typename _Checked_iterator_category< _Iter> ::_Checked_cat 

_Checked_cat(const _Iter &); 
#line 1068
template<class _Iter> inline typename _Checked_iterator_category< _Iter> ::_Checked_cat  /* __cilk */ __cdecl 

__cilkfun__Checked_cat(__cilk_box<const _Iter & > ); 
#line 1077
template<class _Iter, bool _Inherits_from_iterator_base> 
class _Checked_iterator_base_helper2 { friend struct __cilk_s;__CILK_METADATA(_Checked_iterator_base_helper2, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef _Unchanged_checked_iterator_base_type_tag _Checked_iterator_base_type; 
}; 

template<class _Iter> 
class _Checked_iterator_base_helper2< _Iter, true>  { friend struct __cilk_s;__CILK_METADATA(_Checked_iterator_base_helper2, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef typename _Iter::_Checked_iterator_base_type _Checked_iterator_base_type; 
}; 

template<class _Iter, class _Base_type> 
class _Checked_iterator_base_helper1 { friend struct __cilk_s;__CILK_METADATA(_Checked_iterator_base_helper1, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef _Different_checked_iterator_base_type_tag _Base_type_tag; 
typedef _Base_type _Checked_iterator_base_type; 
}; 

template<class _Iter> 
class _Checked_iterator_base_helper1< _Iter, _Unchanged_checked_iterator_base_type_tag>  { friend struct __cilk_s;__CILK_METADATA(_Checked_iterator_base_helper1, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef _Unchanged_checked_iterator_base_type_tag _Base_type_tag; 
typedef _Iter _Checked_iterator_base_type; 
}; 

template<class _Iter> 
class _Checked_iterator_base_helper { friend struct __cilk_s;__CILK_METADATA(_Checked_iterator_base_helper, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef _Checked_iterator_base_helper2< _Iter, __is_base_of(_Iterator_base_universal, _Iter)>  _Base_helper2; 
typedef _Checked_iterator_base_helper1< _Iter, typename _Checked_iterator_base_helper2< _Iter, __is_base_of(_Iterator_base_universal, _Iter)> ::_Checked_iterator_base_type>  _Base_helper1; 

typedef typename _Checked_iterator_base_helper1< _Iter, typename _Checked_iterator_base_helper2< _Iter, __is_base_of(_Iterator_base_universal, _Iter)> ::_Checked_iterator_base_type> ::_Base_type_tag _Checked_iterator_base_type_tag; 
typedef typename _Checked_iterator_base_helper1< _Iter, typename _Checked_iterator_base_helper2< _Iter, __is_base_of(_Iterator_base_universal, _Iter)> ::_Checked_iterator_base_type> ::_Checked_iterator_base_type _Checked_iterator_base_type; 
}; 

template<class _Iter, class _Base_tag> inline typename _Checked_iterator_base_helper< _Iter> ::_Checked_iterator_base_type 


_Checked_base(const _Iter &, _Base_tag); 
#line 1118
template<class _Iter, class _Base_tag> inline typename _Checked_iterator_base_helper< _Iter> ::_Checked_iterator_base_type  /* __cilk */ __cdecl 


__cilkfun__Checked_base(__cilk_box<const _Iter & > , __cilk_box<_Base_tag > ); 




template<class _Iter> inline typename _Checked_iterator_base_helper< _Iter> ::_Checked_iterator_base_type 


_Checked_base(const _Iter &, _Unchanged_checked_iterator_base_type_tag); 
#line 1126
template<class _Iter> inline typename _Checked_iterator_base_helper< _Iter> ::_Checked_iterator_base_type  /* __cilk */ __cdecl 


__cilkfun__Checked_base(__cilk_box<const _Iter & > , __cilk_box<_Unchanged_checked_iterator_base_type_tag > ); 




template<class _Iter, class _Base_tag> inline typename _Checked_iterator_base_helper< _Iter> ::_Checked_iterator_base_type 


_Checked_base(_Iter &, _Base_tag); 
#line 1134
template<class _Iter, class _Base_tag> inline typename _Checked_iterator_base_helper< _Iter> ::_Checked_iterator_base_type  /* __cilk */ __cdecl 


__cilkfun__Checked_base(__cilk_box<_Iter & > , __cilk_box<_Base_tag > ); 




template<class _Iter> inline typename _Checked_iterator_base_helper< _Iter> ::_Checked_iterator_base_type 


_Checked_base(_Iter &, _Unchanged_checked_iterator_base_type_tag); 
#line 1142
template<class _Iter> inline typename _Checked_iterator_base_helper< _Iter> ::_Checked_iterator_base_type  /* __cilk */ __cdecl 


__cilkfun__Checked_base(__cilk_box<_Iter & > , __cilk_box<_Unchanged_checked_iterator_base_type_tag > ); 




template<class _Iter> inline typename _Checked_iterator_base_helper< _Iter> ::_Checked_iterator_base_type 


_Checked_base(const _Iter &); 
#line 1150
template<class _Iter> inline typename _Checked_iterator_base_helper< _Iter> ::_Checked_iterator_base_type  /* __cilk */ __cdecl 


__cilkfun__Checked_base(__cilk_box<const _Iter & > ); 
#line 1159
template<class _Iter> inline typename _Checked_iterator_base_helper< _Iter> ::_Checked_iterator_base_type 


_Checked_base(_Iter &); 
#line 1159
template<class _Iter> inline typename _Checked_iterator_base_helper< _Iter> ::_Checked_iterator_base_type  /* __cilk */ __cdecl 


__cilkfun__Checked_base(__cilk_box<_Iter & > ); 
#line 1170
template<class _DstIter, class _BaseIter> inline void 

_Checked_assign_from_base(_DstIter &, const _BaseIter &); 
#line 1170
template<class _DstIter, class _BaseIter> inline void  /* __cilk */ __cdecl 

__cilkfun__Checked_assign_from_base(__cilk_box<_DstIter & > , __cilk_box<const _BaseIter & > ); 




template<class _Iter> inline void 

_Checked_assign_from_base(_Iter &, const _Iter &); 
#line 1177
template<class _Iter> inline void  /* __cilk */ __cdecl 

__cilkfun__Checked_assign_from_base(__cilk_box<_Iter & > , __cilk_box<const _Iter & > ); 
#line 1190
template<class _Value> 
class _Move_operation_category { friend struct __cilk_s;__CILK_METADATA(_Move_operation_category, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef _Undefined_move_tag _Move_cat; 
}; 

template<class _Iter> inline typename _Move_operation_category< typename iterator_traits< _Iter> ::value_type> ::_Move_cat 

_Move_cat(const _Iter &); 
#line 1197
template<class _Iter> inline typename _Move_operation_category< typename iterator_traits< _Iter> ::value_type> ::_Move_cat  /* __cilk */ __cdecl 

__cilkfun__Move_cat(__cilk_box<const _Iter & > ); 
#line 1206
template<class _T1, class _T2, class _Checked_Cat1, class _Checked_Cat2> 
struct _Ptr_cat_with_checked_cat_helper { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_with_checked_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Nonscalar_ptr_iterator_tag _Ptr_cat; 
}; 

template<class _T1, class _T2> 
struct _Ptr_cat_helper { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



typedef typename _Ptr_cat_with_checked_cat_helper< _T1, _T2, typename _Checked_iterator_category< _T1> ::_Checked_cat, typename _Checked_iterator_category< _T2> ::_Checked_cat> ::_Ptr_cat _Ptr_cat; 
}; 

template<class _T1, class _T2, class _Checked_Cat1> 
struct _Ptr_cat_with_checked_cat_helper< _T1, _T2, _Checked_Cat1, _Range_checked_iterator_tag>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_with_checked_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef typename _Ptr_cat_helper< _T1, typename _T2::_Inner_type> ::_Ptr_cat _Ptr_cat; 
}; 

template<class _T1, class _T2, class _Checked_Cat2> 
struct _Ptr_cat_with_checked_cat_helper< _T1, _T2, _Range_checked_iterator_tag, _Checked_Cat2>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_with_checked_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef typename _Ptr_cat_helper< typename _T1::_Inner_type, _T2> ::_Ptr_cat _Ptr_cat; 
}; 

template<class _T1, class _T2> 
struct _Ptr_cat_with_checked_cat_helper< _T1, _T2, _Range_checked_iterator_tag, _Range_checked_iterator_tag>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_with_checked_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef typename _Ptr_cat_helper< typename _T1::_Inner_type, typename _T2::_Inner_type> ::_Ptr_cat _Ptr_cat; 
}; 

template<class _T1> 
struct _Ptr_cat_helper< _T1, _Undefined_inner_type_tag>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Nonscalar_ptr_iterator_tag _Ptr_cat; 
}; 

template<class _T2> 
struct _Ptr_cat_helper< _Undefined_inner_type_tag, _T2>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Nonscalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< _Undefined_inner_type_tag, _Undefined_inner_type_tag>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Nonscalar_ptr_iterator_tag _Ptr_cat; 
}; 



template<> struct _Ptr_cat_helper< bool *, bool *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const bool *, bool *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< char *, char *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const char *, char *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< signed char *, signed char *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const signed char *, signed char *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< unsigned char *, unsigned char *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const unsigned char *, unsigned char *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 




template<> struct _Ptr_cat_helper< __wchar_t *, __wchar_t *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const __wchar_t *, __wchar_t *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 



template<> struct _Ptr_cat_helper< short *, short *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const short *, short *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< unsigned short *, unsigned short *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const unsigned short *, unsigned short *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< int *, int *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const int *, int *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< unsigned *, unsigned *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const unsigned *, unsigned *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< long *, long *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const long *, long *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< unsigned long *, unsigned long *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const unsigned long *, unsigned long *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< float *, float *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const float *, float *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< double *, double *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const double *, double *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< long double *, long double *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const long double *, long double *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 




template<> struct _Ptr_cat_helper< __int64 *, __int64 *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const __int64 *, __int64 *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< unsigned __int64 *, unsigned __int64 *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const unsigned __int64 *, unsigned __int64 *>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 



template<class _Ty> 
struct _Ptr_cat_helper< _Ty **, _Ty **>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 

template<class _Ty> 
struct _Ptr_cat_helper< _Ty **, const _Ty **>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 

template<class _Ty> 
struct _Ptr_cat_helper< _Ty *const *, _Ty **>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 

template<class _Ty> 
struct _Ptr_cat_helper< _Ty *const *, const _Ty **>  { friend struct __cilk_s;__CILK_METADATA(_Ptr_cat_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<class _T1, class _T2> inline typename _Ptr_cat_helper< _T1, _T2> ::_Ptr_cat 
_Ptr_cat(_T1 &, _T2 &); 
#line 1481
template<class _T1, class _T2> inline typename _Ptr_cat_helper< _T1, _T2> ::_Ptr_cat  /* __cilk */ __cdecl 
__cilkfun__Ptr_cat(__cilk_box<_T1 & > , __cilk_box<_T2 & > ); 
#line 1737
template<class _Iter> inline typename iterator_traits< _Iter> ::value_type *
_Val_type(_Iter); 
#line 1737
template<class _Iter> inline typename iterator_traits< _Iter> ::value_type * /* __cilk */ __cdecl 
__cilkfun__Val_type(__cilk_box<_Iter > ); 
#line 1744
template<class _InIt, class 
_Diff> inline void 
advance(_InIt &, _Diff); 
#line 1744
template<class _InIt, class 
_Diff> inline void  /* __cilk */ __cdecl 
__cilkfun_advance(__cilk_box<_InIt & > , __cilk_box<_Diff > ); 




template<class _InIt, class 
_Diff> inline void 
_Advance(_InIt &, _Diff, input_iterator_tag); 
#line 1751
template<class _InIt, class 
_Diff> inline void  /* __cilk */ __cdecl 
__cilkfun__Advance(__cilk_box<_InIt & > , __cilk_box<_Diff > , __cilk_box<input_iterator_tag > ); 
#line 1765
template<class _FI, class 
_Diff> inline void 
_Advance(_FI &, _Diff, forward_iterator_tag); 
#line 1765
template<class _FI, class 
_Diff> inline void  /* __cilk */ __cdecl 
__cilkfun__Advance(__cilk_box<_FI & > , __cilk_box<_Diff > , __cilk_box<forward_iterator_tag > ); 
#line 1779
#pragma warning(push)
#pragma warning(disable: 6295)
template<class _BI, class 
_Diff> inline void 
_Advance(_BI &, _Diff, bidirectional_iterator_tag); 
#line 1781
template<class _BI, class 
_Diff> inline void  /* __cilk */ __cdecl 
__cilkfun__Advance(__cilk_box<_BI & > , __cilk_box<_Diff > , __cilk_box<bidirectional_iterator_tag > ); 
#line 1790
#pragma warning(pop)

template<class _RI, class 
_Diff> inline void 
_Advance(_RI &, _Diff, random_access_iterator_tag); 
#line 1792
template<class _RI, class 
_Diff> inline void  /* __cilk */ __cdecl 
__cilkfun__Advance(__cilk_box<_RI & > , __cilk_box<_Diff > , __cilk_box<random_access_iterator_tag > ); 
#line 1801
template<class _Iter> inline typename iterator_traits< _Iter> ::difference_type *

_Dist_type(_Iter); 
#line 1801
template<class _Iter> inline typename iterator_traits< _Iter> ::difference_type * /* __cilk */ __cdecl 

__cilkfun__Dist_type(__cilk_box<_Iter > ); 
#line 1809
template<class _InIt, class 
_Diff> inline void 
_Distance2(_InIt, _InIt, _Diff &, input_iterator_tag); 
#line 1809
template<class _InIt, class 
_Diff> inline void  /* __cilk */ __cdecl 
__cilkfun__Distance2(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_Diff & > , __cilk_box<input_iterator_tag > ); 
#line 1818
template<class _FwdIt, class 
_Diff> inline void 
_Distance2(_FwdIt, _FwdIt, _Diff &, forward_iterator_tag); 
#line 1818
template<class _FwdIt, class 
_Diff> inline void  /* __cilk */ __cdecl 
__cilkfun__Distance2(__cilk_box<_FwdIt > , __cilk_box<_FwdIt > , __cilk_box<_Diff & > , __cilk_box<forward_iterator_tag > ); 
#line 1827
template<class _BidIt, class 
_Diff> inline void 
_Distance2(_BidIt, _BidIt, _Diff &, bidirectional_iterator_tag); 
#line 1827
template<class _BidIt, class 
_Diff> inline void  /* __cilk */ __cdecl 
__cilkfun__Distance2(__cilk_box<_BidIt > , __cilk_box<_BidIt > , __cilk_box<_Diff & > , __cilk_box<bidirectional_iterator_tag > ); 
#line 1836
template<class _RanIt, class 
_Diff> inline void 
_Distance2(_RanIt, _RanIt, _Diff &, random_access_iterator_tag); 
#line 1836
template<class _RanIt, class 
_Diff> inline void  /* __cilk */ __cdecl 
__cilkfun__Distance2(__cilk_box<_RanIt > , __cilk_box<_RanIt > , __cilk_box<_Diff & > , __cilk_box<random_access_iterator_tag > ); 
#line 1853
template<class _InIt> inline typename iterator_traits< _InIt> ::difference_type 

distance(_InIt, _InIt); 
#line 1853
template<class _InIt> inline typename iterator_traits< _InIt> ::difference_type  /* __cilk */ __cdecl 

__cilkfun_distance(__cilk_box<_InIt > , __cilk_box<_InIt > ); 
#line 1863
template<class _InIt, class 
_Diff> inline void 
_Distance(_InIt, _InIt, _Diff &); 
#line 1863
template<class _InIt, class 
_Diff> inline void  /* __cilk */ __cdecl 
__cilkfun__Distance(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_Diff & > ); 
#line 1871
template<class _RanIt, class 
_Base> 
class _Revranit : public _Base { friend struct __cilk_s;__CILK_METADATA(_Revranit, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



typedef std::_Revranit< _RanIt, _Base>  _Myt; 
typedef typename iterator_traits< _RanIt> ::iterator_category iterator_category; 
typedef typename iterator_traits< _RanIt> ::value_type value_type; 
typedef typename iterator_traits< _RanIt> ::difference_type difference_type; 
typedef typename iterator_traits< _RanIt> ::difference_type distance_type; 
typedef typename iterator_traits< _RanIt> ::pointer pointer; 
typedef typename iterator_traits< _RanIt> ::reference reference; 
typedef _RanIt iterator_type; 

inline _Revranit(); 



inline explicit _Revranit(_RanIt); inline explicit  /* __cilk */ __thiscall _Revranit(__cilk_box<_RanIt > ); 




template<class _RanIt2, class 
_Base2> inline 
_Revranit(const std::_Revranit< _RanIt2, _Base2>  &); 
#line 1895
template<class _RanIt2, class 
_Base2> inline  /* __cilk */ __thiscall 
_Revranit(__cilk_box<const std::_Revranit< _RanIt2, _Base2>  & > ); 




inline _RanIt base() const; inline _RanIt  /* __cilk */ __thiscall __cilkfun_base() const; 




inline reference operator*() const; 
#line 1913
inline pointer operator->() const; 




inline _Myt &operator++(); 
#line 1924
inline _Myt operator++(int); 
#line 1931
inline _Myt &operator--(); 
#line 1937
inline _Myt operator--(int); 
#line 1944
template<class _RanIt2, class 
_Base2> inline bool 
_Equal(const std::_Revranit< _RanIt2, _Base2>  &) const; 
#line 1944
template<class _RanIt2, class 
_Base2> inline bool  /* __cilk */ __thiscall 
__cilkfun__Equal(__cilk_box<const std::_Revranit< _RanIt2, _Base2>  & > ) const; 
#line 1953
inline _Myt &operator+=(difference_type); inline _Myt & /* __cilk */ __thiscall __cilk_op_plus_assign(__cilk_box<typename iterator_traits< _RanIt> ::difference_type > ); 
#line 1959
inline _Myt operator+(difference_type) const; inline _Myt  /* __cilk */ __thiscall __cilk_op_plus(__cilk_box<typename iterator_traits< _RanIt> ::difference_type > ) const; 




inline _Myt &operator-=(difference_type); inline _Myt & /* __cilk */ __thiscall __cilk_op_minus_assign(__cilk_box<typename iterator_traits< _RanIt> ::difference_type > ); 
#line 1970
inline _Myt operator-(difference_type) const; inline _Myt  /* __cilk */ __thiscall __cilk_op_minus(__cilk_box<typename iterator_traits< _RanIt> ::difference_type > ) const; 




inline reference operator[](difference_type) const; inline reference  /* __cilk */ __thiscall __cilk_op_subscript(__cilk_box<typename iterator_traits< _RanIt> ::difference_type > ) const; 




template<class _RanIt2, class 
_Base2> inline bool 
_Less(const std::_Revranit< _RanIt2, _Base2>  &) const; 
#line 1980
template<class _RanIt2, class 
_Base2> inline bool  /* __cilk */ __thiscall 
__cilkfun__Less(__cilk_box<const std::_Revranit< _RanIt2, _Base2>  & > ) const; 




template<class _RanIt2, class 
_Base2> inline difference_type 
_Minus(const std::_Revranit< _RanIt2, _Base2>  &) const; 
#line 1987
template<class _RanIt2, class 
_Base2> inline difference_type  /* __cilk */ __thiscall 
__cilkfun__Minus(__cilk_box<const std::_Revranit< _RanIt2, _Base2>  & > ) const; 
#line 1995
protected: _RanIt current; 
}; 


template<class _RanIt, class 
_Base, class 
_Diff> inline _Revranit< _RanIt, _Base>  

operator+(_Diff, const _Revranit< _RanIt, _Base>  &); 
#line 1999
template<class _RanIt, class 
_Base, class 
_Diff> inline _Revranit< _RanIt, _Base>   /* __cilk */ __cdecl 

__cilk_op_plus(__cilk_box<_Diff > , __cilk_box<const _Revranit< _RanIt, _Base>  & > ); 
#line 2009
template<class _RanIt1, class 
_Base1, class 
_RanIt2, class 
_Base2> inline typename _Base1::difference_type 
operator-(const _Revranit< _RanIt1, _Base1>  &, const _Revranit< _RanIt2, _Base2>  &); 
#line 2009
template<class _RanIt1, class 
_Base1, class 
_RanIt2, class 
_Base2> inline typename _Base1::difference_type  /* __cilk */ __cdecl 
__cilk_op_minus(__cilk_box<const _Revranit< _RanIt1, _Base1>  & > , __cilk_box<const _Revranit< _RanIt2, _Base2>  & > ); 
#line 2020
template<class _RanIt1, class 
_Base1, class 
_RanIt2, class 
_Base2> inline bool 
operator==(const _Revranit< _RanIt1, _Base1>  &, const _Revranit< _RanIt2, _Base2>  &); 
#line 2020
template<class _RanIt1, class 
_Base1, class 
_RanIt2, class 
_Base2> inline bool  /* __cilk */ __cdecl 
__cilk_op_eq(__cilk_box<const _Revranit< _RanIt1, _Base1>  & > , __cilk_box<const _Revranit< _RanIt2, _Base2>  & > ); 
#line 2031
template<class _RanIt1, class 
_Base1, class 
_RanIt2, class 
_Base2> inline bool 
operator!=(const _Revranit< _RanIt1, _Base1>  &, const _Revranit< _RanIt2, _Base2>  &); 
#line 2031
template<class _RanIt1, class 
_Base1, class 
_RanIt2, class 
_Base2> inline bool  /* __cilk */ __cdecl 
__cilk_op_ne(__cilk_box<const _Revranit< _RanIt1, _Base1>  & > , __cilk_box<const _Revranit< _RanIt2, _Base2>  & > ); 
#line 2042
template<class _RanIt1, class 
_Base1, class 
_RanIt2, class 
_Base2> inline bool 
operator<(const _Revranit< _RanIt1, _Base1>  &, const _Revranit< _RanIt2, _Base2>  &); 
#line 2042
template<class _RanIt1, class 
_Base1, class 
_RanIt2, class 
_Base2> inline bool  /* __cilk */ __cdecl 
__cilk_op_lt(__cilk_box<const _Revranit< _RanIt1, _Base1>  & > , __cilk_box<const _Revranit< _RanIt2, _Base2>  & > ); 
#line 2053
template<class _RanIt1, class 
_Base1, class 
_RanIt2, class 
_Base2> inline bool 
operator>(const _Revranit< _RanIt1, _Base1>  &, const _Revranit< _RanIt2, _Base2>  &); 
#line 2053
template<class _RanIt1, class 
_Base1, class 
_RanIt2, class 
_Base2> inline bool  /* __cilk */ __cdecl 
__cilk_op_gt(__cilk_box<const _Revranit< _RanIt1, _Base1>  & > , __cilk_box<const _Revranit< _RanIt2, _Base2>  & > ); 
#line 2064
template<class _RanIt1, class 
_Base1, class 
_RanIt2, class 
_Base2> inline bool 
operator<=(const _Revranit< _RanIt1, _Base1>  &, const _Revranit< _RanIt2, _Base2>  &); 
#line 2064
template<class _RanIt1, class 
_Base1, class 
_RanIt2, class 
_Base2> inline bool  /* __cilk */ __cdecl 
__cilk_op_le(__cilk_box<const _Revranit< _RanIt1, _Base1>  & > , __cilk_box<const _Revranit< _RanIt2, _Base2>  & > ); 
#line 2075
template<class _RanIt1, class 
_Base1, class 
_RanIt2, class 
_Base2> inline bool 
operator>=(const _Revranit< _RanIt1, _Base1>  &, const _Revranit< _RanIt2, _Base2>  &); 
#line 2075
template<class _RanIt1, class 
_Base1, class 
_RanIt2, class 
_Base2> inline bool  /* __cilk */ __cdecl 
__cilk_op_ge(__cilk_box<const _Revranit< _RanIt1, _Base1>  & > , __cilk_box<const _Revranit< _RanIt2, _Base2>  & > ); 
#line 2087
template<class _RanIt> 
class reverse_iterator : public _Revranit< _RanIt, iterator< typename iterator_traits< _RanIt> ::iterator_category, typename iterator_traits< _RanIt> ::value_type, typename iterator_traits< _RanIt> ::difference_type, typename iterator_traits< _RanIt> ::pointer, typename iterator_traits< _RanIt> ::reference> >  { friend struct __cilk_s;__CILK_METADATA(reverse_iterator, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;
#line 2096
typedef std::reverse_iterator< _RanIt>  _Myt; 
#line 2102
typedef _Revranit< _RanIt, iterator< typename iterator_traits< _RanIt> ::iterator_category, typename iterator_traits< _RanIt> ::value_type, typename iterator_traits< _RanIt> ::difference_type, typename iterator_traits< _RanIt> ::pointer, typename iterator_traits< _RanIt> ::reference> >  _Mybase; 


typedef typename iterator_traits< _RanIt> ::iterator_category iterator_category; 
typedef typename iterator_traits< _RanIt> ::value_type value_type; 
typedef typename iterator_traits< _RanIt> ::difference_type difference_type; 
typedef typename iterator_traits< _RanIt> ::difference_type distance_type; 
typedef typename iterator_traits< _RanIt> ::pointer pointer; 
typedef typename iterator_traits< _RanIt> ::reference reference; 
typedef _RanIt iterator_type; 

inline reverse_iterator(); 



inline explicit reverse_iterator(_RanIt); inline explicit  /* __cilk */ __thiscall reverse_iterator(__cilk_box<_RanIt > ); 




template<class _Other> inline 
reverse_iterator(const std::reverse_iterator< _Other>  &); 
#line 2122
template<class _Other> inline  /* __cilk */ __thiscall 
reverse_iterator(__cilk_box<const std::reverse_iterator< _Other>  & > ); 




inline reverse_iterator(_Mybase); inline  /* __cilk */ __thiscall reverse_iterator(__cilk_box<_Revranit< _RanIt, iterator< typename iterator_traits< _RanIt> ::iterator_category, typename iterator_traits< _RanIt> ::value_type, typename iterator_traits< _RanIt> ::difference_type, typename iterator_traits< _RanIt> ::pointer, typename iterator_traits< _RanIt> ::reference> >  > ); 
#line 2134
typedef typename std::_Checked_iterator_category< _RanIt> ::_Checked_cat _Checked_iterator_category; 
typedef std::reverse_iterator< typename _Checked_iterator_base_helper< _RanIt> ::_Checked_iterator_base_type>  _Checked_iterator_base_type; 

inline _Checked_iterator_base_type _Checked_iterator_base() const; inline _Checked_iterator_base_type  /* __cilk */ __thiscall __cilkfun__Checked_iterator_base() const; 
#line 2143
inline void _Checked_iterator_assign_from_base(_Checked_iterator_base_type); inline void  /* __cilk */ __thiscall __cilkfun__Checked_iterator_assign_from_base(__cilk_box<std::reverse_iterator< typename _Checked_iterator_base_helper< _RanIt> ::_Checked_iterator_base_type>  > ); 
#line 2149
inline _Myt &operator++(); 
#line 2155
inline _Myt operator++(int); 
#line 2162
inline _Myt &operator--(); 
#line 2168
inline _Myt operator--(int); 
#line 2175
inline _Myt &operator+=(difference_type); inline _Myt & /* __cilk */ __thiscall __cilk_op_plus_assign(__cilk_box<typename iterator_traits< _RanIt> ::difference_type > ); 
#line 2181
inline _Myt operator+(difference_type) const; inline _Myt  /* __cilk */ __thiscall __cilk_op_plus(__cilk_box<typename iterator_traits< _RanIt> ::difference_type > ) const; 
#line 2187
inline _Myt &operator-=(difference_type); inline _Myt & /* __cilk */ __thiscall __cilk_op_minus_assign(__cilk_box<typename iterator_traits< _RanIt> ::difference_type > ); 
#line 2193
inline _Myt operator-(difference_type) const; inline _Myt  /* __cilk */ __thiscall __cilk_op_minus(__cilk_box<typename iterator_traits< _RanIt> ::difference_type > ) const; 




}; 


template<class _RanIt, class 
_Diff> inline reverse_iterator< _RanIt>  
operator+(_Diff, const reverse_iterator< _RanIt>  &); 
#line 2201
template<class _RanIt, class 
_Diff> inline reverse_iterator< _RanIt>   /* __cilk */ __cdecl 
__cilk_op_plus(__cilk_box<_Diff > , __cilk_box<const reverse_iterator< _RanIt>  & > ); 
#line 2209
template<class _RanIt1, class 
_RanIt2> inline typename reverse_iterator< _RanIt1> ::difference_type 

operator-(const reverse_iterator< _RanIt1>  &, const reverse_iterator< _RanIt2>  &); 
#line 2209
template<class _RanIt1, class 
_RanIt2> inline typename reverse_iterator< _RanIt1> ::difference_type  /* __cilk */ __cdecl 

__cilk_op_minus(__cilk_box<const reverse_iterator< _RanIt1>  & > , __cilk_box<const reverse_iterator< _RanIt2>  & > ); 
#line 2218
template<class _RanIt1, class 
_RanIt2> inline bool 
operator==(const reverse_iterator< _RanIt1>  &, const reverse_iterator< _RanIt2>  &); 
#line 2218
template<class _RanIt1, class 
_RanIt2> inline bool  /* __cilk */ __cdecl 
__cilk_op_eq(__cilk_box<const reverse_iterator< _RanIt1>  & > , __cilk_box<const reverse_iterator< _RanIt2>  & > ); 
#line 2226
template<class _RanIt1, class 
_RanIt2> inline bool 
operator!=(const reverse_iterator< _RanIt1>  &, const reverse_iterator< _RanIt2>  &); 
#line 2226
template<class _RanIt1, class 
_RanIt2> inline bool  /* __cilk */ __cdecl 
__cilk_op_ne(__cilk_box<const reverse_iterator< _RanIt1>  & > , __cilk_box<const reverse_iterator< _RanIt2>  & > ); 
#line 2234
template<class _RanIt1, class 
_RanIt2> inline bool 
operator<(const reverse_iterator< _RanIt1>  &, const reverse_iterator< _RanIt2>  &); 
#line 2234
template<class _RanIt1, class 
_RanIt2> inline bool  /* __cilk */ __cdecl 
__cilk_op_lt(__cilk_box<const reverse_iterator< _RanIt1>  & > , __cilk_box<const reverse_iterator< _RanIt2>  & > ); 
#line 2242
template<class _RanIt1, class 
_RanIt2> inline bool 
operator>(const reverse_iterator< _RanIt1>  &, const reverse_iterator< _RanIt2>  &); 
#line 2242
template<class _RanIt1, class 
_RanIt2> inline bool  /* __cilk */ __cdecl 
__cilk_op_gt(__cilk_box<const reverse_iterator< _RanIt1>  & > , __cilk_box<const reverse_iterator< _RanIt2>  & > ); 
#line 2250
template<class _RanIt1, class 
_RanIt2> inline bool 
operator<=(const reverse_iterator< _RanIt1>  &, const reverse_iterator< _RanIt2>  &); 
#line 2250
template<class _RanIt1, class 
_RanIt2> inline bool  /* __cilk */ __cdecl 
__cilk_op_le(__cilk_box<const reverse_iterator< _RanIt1>  & > , __cilk_box<const reverse_iterator< _RanIt2>  & > ); 
#line 2258
template<class _RanIt1, class 
_RanIt2> inline bool 
operator>=(const reverse_iterator< _RanIt1>  &, const reverse_iterator< _RanIt2>  &); 
#line 2258
template<class _RanIt1, class 
_RanIt2> inline bool  /* __cilk */ __cdecl 
__cilk_op_ge(__cilk_box<const reverse_iterator< _RanIt1>  & > , __cilk_box<const reverse_iterator< _RanIt2>  & > ); 
#line 2267
template<class _BidIt, class 
_Ty, class 
_Reference, class 
_Pointer, class 
_Diff> 
class reverse_bidirectional_iterator : public iterator< bidirectional_iterator_tag, _Ty, _Diff, _Pointer, _Reference>  { friend struct __cilk_s;__CILK_METADATA(reverse_bidirectional_iterator, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;
#line 2278
typedef std::reverse_bidirectional_iterator< _BidIt, _Ty, _Reference, _Pointer, _Diff>  _Myt; 
typedef _BidIt iterator_type; 

inline reverse_bidirectional_iterator(); 



inline explicit reverse_bidirectional_iterator(_BidIt); inline explicit  /* __cilk */ __thiscall reverse_bidirectional_iterator(__cilk_box<_BidIt > ); 




inline _BidIt base() const; inline _BidIt  /* __cilk */ __thiscall __cilkfun_base() const; 




inline _Reference operator*() const; 
#line 2301
inline _Pointer operator->() const; 
#line 2307
inline _Myt &operator++(); 
#line 2313
inline _Myt operator++(int); 
#line 2320
inline _Myt &operator--(); 
#line 2326
inline _Myt operator--(int); 
#line 2333
inline bool operator==(const _Myt &) const; inline bool  /* __cilk */ __thiscall __cilk_op_eq(__cilk_box<const _Myt & > ) const; 




inline bool operator!=(const _Myt &) const; inline bool  /* __cilk */ __thiscall __cilk_op_ne(__cilk_box<const _Myt & > ) const; 
#line 2344
protected: _BidIt current; 
}; 


template<class _BidIt, class 
_BidIt2> 
class _Revbidit : public iterator< typename iterator_traits< _BidIt> ::iterator_category, typename iterator_traits< _BidIt> ::value_type, typename iterator_traits< _BidIt> ::difference_type, typename iterator_traits< _BidIt> ::pointer, typename iterator_traits< _BidIt> ::reference>  { friend struct __cilk_s;__CILK_METADATA(_Revbidit, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;
#line 2359
typedef std::_Revbidit< _BidIt, _BidIt2>  _Myt; 
typedef typename iterator_traits< _BidIt> ::difference_type _Diff; 
typedef typename iterator_traits< _BidIt> ::pointer _Pointer; 
typedef typename iterator_traits< _BidIt> ::reference _Reference; 
typedef _BidIt iterator_type; 

inline _Revbidit(); 



inline explicit _Revbidit(_BidIt); inline explicit  /* __cilk */ __thiscall _Revbidit(__cilk_box<_BidIt > ); 




inline _Revbidit(const std::_Revbidit< _BidIt2, _BidIt2>  &); inline  /* __cilk */ __thiscall _Revbidit(__cilk_box<const std::_Revbidit< _BidIt2, _BidIt2>  & > ); 




inline _BidIt base() const; inline _BidIt  /* __cilk */ __thiscall __cilkfun_base() const; 




inline _Reference operator*() const; 
#line 2390
inline _Pointer operator->() const; 
#line 2396
inline _Myt &operator++(); 
#line 2402
inline _Myt operator++(int); 
#line 2409
inline _Myt &operator--(); 
#line 2415
inline _Myt operator--(int); 
#line 2422
inline bool operator==(const _Myt &) const; inline bool  /* __cilk */ __thiscall __cilk_op_eq(__cilk_box<const _Myt & > ) const; 




inline bool operator!=(const _Myt &) const; inline bool  /* __cilk */ __thiscall __cilk_op_ne(__cilk_box<const _Myt & > ) const; 
#line 2433
protected: _BidIt current; 
}; 




template<class _InIt, class _OutIt, class _InOutItCat> inline _OutIt 

_Copy_opt(_InIt, _InIt, _OutIt, _InOutItCat, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag); 
#line 2439
template<class _InIt, class _OutIt, class _InOutItCat> inline _OutIt  /* __cilk */ __cdecl 

__cilkfun__Copy_opt(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_OutIt > , __cilk_box<_InOutItCat > , __cilk_box<_Nonscalar_ptr_iterator_tag > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 2451
template<class _InIt, class _OutIt> inline _OutIt 

_Copy_opt(_InIt, _InIt, _OutIt, random_access_iterator_tag, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag); 
#line 2451
template<class _InIt, class _OutIt> inline _OutIt  /* __cilk */ __cdecl 

__cilkfun__Copy_opt(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_OutIt > , __cilk_box<random_access_iterator_tag > , __cilk_box<_Nonscalar_ptr_iterator_tag > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 2464
template<class _InIt, class _OutIt, class _InOutItCat> inline _OutIt 

_Copy_opt(_InIt, _InIt, _OutIt, _InOutItCat, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag); 
#line 2464
template<class _InIt, class _OutIt, class _InOutItCat> inline _OutIt  /* __cilk */ __cdecl 

__cilkfun__Copy_opt(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_OutIt > , __cilk_box<_InOutItCat > , __cilk_box<_Scalar_ptr_iterator_tag > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 2484
template<bool _Cond, class _Result_type> struct _Enable_if; 


template<class _Result_type> 
struct _Enable_if< true, _Result_type>  { friend struct __cilk_s;__CILK_METADATA(_Enable_if, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Result_type _Result; 
}; 

template<class _Checked_iter_cat> 
struct _Is_checked_iterator_helper { friend struct __cilk_s;__CILK_METADATA(_Is_checked_iterator_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

enum { _Result}; 
}; 


template<> struct _Is_checked_iterator_helper< _Range_checked_iterator_tag>  { friend struct __cilk_s;__CILK_METADATA(_Is_checked_iterator_helper, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

enum { _Result = 1}; 
}; 

template<class _Iter> 
struct _Is_checked_iterator { friend struct __cilk_s;__CILK_METADATA(_Is_checked_iterator, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

enum { _Result = _Is_checked_iterator_helper< typename _Checked_iterator_category< _Iter> ::_Checked_cat> ::_Result
}; 
}; 
#line 2532
template<class _InIt, class _OutIt> inline typename _Enable_if< _Is_checked_iterator< _OutIt> ::_Result, _OutIt> ::_Result 

copy(_InIt, _InIt, _OutIt); 
#line 2532
template<class _InIt, class _OutIt> inline typename _Enable_if< _Is_checked_iterator< _OutIt> ::_Result, _OutIt> ::_Result  /* __cilk */ __cdecl 

__cilkfun_copy(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_OutIt > ); 
#line 2540
template<class _InIt, class _OutElem, size_t _Size> inline _OutElem *

copy(_InIt, _InIt, _OutElem (&)[_Size]); 
#line 2540
template<class _InIt, class _OutElem, size_t _Size> inline _OutElem * /* __cilk */ __cdecl 

__cilkfun_copy(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_OutElem (&)[_Size] > ); 




template<class _InIt, class _OutIt> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename _Enable_if< (!_Is_checked_iterator< _OutIt> ::_Result), _OutIt> ::_Result 


copy(_InIt, _InIt, _OutIt); 
#line 2547
template<class _InIt, class _OutIt> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename _Enable_if< (!_Is_checked_iterator< _OutIt> ::_Result), _OutIt> ::_Result  /* __cilk */ __cdecl 


__cilkfun_copy(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_OutIt > ); 
#line 2569
template<class _InIt, class _OutIt, class _InOutItCat, class _MoveCatTy> inline _OutIt 

_Move_opt(_InIt, _InIt, _OutIt, _InOutItCat, _MoveCatTy, _Range_checked_iterator_tag); 
#line 2569
template<class _InIt, class _OutIt, class _InOutItCat, class _MoveCatTy> inline _OutIt  /* __cilk */ __cdecl 

__cilkfun__Move_opt(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_OutIt > , __cilk_box<_InOutItCat > , __cilk_box<_MoveCatTy > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 2578
template<class _InIt, class _OutIt, class _InOutItCat> inline _OutIt 

_Move_opt(_InIt, _InIt, _OutIt, _InOutItCat, _Swap_move_tag, _Range_checked_iterator_tag); 
#line 2578
template<class _InIt, class _OutIt, class _InOutItCat> inline _OutIt  /* __cilk */ __cdecl 

__cilkfun__Move_opt(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_OutIt > , __cilk_box<_InOutItCat > , __cilk_box<_Swap_move_tag > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 2590
template<class _InIt, class _OutIt, class _InOutItCat> inline _OutIt 

_Move_opt(_InIt, _InIt, _OutIt, random_access_iterator_tag, _Swap_move_tag, _Range_checked_iterator_tag); 
#line 2590
template<class _InIt, class _OutIt, class _InOutItCat> inline _OutIt  /* __cilk */ __cdecl 

__cilkfun__Move_opt(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_OutIt > , __cilk_box<random_access_iterator_tag > , __cilk_box<_Swap_move_tag > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 2605
template<class _InIt, class _OutIt> inline typename _Enable_if< _Is_checked_iterator< _OutIt> ::_Result, _OutIt> ::_Result 

_Move(_InIt, _InIt, _OutIt); 
#line 2605
template<class _InIt, class _OutIt> inline typename _Enable_if< _Is_checked_iterator< _OutIt> ::_Result, _OutIt> ::_Result  /* __cilk */ __cdecl 

__cilkfun__Move(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_OutIt > ); 
#line 2613
template<class _InIt, class _OutElem, size_t _Size> inline _OutElem *

_Move(_InIt, _InIt, _OutElem (&)[_Size]); 
#line 2613
template<class _InIt, class _OutElem, size_t _Size> inline _OutElem * /* __cilk */ __cdecl 

__cilkfun__Move(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_OutElem (&)[_Size] > ); 
#line 2621
template<class _InIt, class _OutIt> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename _Enable_if< (!_Is_checked_iterator< _OutIt> ::_Result), _OutIt> ::_Result 


_Move(_InIt, _InIt, _OutIt); 
#line 2621
template<class _InIt, class _OutIt> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename _Enable_if< (!_Is_checked_iterator< _OutIt> ::_Result), _OutIt> ::_Result  /* __cilk */ __cdecl 


__cilkfun__Move(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_OutIt > ); 
#line 2643
template<class _BidIt1, class _BidIt2, class _InOutItCat> inline _BidIt2 

_Copy_backward_opt(_BidIt1, _BidIt1, _BidIt2, _InOutItCat, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag); 
#line 2643
template<class _BidIt1, class _BidIt2, class _InOutItCat> inline _BidIt2  /* __cilk */ __cdecl 

__cilkfun__Copy_backward_opt(__cilk_box<_BidIt1 > , __cilk_box<_BidIt1 > , __cilk_box<_BidIt2 > , __cilk_box<_InOutItCat > , __cilk_box<_Nonscalar_ptr_iterator_tag > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 2655
template<class _InIt, class _OutIt> inline _OutIt 

_Copy_backward_opt(_InIt, _InIt, _OutIt, random_access_iterator_tag, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag); 
#line 2655
template<class _InIt, class _OutIt> inline _OutIt  /* __cilk */ __cdecl 

__cilkfun__Copy_backward_opt(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_OutIt > , __cilk_box<random_access_iterator_tag > , __cilk_box<_Nonscalar_ptr_iterator_tag > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 2668
template<class _InIt, class _OutIt, class _InOutItCat> inline _OutIt 

_Copy_backward_opt(_InIt, _InIt, _OutIt, _InOutItCat, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag); 
#line 2668
template<class _InIt, class _OutIt, class _InOutItCat> inline _OutIt  /* __cilk */ __cdecl 

__cilkfun__Copy_backward_opt(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_OutIt > , __cilk_box<_InOutItCat > , __cilk_box<_Scalar_ptr_iterator_tag > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 2692
template<class _BidIt1, class 
_BidIt2> inline typename _Enable_if< _Is_checked_iterator< _BidIt2> ::_Result, _BidIt2> ::_Result 
copy_backward(_BidIt1, _BidIt1, _BidIt2); 
#line 2692
template<class _BidIt1, class 
_BidIt2> inline typename _Enable_if< _Is_checked_iterator< _BidIt2> ::_Result, _BidIt2> ::_Result  /* __cilk */ __cdecl 
__cilkfun_copy_backward(__cilk_box<_BidIt1 > , __cilk_box<_BidIt1 > , __cilk_box<_BidIt2 > ); 
#line 2700
template<class _BidIt1, class 
_BidIt2> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename _Enable_if< (!_Is_checked_iterator< _BidIt2> ::_Result), _BidIt2> ::_Result 

copy_backward(_BidIt1, _BidIt1, _BidIt2); 
#line 2700
template<class _BidIt1, class 
_BidIt2> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename _Enable_if< (!_Is_checked_iterator< _BidIt2> ::_Result), _BidIt2> ::_Result  /* __cilk */ __cdecl 

__cilkfun_copy_backward(__cilk_box<_BidIt1 > , __cilk_box<_BidIt1 > , __cilk_box<_BidIt2 > ); 
#line 2722
template<class _BidIt1, class _BidIt2, class _InOutItCat, class _MoveCatTy> inline _BidIt2 

_Move_backward_opt(_BidIt1, _BidIt1, _BidIt2, _InOutItCat, _MoveCatTy, _Range_checked_iterator_tag); 
#line 2722
template<class _BidIt1, class _BidIt2, class _InOutItCat, class _MoveCatTy> inline _BidIt2  /* __cilk */ __cdecl 

__cilkfun__Move_backward_opt(__cilk_box<_BidIt1 > , __cilk_box<_BidIt1 > , __cilk_box<_BidIt2 > , __cilk_box<_InOutItCat > , __cilk_box<_MoveCatTy > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 2731
template<class _BidIt1, class _BidIt2, class _InOutItCat> inline _BidIt2 

_Move_backward_opt(_BidIt1, _BidIt1, _BidIt2, _InOutItCat, _Swap_move_tag, _Range_checked_iterator_tag); 
#line 2731
template<class _BidIt1, class _BidIt2, class _InOutItCat> inline _BidIt2  /* __cilk */ __cdecl 

__cilkfun__Move_backward_opt(__cilk_box<_BidIt1 > , __cilk_box<_BidIt1 > , __cilk_box<_BidIt2 > , __cilk_box<_InOutItCat > , __cilk_box<_Swap_move_tag > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 2743
template<class _BidIt1, class _BidIt2> inline _BidIt2 

_Move_backward_opt(_BidIt1, _BidIt1, _BidIt2, random_access_iterator_tag, _Swap_move_tag, _Range_checked_iterator_tag); 
#line 2743
template<class _BidIt1, class _BidIt2> inline _BidIt2  /* __cilk */ __cdecl 

__cilkfun__Move_backward_opt(__cilk_box<_BidIt1 > , __cilk_box<_BidIt1 > , __cilk_box<_BidIt2 > , __cilk_box<random_access_iterator_tag > , __cilk_box<_Swap_move_tag > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 2758
template<class _BidIt1, class _BidIt2> inline typename _Enable_if< _Is_checked_iterator< _BidIt2> ::_Result, _BidIt2> ::_Result 

_Move_backward(_BidIt1, _BidIt1, _BidIt2); 
#line 2758
template<class _BidIt1, class _BidIt2> inline typename _Enable_if< _Is_checked_iterator< _BidIt2> ::_Result, _BidIt2> ::_Result  /* __cilk */ __cdecl 

__cilkfun__Move_backward(__cilk_box<_BidIt1 > , __cilk_box<_BidIt1 > , __cilk_box<_BidIt2 > ); 
#line 2766
template<class _BidIt1, class _BidIt2> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename _Enable_if< (!_Is_checked_iterator< _BidIt2> ::_Result), _BidIt2> ::_Result 


_Move_backward(_BidIt1, _BidIt1, _BidIt2); 
#line 2766
template<class _BidIt1, class _BidIt2> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename _Enable_if< (!_Is_checked_iterator< _BidIt2> ::_Result), _BidIt2> ::_Result  /* __cilk */ __cdecl 


__cilkfun__Move_backward(__cilk_box<_BidIt1 > , __cilk_box<_BidIt1 > , __cilk_box<_BidIt2 > ); 
#line 2788
template<class _InIt1, class _InIt2, class _InItCats> inline pair< _InIt1, _InIt2>  


_Mismatch(_InIt1, _InIt1, _InIt2, _InItCats, _Range_checked_iterator_tag); 
#line 2788
template<class _InIt1, class _InIt2, class _InItCats> inline pair< _InIt1, _InIt2>   /* __cilk */ __cdecl 


__cilkfun__Mismatch(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > , __cilk_box<_InItCats > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 2807
template<class _InIt1, class _InIt2> inline pair< _InIt1, _InIt2>  


_Mismatch(_InIt1, _InIt1, _InIt2, random_access_iterator_tag, _Range_checked_iterator_tag); 
#line 2807
template<class _InIt1, class _InIt2> inline pair< _InIt1, _InIt2>   /* __cilk */ __cdecl 


__cilkfun__Mismatch(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > , __cilk_box<random_access_iterator_tag > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 2825
template<class _InIt1, class _InIt2> inline typename _Enable_if< _Is_checked_iterator< _InIt2> ::_Result, pair< _InIt1, _InIt2> > ::_Result 


mismatch(_InIt1, _InIt1, _InIt2); 
#line 2825
template<class _InIt1, class _InIt2> inline typename _Enable_if< _Is_checked_iterator< _InIt2> ::_Result, pair< _InIt1, _InIt2> > ::_Result  /* __cilk */ __cdecl 


__cilkfun_mismatch(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > ); 
#line 2837
template<class _InIt1, class _InElem2, size_t _Size> inline pair< _InIt1, _InElem2 *>  


mismatch(_InIt1, _InIt1, _InElem2 (&)[_Size]); 
#line 2837
template<class _InIt1, class _InElem2, size_t _Size> inline pair< _InIt1, _InElem2 *>   /* __cilk */ __cdecl 


__cilkfun_mismatch(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InElem2 (&)[_Size] > ); 
#line 2847
template<class _InIt1, class _InIt2> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename _Enable_if< (!_Is_checked_iterator< _InIt2> ::_Result), pair< _InIt1, _InIt2> > ::_Result 



mismatch(_InIt1, _InIt1, _InIt2); 
#line 2847
template<class _InIt1, class _InIt2> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename _Enable_if< (!_Is_checked_iterator< _InIt2> ::_Result), pair< _InIt1, _InIt2> > ::_Result  /* __cilk */ __cdecl 



__cilkfun_mismatch(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > ); 
#line 2874
template<class _InIt1, class _InIt2, class _Pr, class _InItCats> inline pair< _InIt1, _InIt2>  


_Mismatch(_InIt1, _InIt1, _InIt2, _Pr, _InItCats, _Range_checked_iterator_tag); 
#line 2874
template<class _InIt1, class _InIt2, class _Pr, class _InItCats> inline pair< _InIt1, _InIt2>   /* __cilk */ __cdecl 


__cilkfun__Mismatch(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > , __cilk_box<_Pr > , __cilk_box<_InItCats > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 2894
template<class _InIt1, class _InIt2, class _Pr> inline pair< _InIt1, _InIt2>  


_Mismatch(_InIt1, _InIt1, _InIt2, _Pr, random_access_iterator_tag, _Range_checked_iterator_tag); 
#line 2894
template<class _InIt1, class _InIt2, class _Pr> inline pair< _InIt1, _InIt2>   /* __cilk */ __cdecl 


__cilkfun__Mismatch(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > , __cilk_box<_Pr > , __cilk_box<random_access_iterator_tag > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 2912
template<class _InIt1, class _InIt2, class _Pr> inline typename _Enable_if< _Is_checked_iterator< _InIt2> ::_Result, pair< _InIt1, _InIt2> > ::_Result 


mismatch(_InIt1, _InIt1, _InIt2, _Pr); 
#line 2912
template<class _InIt1, class _InIt2, class _Pr> inline typename _Enable_if< _Is_checked_iterator< _InIt2> ::_Result, pair< _InIt1, _InIt2> > ::_Result  /* __cilk */ __cdecl 


__cilkfun_mismatch(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > , __cilk_box<_Pr > ); 
#line 2924
template<class _InIt1, class _InElem2, class _Pr, size_t _Size> inline pair< _InIt1, _InElem2 *>  


mismatch(_InIt1, _InIt1, _InElem2 (&)[_Size], _Pr); 
#line 2924
template<class _InIt1, class _InElem2, class _Pr, size_t _Size> inline pair< _InIt1, _InElem2 *>   /* __cilk */ __cdecl 


__cilkfun_mismatch(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InElem2 (&)[_Size] > , __cilk_box<_Pr > ); 
#line 2934
template<class _InIt1, class _InIt2, class _Pr> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename _Enable_if< (!_Is_checked_iterator< _InIt2> ::_Result), pair< _InIt1, _InIt2> > ::_Result 



mismatch(_InIt1, _InIt1, _InIt2, _Pr); 
#line 2934
template<class _InIt1, class _InIt2, class _Pr> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename _Enable_if< (!_Is_checked_iterator< _InIt2> ::_Result), pair< _InIt1, _InIt2> > ::_Result  /* __cilk */ __cdecl 



__cilkfun_mismatch(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > , __cilk_box<_Pr > ); 
#line 2961
template<class _InIt1, class _InIt2, class _InItCats> inline bool 

_Equal(_InIt1, _InIt1, _InIt2, _InItCats, _Range_checked_iterator_tag); 
#line 2961
template<class _InIt1, class _InIt2, class _InItCats> inline bool  /* __cilk */ __cdecl 

__cilkfun__Equal(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > , __cilk_box<_InItCats > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 2972
inline bool _Equal(const char *_First1, const char *
_Last1, const char *_First2, random_access_iterator_tag __T13959900, _Range_checked_iterator_tag __T13959992) 

{ 
#line 2982
return ::memcmp(_First1, _First2, _Last1 - _First1) == 0; 
} 

inline bool _Equal(const signed char *_First1, const signed char *
_Last1, const signed char *_First2, random_access_iterator_tag __T13961196, _Range_checked_iterator_tag __T13961288) 

{ 
#line 2995
return ::memcmp(_First1, _First2, _Last1 - _First1) == 0; 
} 

inline bool _Equal(const unsigned char *_First1, const unsigned char *
_Last1, const unsigned char *_First2, random_access_iterator_tag __T13962492, _Range_checked_iterator_tag __T13962584) 

{ 
#line 3008
return ::memcmp(_First1, _First2, _Last1 - _First1) == 0; 
} 


template<class _InIt1, class _InIt2> inline bool 

_Equal(_InIt1, _InIt1, _InIt2, random_access_iterator_tag, _Range_checked_iterator_tag); 
#line 3012
template<class _InIt1, class _InIt2> inline bool  /* __cilk */ __cdecl 

__cilkfun__Equal(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > , __cilk_box<random_access_iterator_tag > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 3026
template<class _InIt1, class _InIt2> inline typename _Enable_if< _Is_checked_iterator< _InIt2> ::_Result, bool> ::_Result 

equal(_InIt1, _InIt1, _InIt2); 
#line 3026
template<class _InIt1, class _InIt2> inline typename _Enable_if< _Is_checked_iterator< _InIt2> ::_Result, bool> ::_Result  /* __cilk */ __cdecl 

__cilkfun_equal(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > ); 
#line 3034
template<class _InIt1, class _InElem2, size_t _Size> inline bool 

equal(_InIt1, _InIt1, _InElem2 (&)[_Size]); 
#line 3034
template<class _InIt1, class _InElem2, size_t _Size> inline bool  /* __cilk */ __cdecl 

__cilkfun_equal(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InElem2 (&)[_Size] > ); 
#line 3042
template<class _InIt1, class _InIt2> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename _Enable_if< (!_Is_checked_iterator< _InIt2> ::_Result), bool> ::_Result 


equal(_InIt1, _InIt1, _InIt2); 
#line 3042
template<class _InIt1, class _InIt2> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename _Enable_if< (!_Is_checked_iterator< _InIt2> ::_Result), bool> ::_Result  /* __cilk */ __cdecl 


__cilkfun_equal(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > ); 
#line 3064
template<class _InIt1, class _InIt2, class _Pr, class _InItCats> inline bool 

_Equal(_InIt1, _InIt1, _InIt2, _Pr, _InItCats, _Range_checked_iterator_tag); 
#line 3064
template<class _InIt1, class _InIt2, class _Pr, class _InItCats> inline bool  /* __cilk */ __cdecl 

__cilkfun__Equal(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > , __cilk_box<_Pr > , __cilk_box<_InItCats > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 3076
template<class _InIt1, class _InIt2, class _Pr> inline bool 

_Equal(_InIt1, _InIt1, _InIt2, _Pr, random_access_iterator_tag, _Range_checked_iterator_tag); 
#line 3076
template<class _InIt1, class _InIt2, class _Pr> inline bool  /* __cilk */ __cdecl 

__cilkfun__Equal(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > , __cilk_box<_Pr > , __cilk_box<random_access_iterator_tag > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 3090
template<class _InIt1, class _InIt2, class _Pr> inline typename _Enable_if< _Is_checked_iterator< _InIt2> ::_Result, bool> ::_Result 

equal(_InIt1, _InIt1, _InIt2, _Pr); 
#line 3090
template<class _InIt1, class _InIt2, class _Pr> inline typename _Enable_if< _Is_checked_iterator< _InIt2> ::_Result, bool> ::_Result  /* __cilk */ __cdecl 

__cilkfun_equal(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > , __cilk_box<_Pr > ); 
#line 3098
template<class _InIt1, class _InElem2, class _Pr, size_t _Size> inline bool 

equal(_InIt1, _InIt1, _InElem2 (&)[_Size], _Pr); 
#line 3098
template<class _InIt1, class _InElem2, class _Pr, size_t _Size> inline bool  /* __cilk */ __cdecl 

__cilkfun_equal(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InElem2 (&)[_Size] > , __cilk_box<_Pr > ); 
#line 3106
template<class _InIt1, class _InIt2, class _Pr> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename _Enable_if< (!_Is_checked_iterator< _InIt2> ::_Result), bool> ::_Result 


equal(_InIt1, _InIt1, _InIt2, _Pr); 
#line 3106
template<class _InIt1, class _InIt2, class _Pr> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename _Enable_if< (!_Is_checked_iterator< _InIt2> ::_Result), bool> ::_Result  /* __cilk */ __cdecl 


__cilkfun_equal(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > , __cilk_box<_Pr > ); 
#line 3128
template<class _FwdIt, class _Ty> inline void 
_Fill(_FwdIt, _FwdIt, const _Ty &); 
#line 3128
template<class _FwdIt, class _Ty> inline void  /* __cilk */ __cdecl 
__cilkfun__Fill(__cilk_box<_FwdIt > , __cilk_box<_FwdIt > , __cilk_box<const _Ty & > ); 
#line 3136
inline void _Fill(char *_First, char *
_Last, int _Val) 
{ 
; 
::memset(_First, _Val, _Last - _First); 
} 

inline void _Fill(signed char *_First, signed char *
_Last, int _Val) 
{ 
; 
::memset(_First, _Val, _Last - _First); 
} 

inline void _Fill(unsigned char *
_First, unsigned char *
_Last, int _Val) 
{ 
; 
::memset(_First, _Val, _Last - _First); 
} 

template<class _FwdIt, class _Ty> inline void 
fill(_FwdIt, _FwdIt, const _Ty &); 
#line 3158
template<class _FwdIt, class _Ty> inline void  /* __cilk */ __cdecl 
__cilkfun_fill(__cilk_box<_FwdIt > , __cilk_box<_FwdIt > , __cilk_box<const _Ty & > ); 
#line 3165
template<class _OutIt, class 
_Diff, class 
_Ty> inline void 
_Fill_n(_OutIt, _Diff, const _Ty &, _Range_checked_iterator_tag); 
#line 3165
template<class _OutIt, class 
_Diff, class 
_Ty> inline void  /* __cilk */ __cdecl 
__cilkfun__Fill_n(__cilk_box<_OutIt > , __cilk_box<_Diff > , __cilk_box<const _Ty & > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 3175
inline void _Fill_n(char *_First, size_t 
_Count, int _Val, _Range_checked_iterator_tag __T14090968) 
{ 
#line 3184
::memset(_First, _Val, _Count); 
} 

inline void _Fill_n(signed char *_First, size_t 
_Count, int _Val, _Range_checked_iterator_tag __T14092016) 
{ 
#line 3196
::memset(_First, _Val, _Count); 
} 

inline void _Fill_n(unsigned char *_First, size_t 
_Count, int _Val, _Range_checked_iterator_tag __T14093064) 
{ 
#line 3208
::memset(_First, _Val, _Count); 
} 

template<class _OutIt, class _Diff, class _Ty, class _OutCat> inline void 

_Fill_n(_OutIt, _Diff, const _Ty &, _OutCat, _Range_checked_iterator_tag); 
#line 3211
template<class _OutIt, class _Diff, class _Ty, class _OutCat> inline void  /* __cilk */ __cdecl 

__cilkfun__Fill_n(__cilk_box<_OutIt > , __cilk_box<_Diff > , __cilk_box<const _Ty & > , __cilk_box<_OutCat > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 3220
template<class _OutIt, class _Diff, class _Ty> inline void 

_Fill_n(_OutIt, _Diff, const _Ty &, random_access_iterator_tag, _Range_checked_iterator_tag); 
#line 3220
template<class _OutIt, class _Diff, class _Ty> inline void  /* __cilk */ __cdecl 

__cilkfun__Fill_n(__cilk_box<_OutIt > , __cilk_box<_Diff > , __cilk_box<const _Ty & > , __cilk_box<random_access_iterator_tag > , __cilk_box<_Range_checked_iterator_tag > ); 
#line 3234
template<class _OutIt, class 
_Diff, class 
_Ty> inline typename _Enable_if< _Is_checked_iterator< _OutIt> ::_Result, void> ::_Result 

fill_n(_OutIt, _Diff, const _Ty &); 
#line 3234
template<class _OutIt, class 
_Diff, class 
_Ty> inline typename _Enable_if< _Is_checked_iterator< _OutIt> ::_Result, void> ::_Result  /* __cilk */ __cdecl 

__cilkfun_fill_n(__cilk_box<_OutIt > , __cilk_box<_Diff > , __cilk_box<const _Ty & > ); 




template<class _OutElem, class 
_Diff, class 
_Ty, size_t _Size> inline void 

fill_n(_OutElem (&)[_Size], _Diff, const _Ty &); 
#line 3243
template<class _OutElem, class 
_Diff, class 
_Ty, size_t _Size> inline void  /* __cilk */ __cdecl 

__cilkfun_fill_n(__cilk_box<_OutElem (&)[_Size] > , __cilk_box<_Diff > , __cilk_box<const _Ty & > ); 




template<class _OutIt, class 
_Diff, class 
_Ty> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename _Enable_if< (!_Is_checked_iterator< _OutIt> ::_Result), void> ::_Result 


fill_n(_OutIt, _Diff, const _Ty &); 
#line 3252
template<class _OutIt, class 
_Diff, class 
_Ty> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename _Enable_if< (!_Is_checked_iterator< _OutIt> ::_Result), void> ::_Result  /* __cilk */ __cdecl 


__cilkfun_fill_n(__cilk_box<_OutIt > , __cilk_box<_Diff > , __cilk_box<const _Ty & > ); 
#line 3275
template<class _InIt1, class _InIt2> inline bool 
_Lexicographical_compare(_InIt1, _InIt1, _InIt2, _InIt2); 
#line 3275
template<class _InIt1, class _InIt2> inline bool  /* __cilk */ __cdecl 
__cilkfun__Lexicographical_compare(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > , __cilk_box<_InIt2 > ); 
#line 3289
template<class _InIt1, class _InIt2> inline bool 
lexicographical_compare(_InIt1, _InIt1, _InIt2, _InIt2); 
#line 3289
template<class _InIt1, class _InIt2> inline bool  /* __cilk */ __cdecl 
__cilkfun_lexicographical_compare(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > , __cilk_box<_InIt2 > ); 
#line 3297
inline bool lexicographical_compare(const unsigned char *
_First1, const unsigned char *_Last1, const unsigned char *
_First2, const unsigned char *_Last2) 
{ 
; 
; 
auto ptrdiff_t _Num1 = (_Last1 - _First1); 
auto ptrdiff_t _Num2 = (_Last2 - _First2); 
auto int _Ans = ::memcmp(_First1, _First2, (_Num1 < _Num2) ? _Num1 : _Num2); 
return (_Ans < 0) || ((_Ans == 0) && (_Num1 < _Num2)); 
} 
#line 3324
template<class _InIt1, class 
_InIt2, class 
_Pr> inline bool 
_Lexicographical_compare(_InIt1, _InIt1, _InIt2, _InIt2, _Pr); 
#line 3324
template<class _InIt1, class 
_InIt2, class 
_Pr> inline bool  /* __cilk */ __cdecl 
__cilkfun__Lexicographical_compare(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > , __cilk_box<_InIt2 > , __cilk_box<_Pr > ); 
#line 3341
template<class _InIt1, class _InIt2, class _Pr> inline bool 
lexicographical_compare(_InIt1, _InIt1, _InIt2, _InIt2, _Pr); 
#line 3341
template<class _InIt1, class _InIt2, class _Pr> inline bool  /* __cilk */ __cdecl 
__cilkfun_lexicographical_compare(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > , __cilk_box<_InIt2 > , __cilk_box<_Pr > ); 
#line 3355
template<class _Ty> inline const _Ty &
max(const _Ty &, const _Ty &); 
#line 3355
template<class _Ty> inline const _Ty & /* __cilk */ __cdecl 
__cilkfun_max(__cilk_box<const _Ty & > , __cilk_box<const _Ty & > ); 
#line 3362
template<class _Ty, class 
_Pr> inline const _Ty &
max(const _Ty &, const _Ty &, _Pr); 
#line 3362
template<class _Ty, class 
_Pr> inline const _Ty & /* __cilk */ __cdecl 
__cilkfun_max(__cilk_box<const _Ty & > , __cilk_box<const _Ty & > , __cilk_box<_Pr > ); 
#line 3370
template<class _Ty> inline const _Ty &
min(const _Ty &, const _Ty &); 
#line 3370
template<class _Ty> inline const _Ty & /* __cilk */ __cdecl 
__cilkfun_min(__cilk_box<const _Ty & > , __cilk_box<const _Ty & > ); 
#line 3377
template<class _Ty, class 
_Pr> inline const _Ty &
min(const _Ty &, const _Ty &, _Pr); 
#line 3377
template<class _Ty, class 
_Pr> inline const _Ty & /* __cilk */ __cdecl 
__cilkfun_min(__cilk_box<const _Ty & > , __cilk_box<const _Ty & > , __cilk_box<_Pr > ); 




}

namespace stdext { 


template<class _Iterator> 
class checked_array_iterator : public std::iterator< typename std::iterator_traits< _Iterator> ::iterator_category, typename std::iterator_traits< _Iterator> ::value_type, typename std::iterator_traits< _Iterator> ::difference_type, typename std::iterator_traits< _Iterator> ::pointer, typename std::iterator_traits< _Iterator> ::reference>  { friend struct __cilk_s;__CILK_METADATA(checked_array_iterator, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;
#line 3399
typedef stdext::checked_array_iterator< _Iterator>  _Myt; 
typedef typename std::iterator_traits< _Iterator> ::difference_type difference_type; 
typedef typename std::iterator_traits< _Iterator> ::pointer pointer; 
typedef typename std::iterator_traits< _Iterator> ::reference reference; 

typedef std::_Range_checked_iterator_tag _Checked_iterator_category; 
typedef _Iterator _Inner_type; 

typedef _Iterator _Checked_iterator_base_type; 

inline _Checked_iterator_base_type _Checked_iterator_base() const; inline _Checked_iterator_base_type  /* __cilk */ __thiscall __cilkfun__Checked_iterator_base() const; 




inline void _Checked_iterator_assign_from_base(_Checked_iterator_base_type); inline void  /* __cilk */ __thiscall __cilkfun__Checked_iterator_assign_from_base(__cilk_box<_Iterator > ); 
#line 3421
inline checked_array_iterator(); 




inline checked_array_iterator(_Iterator, size_t, size_t = (0)); inline  /* __cilk */ __thiscall checked_array_iterator(__cilk_box<_Iterator > , __cilk_box<unsigned > , __cilk_box<unsigned >  = (__cilk_box<unsigned >(0))); 
#line 3434
inline _Iterator base() const; inline _Iterator  /* __cilk */ __thiscall __cilkfun_base() const; 




inline size_t __Size() const; inline size_t  /* __cilk */ __thiscall __cilkfun___Size() const; 




inline bool operator==(const _Myt &) const; inline bool  /* __cilk */ __thiscall __cilk_op_eq(__cilk_box<const _Myt & > ) const; 
#line 3450
inline bool operator!=(const _Myt &) const; inline bool  /* __cilk */ __thiscall __cilk_op_ne(__cilk_box<const _Myt & > ) const; 




inline bool operator<(const _Myt &) const; inline bool  /* __cilk */ __thiscall __cilk_op_lt(__cilk_box<const _Myt & > ) const; 
#line 3461
inline bool operator>(const _Myt &) const; inline bool  /* __cilk */ __thiscall __cilk_op_gt(__cilk_box<const _Myt & > ) const; 




inline bool operator<=(const _Myt &) const; inline bool  /* __cilk */ __thiscall __cilk_op_le(__cilk_box<const _Myt & > ) const; 




inline bool operator>=(const _Myt &) const; inline bool  /* __cilk */ __thiscall __cilk_op_ge(__cilk_box<const _Myt & > ) const; 




inline reference operator*() const; 
#line 3482
inline pointer operator->() const; 




inline stdext::checked_array_iterator< _Iterator>  &operator++(); 
#line 3494
inline _Myt operator++(int); 
#line 3501
inline _Myt &operator--(); 
#line 3508
inline _Myt operator--(int); 
#line 3517
inline _Myt &operator+=(difference_type); inline _Myt & /* __cilk */ __thiscall __cilk_op_plus_assign(__cilk_box<typename std::iterator_traits< _Iterator> ::difference_type > ); 
#line 3524
inline _Myt operator+(difference_type) const; inline _Myt  /* __cilk */ __thiscall __cilk_op_plus(__cilk_box<typename std::iterator_traits< _Iterator> ::difference_type > ) const; 
#line 3530
inline _Myt &operator-=(difference_type); inline _Myt & /* __cilk */ __thiscall __cilk_op_minus_assign(__cilk_box<typename std::iterator_traits< _Iterator> ::difference_type > ); 




inline _Myt operator-(difference_type) const; inline _Myt  /* __cilk */ __thiscall __cilk_op_minus(__cilk_box<typename std::iterator_traits< _Iterator> ::difference_type > ) const; 
#line 3541
inline difference_type operator-(const stdext::checked_array_iterator< _Iterator>  &) const; inline difference_type  /* __cilk */ __thiscall __cilk_op_minus(__cilk_box<const stdext::checked_array_iterator< _Iterator>  & > ) const; 
#line 3547
inline reference operator[](difference_type) const; inline reference  /* __cilk */ __thiscall __cilk_op_subscript(__cilk_box<typename std::iterator_traits< _Iterator> ::difference_type > ) const; 
#line 3554
protected: inline void _Xran() const; inline void  /* __cilk */ __thiscall __cilkfun__Xran() const; 




inline void _Xinvarg() const; inline void  /* __cilk */ __thiscall __cilkfun__Xinvarg() const; 




_Iterator _Mycont; 
size_t _Current; 
size_t _Size; 
}; 

template<class _Iter> extern checked_array_iterator< _Iter>  
make_checked_array_iterator(_Iter, size_t); 
#line 3569
template<class _Iter> extern checked_array_iterator< _Iter>   /* __cilk */ __cdecl 
__cilkfun_make_checked_array_iterator(__cilk_box<_Iter > , __cilk_box<unsigned > ); 




template<class _InIt, class 
_OutIt> inline _OutIt 
unchecked_copy(_InIt, _InIt, _OutIt); 
#line 3575
template<class _InIt, class 
_OutIt> inline _OutIt  /* __cilk */ __cdecl 
__cilkfun_unchecked_copy(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_OutIt > ); 
#line 3583
template<class _InIt, class _OutIt> inline typename std::_Enable_if< std::_Is_checked_iterator< _OutIt> ::_Result, _OutIt> ::_Result 

checked_copy(_InIt, _InIt, _OutIt); 
#line 3583
template<class _InIt, class _OutIt> inline typename std::_Enable_if< std::_Is_checked_iterator< _OutIt> ::_Result, _OutIt> ::_Result  /* __cilk */ __cdecl 

__cilkfun_checked_copy(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_OutIt > ); 
#line 3591
template<class _InIt, class _OutElem, size_t _Size> inline _OutElem *

checked_copy(_InIt, _InIt, _OutElem (&)[_Size]); 
#line 3591
template<class _InIt, class _OutElem, size_t _Size> inline _OutElem * /* __cilk */ __cdecl 

__cilkfun_checked_copy(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_OutElem (&)[_Size] > ); 




template<class _InIt, class _OutIt> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename std::_Enable_if< (!std::_Is_checked_iterator< _OutIt> ::_Result), _OutIt> ::_Result 


checked_copy(_InIt, _InIt, _OutIt); 
#line 3598
template<class _InIt, class _OutIt> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename std::_Enable_if< (!std::_Is_checked_iterator< _OutIt> ::_Result), _OutIt> ::_Result  /* __cilk */ __cdecl 


__cilkfun_checked_copy(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_OutIt > ); 
#line 3607
template<class _BidIt1, class 
_BidIt2> inline _BidIt2 
unchecked_copy_backward(_BidIt1, _BidIt1, _BidIt2); 
#line 3607
template<class _BidIt1, class 
_BidIt2> inline _BidIt2  /* __cilk */ __cdecl 
__cilkfun_unchecked_copy_backward(__cilk_box<_BidIt1 > , __cilk_box<_BidIt1 > , __cilk_box<_BidIt2 > ); 
#line 3615
template<class _BidIt1, class 
_BidIt2> inline typename std::_Enable_if< std::_Is_checked_iterator< _BidIt2> ::_Result, _BidIt2> ::_Result 
checked_copy_backward(_BidIt1, _BidIt1, _BidIt2); 
#line 3615
template<class _BidIt1, class 
_BidIt2> inline typename std::_Enable_if< std::_Is_checked_iterator< _BidIt2> ::_Result, _BidIt2> ::_Result  /* __cilk */ __cdecl 
__cilkfun_checked_copy_backward(__cilk_box<_BidIt1 > , __cilk_box<_BidIt1 > , __cilk_box<_BidIt2 > ); 
#line 3623
template<class _BidIt1, class 
_BidIt2> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename std::_Enable_if< (!std::_Is_checked_iterator< _BidIt2> ::_Result), _BidIt2> ::_Result 

checked_copy_backward(_BidIt1, _BidIt1, _BidIt2); 
#line 3623
template<class _BidIt1, class 
_BidIt2> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename std::_Enable_if< (!std::_Is_checked_iterator< _BidIt2> ::_Result), _BidIt2> ::_Result  /* __cilk */ __cdecl 

__cilkfun_checked_copy_backward(__cilk_box<_BidIt1 > , __cilk_box<_BidIt1 > , __cilk_box<_BidIt2 > ); 
#line 3632
template<class _InIt, class 
_OutIt> inline _OutIt 
_Unchecked_move(_InIt, _InIt, _OutIt); 
#line 3632
template<class _InIt, class 
_OutIt> inline _OutIt  /* __cilk */ __cdecl 
__cilkfun__Unchecked_move(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_OutIt > ); 
#line 3640
template<class _InIt, class _OutIt> inline typename std::_Enable_if< std::_Is_checked_iterator< _OutIt> ::_Result, _OutIt> ::_Result 

_Checked_move(_InIt, _InIt, _OutIt); 
#line 3640
template<class _InIt, class _OutIt> inline typename std::_Enable_if< std::_Is_checked_iterator< _OutIt> ::_Result, _OutIt> ::_Result  /* __cilk */ __cdecl 

__cilkfun__Checked_move(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_OutIt > ); 
#line 3648
template<class _InIt, class _OutElem, size_t _Size> inline _OutElem *

_Checked_move(_InIt, _InIt, _OutElem (&)[_Size]); 
#line 3648
template<class _InIt, class _OutElem, size_t _Size> inline _OutElem * /* __cilk */ __cdecl 

__cilkfun__Checked_move(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_OutElem (&)[_Size] > ); 
#line 3656
template<class _InIt, class _OutIt> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename std::_Enable_if< (!std::_Is_checked_iterator< _OutIt> ::_Result), _OutIt> ::_Result 


_Checked_move(_InIt, _InIt, _OutIt); 
#line 3656
template<class _InIt, class _OutIt> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename std::_Enable_if< (!std::_Is_checked_iterator< _OutIt> ::_Result), _OutIt> ::_Result  /* __cilk */ __cdecl 


__cilkfun__Checked_move(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<_OutIt > ); 
#line 3665
template<class _BidIt1, class 
_BidIt2> inline _BidIt2 
_Unchecked_move_backward(_BidIt1, _BidIt1, _BidIt2); 
#line 3665
template<class _BidIt1, class 
_BidIt2> inline _BidIt2  /* __cilk */ __cdecl 
__cilkfun__Unchecked_move_backward(__cilk_box<_BidIt1 > , __cilk_box<_BidIt1 > , __cilk_box<_BidIt2 > ); 
#line 3673
template<class _BidIt1, class _BidIt2> inline typename std::_Enable_if< std::_Is_checked_iterator< _BidIt2> ::_Result, _BidIt2> ::_Result 

_Checked_move_backward(_BidIt1, _BidIt1, _BidIt2); 
#line 3673
template<class _BidIt1, class _BidIt2> inline typename std::_Enable_if< std::_Is_checked_iterator< _BidIt2> ::_Result, _BidIt2> ::_Result  /* __cilk */ __cdecl 

__cilkfun__Checked_move_backward(__cilk_box<_BidIt1 > , __cilk_box<_BidIt1 > , __cilk_box<_BidIt2 > ); 
#line 3681
template<class _BidIt1, class _BidIt2> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename std::_Enable_if< (!std::_Is_checked_iterator< _BidIt2> ::_Result), _BidIt2> ::_Result 


_Checked_move_backward(_BidIt1, _BidIt1, _BidIt2); 
#line 3681
template<class _BidIt1, class _BidIt2> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename std::_Enable_if< (!std::_Is_checked_iterator< _BidIt2> ::_Result), _BidIt2> ::_Result  /* __cilk */ __cdecl 


__cilkfun__Checked_move_backward(__cilk_box<_BidIt1 > , __cilk_box<_BidIt1 > , __cilk_box<_BidIt2 > ); 
#line 3690
template<class _OutIt, class 
_Diff, class 
_Ty> inline void 
unchecked_fill_n(_OutIt, _Diff, const _Ty &); 
#line 3690
template<class _OutIt, class 
_Diff, class 
_Ty> inline void  /* __cilk */ __cdecl 
__cilkfun_unchecked_fill_n(__cilk_box<_OutIt > , __cilk_box<_Diff > , __cilk_box<const _Ty & > ); 




template<class _OutIt, class 
_Diff, class 
_Ty> inline typename std::_Enable_if< std::_Is_checked_iterator< _OutIt> ::_Result, void> ::_Result 

checked_fill_n(_OutIt, _Diff, const _Ty &); 
#line 3698
template<class _OutIt, class 
_Diff, class 
_Ty> inline typename std::_Enable_if< std::_Is_checked_iterator< _OutIt> ::_Result, void> ::_Result  /* __cilk */ __cdecl 

__cilkfun_checked_fill_n(__cilk_box<_OutIt > , __cilk_box<_Diff > , __cilk_box<const _Ty & > ); 




template<class _OutElem, class 
_Diff, class 
_Ty, size_t _Size> inline void 

checked_fill_n(_OutElem (&)[_Size], _Diff, const _Ty &); 
#line 3707
template<class _OutElem, class 
_Diff, class 
_Ty, size_t _Size> inline void  /* __cilk */ __cdecl 

__cilkfun_checked_fill_n(__cilk_box<_OutElem (&)[_Size] > , __cilk_box<_Diff > , __cilk_box<const _Ty & > ); 




template<class _OutIt, class 
_Diff, class 
_Ty> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename std::_Enable_if< (!std::_Is_checked_iterator< _OutIt> ::_Result), void> ::_Result 


checked_fill_n(_OutIt, _Diff, const _Ty &); 
#line 3716
template<class _OutIt, class 
_Diff, class 
_Ty> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename std::_Enable_if< (!std::_Is_checked_iterator< _OutIt> ::_Result), void> ::_Result  /* __cilk */ __cdecl 


__cilkfun_checked_fill_n(__cilk_box<_OutIt > , __cilk_box<_Diff > , __cilk_box<const _Ty & > ); 




template<class _InIt1, class _InIt2> inline std::pair< _InIt1, _InIt2>  


unchecked_mismatch(_InIt1, _InIt1, _InIt2); 
#line 3726
template<class _InIt1, class _InIt2> inline std::pair< _InIt1, _InIt2>   /* __cilk */ __cdecl 


__cilkfun_unchecked_mismatch(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > ); 
#line 3743
template<class _InIt1, class _InIt2> inline typename std::_Enable_if< std::_Is_checked_iterator< _InIt2> ::_Result, std::pair< _InIt1, _InIt2> > ::_Result 


checked_mismatch(_InIt1, _InIt1, _InIt2); 
#line 3743
template<class _InIt1, class _InIt2> inline typename std::_Enable_if< std::_Is_checked_iterator< _InIt2> ::_Result, std::pair< _InIt1, _InIt2> > ::_Result  /* __cilk */ __cdecl 


__cilkfun_checked_mismatch(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > ); 
#line 3755
template<class _InIt1, class _InElem2, size_t _Size> inline std::pair< _InIt1, _InElem2 *>  


checked_mismatch(_InIt1, _InIt1, _InElem2 (&)[_Size]); 
#line 3755
template<class _InIt1, class _InElem2, size_t _Size> inline std::pair< _InIt1, _InElem2 *>   /* __cilk */ __cdecl 


__cilkfun_checked_mismatch(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InElem2 (&)[_Size] > ); 
#line 3765
template<class _InIt1, class _InIt2> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename std::_Enable_if< (!std::_Is_checked_iterator< _InIt2> ::_Result), std::pair< _InIt1, _InIt2> > ::_Result 



checked_mismatch(_InIt1, _InIt1, _InIt2); 
#line 3765
template<class _InIt1, class _InIt2> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename std::_Enable_if< (!std::_Is_checked_iterator< _InIt2> ::_Result), std::pair< _InIt1, _InIt2> > ::_Result  /* __cilk */ __cdecl 



__cilkfun_checked_mismatch(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > ); 
#line 3778
template<class _InIt1, class _InIt2, class _Pr> inline std::pair< _InIt1, _InIt2>  


unchecked_mismatch(_InIt1, _InIt1, _InIt2, _Pr); 
#line 3778
template<class _InIt1, class _InIt2, class _Pr> inline std::pair< _InIt1, _InIt2>   /* __cilk */ __cdecl 


__cilkfun_unchecked_mismatch(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > , __cilk_box<_Pr > ); 
#line 3795
template<class _InIt1, class _InIt2, class _Pr> inline typename std::_Enable_if< std::_Is_checked_iterator< _InIt2> ::_Result, std::pair< _InIt1, _InIt2> > ::_Result 


checked_mismatch(_InIt1, _InIt1, _InIt2, _Pr); 
#line 3795
template<class _InIt1, class _InIt2, class _Pr> inline typename std::_Enable_if< std::_Is_checked_iterator< _InIt2> ::_Result, std::pair< _InIt1, _InIt2> > ::_Result  /* __cilk */ __cdecl 


__cilkfun_checked_mismatch(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > , __cilk_box<_Pr > ); 
#line 3807
template<class _InIt1, class _InElem2, class _Pr, size_t _Size> inline std::pair< _InIt1, _InElem2 *>  


checked_mismatch(_InIt1, _InIt1, _InElem2 (&)[_Size], _Pr); 
#line 3807
template<class _InIt1, class _InElem2, class _Pr, size_t _Size> inline std::pair< _InIt1, _InElem2 *>   /* __cilk */ __cdecl 


__cilkfun_checked_mismatch(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InElem2 (&)[_Size] > , __cilk_box<_Pr > ); 
#line 3817
template<class _InIt1, class _InIt2, class _Pr> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename std::_Enable_if< (!std::_Is_checked_iterator< _InIt2> ::_Result), std::pair< _InIt1, _InIt2> > ::_Result 



checked_mismatch(_InIt1, _InIt1, _InIt2, _Pr); 
#line 3817
template<class _InIt1, class _InIt2, class _Pr> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename std::_Enable_if< (!std::_Is_checked_iterator< _InIt2> ::_Result), std::pair< _InIt1, _InIt2> > ::_Result  /* __cilk */ __cdecl 



__cilkfun_checked_mismatch(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > , __cilk_box<_Pr > ); 
#line 3830
template<class _InIt1, class _InIt2> inline bool 

unchecked_equal(_InIt1, _InIt1, _InIt2); 
#line 3830
template<class _InIt1, class _InIt2> inline bool  /* __cilk */ __cdecl 

__cilkfun_unchecked_equal(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > ); 
#line 3838
template<class _InIt1, class _InIt2> inline typename std::_Enable_if< std::_Is_checked_iterator< _InIt2> ::_Result, bool> ::_Result 

checked_equal(_InIt1, _InIt1, _InIt2); 
#line 3838
template<class _InIt1, class _InIt2> inline typename std::_Enable_if< std::_Is_checked_iterator< _InIt2> ::_Result, bool> ::_Result  /* __cilk */ __cdecl 

__cilkfun_checked_equal(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > ); 
#line 3846
template<class _InIt1, class _InElem2, size_t _Size> inline bool 

checked_equal(_InIt1, _InIt1, _InElem2 (&)[_Size]); 
#line 3846
template<class _InIt1, class _InElem2, size_t _Size> inline bool  /* __cilk */ __cdecl 

__cilkfun_checked_equal(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InElem2 (&)[_Size] > ); 
#line 3854
template<class _InIt1, class _InIt2> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename std::_Enable_if< (!std::_Is_checked_iterator< _InIt2> ::_Result), bool> ::_Result 


checked_equal(_InIt1, _InIt1, _InIt2); 
#line 3854
template<class _InIt1, class _InIt2> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename std::_Enable_if< (!std::_Is_checked_iterator< _InIt2> ::_Result), bool> ::_Result  /* __cilk */ __cdecl 


__cilkfun_checked_equal(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > ); 
#line 3863
template<class _InIt1, class _InIt2, class _Pr> inline bool 

unchecked_equal(_InIt1, _InIt1, _InIt2, _Pr); 
#line 3863
template<class _InIt1, class _InIt2, class _Pr> inline bool  /* __cilk */ __cdecl 

__cilkfun_unchecked_equal(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > , __cilk_box<_Pr > ); 
#line 3871
template<class _InIt1, class _InIt2, class _Pr> inline typename std::_Enable_if< std::_Is_checked_iterator< _InIt2> ::_Result, bool> ::_Result 

checked_equal(_InIt1, _InIt1, _InIt2, _Pr); 
#line 3871
template<class _InIt1, class _InIt2, class _Pr> inline typename std::_Enable_if< std::_Is_checked_iterator< _InIt2> ::_Result, bool> ::_Result  /* __cilk */ __cdecl 

__cilkfun_checked_equal(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > , __cilk_box<_Pr > ); 
#line 3879
template<class _InIt1, class _InElem2, class _Pr, size_t _Size> inline bool 

checked_equal(_InIt1, _InIt1, _InElem2 (&)[_Size], _Pr); 
#line 3879
template<class _InIt1, class _InElem2, class _Pr, size_t _Size> inline bool  /* __cilk */ __cdecl 

__cilkfun_checked_equal(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InElem2 (&)[_Size] > , __cilk_box<_Pr > ); 
#line 3887
template<class _InIt1, class _InIt2, class _Pr> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename std::_Enable_if< (!std::_Is_checked_iterator< _InIt2> ::_Result), bool> ::_Result 


checked_equal(_InIt1, _InIt1, _InIt2, _Pr); 
#line 3887
template<class _InIt1, class _InIt2, class _Pr> inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) typename std::_Enable_if< (!std::_Is_checked_iterator< _InIt2> ::_Result), bool> ::_Result  /* __cilk */ __cdecl 


__cilkfun_checked_equal(__cilk_box<_InIt1 > , __cilk_box<_InIt1 > , __cilk_box<_InIt2 > , __cilk_box<_Pr > ); 
#line 3896
}
#line 3951
extern "C" __declspec( dllimport ) void __cdecl _invalid_parameter_noinfo(); 





#pragma warning(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xmemory"
#pragma warning(push,3)
#pragma warning(disable: 4100)
#line 3958 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xutility"
#pragma pack ( pop )
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xmemory"
#pragma pack ( push, 8 )
#line 32
namespace std { 

template<class _Ty> inline _Ty *
_Allocate(size_t, _Ty *); 
#line 34
template<class _Ty> inline _Ty * /* __cilk */ __cdecl 
__cilkfun__Allocate(__cilk_box<unsigned > , __cilk_box<_Ty * > ); 
#line 47
template<class _T1, class 
_T2> inline void 
_Construct(_T1 *, const _T2 &); 
#line 47
template<class _T1, class 
_T2> inline void  /* __cilk */ __cdecl 
__cilkfun__Construct(__cilk_box<_T1 * > , __cilk_box<const _T2 & > ); 
#line 56
template<class _Ty> inline void 
_Destroy(_Ty *); 
#line 56
template<class _Ty> inline void  /* __cilk */ __cdecl 
__cilkfun__Destroy(__cilk_box<_Ty * > ); template<> inline void _Destroy(char *); 
#line 63
template<> inline void _Destroy(char *__T14549440) 
{ 
} 
#line 57
template<> inline void _Destroy(__wchar_t *); 
#line 68
template<> inline void _Destroy(__wchar_t *__T14549896) 
{ 
} 



template<class _Ty> 
struct _Allocator_base { friend struct __cilk_s;__CILK_METADATA(_Allocator_base, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Ty value_type; 
}; 


template<class _Ty> 
struct _Allocator_base< const _Ty>  { friend struct __cilk_s;__CILK_METADATA(_Allocator_base, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef _Ty value_type; 
}; 


template<class _Ty> 
class allocator : public _Allocator_base< _Ty>  { friend struct __cilk_s;__CILK_METADATA(allocator, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



typedef _Allocator_base< _Ty>  _Mybase; 
typedef typename _Allocator_base< _Ty> ::value_type value_type; 
typedef value_type *pointer; 
typedef value_type &reference; 
typedef const value_type *const_pointer; 
typedef const value_type &const_reference; 

typedef size_t size_type; 
typedef ptrdiff_t difference_type; 

template<class _Other> 
struct rebind { friend struct __cilk_s;__CILK_METADATA(rebind, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef std::allocator< _Other>  other; 
}; 

inline pointer address(reference) const; inline pointer  /* __cilk */ __thiscall __cilkfun_address(__cilk_box<value_type & > ) const; 




inline const_pointer address(const_reference) const; inline const_pointer  /* __cilk */ __thiscall __cilkfun_address(__cilk_box<const value_type & > ) const; 




inline allocator() throw(); 



inline allocator(const std::allocator< _Ty>  &) throw(); 



template<class _Other> inline 
allocator(const std::allocator< _Other>  &) throw(); 
#line 127
template<class _Other> inline  /* __cilk */ __thiscall 
allocator(__cilk_box<const std::allocator< _Other>  & > ) throw(); 



template<class _Other> inline std::allocator< _Ty>  &
operator=(const std::allocator< _Other>  &); 
#line 132
template<class _Other> inline std::allocator< _Ty>  & /* __cilk */ __thiscall 
operator=(__cilk_box<const std::allocator< _Other>  & > ); 




inline void deallocate(pointer, size_type); inline void  /* __cilk */ __thiscall __cilkfun_deallocate(__cilk_box<value_type * > , __cilk_box<unsigned > ); 




inline pointer allocate(size_type); inline pointer  /* __cilk */ __thiscall __cilkfun_allocate(__cilk_box<unsigned > ); 




inline pointer allocate(size_type, const void *); inline pointer  /* __cilk */ __thiscall __cilkfun_allocate(__cilk_box<unsigned > , __cilk_box<const void * > ); 




inline void construct(pointer, const _Ty &); inline void  /* __cilk */ __thiscall __cilkfun_construct(__cilk_box<value_type * > , __cilk_box<const _Ty & > ); 




inline void destroy(pointer); inline void  /* __cilk */ __thiscall __cilkfun_destroy(__cilk_box<value_type * > ); 




inline size_t max_size() const throw(); inline size_t  /* __cilk */ __thiscall __cilkfun_max_size() const throw(); 




}; 


template<class _Ty, class 
_Other> inline bool 
operator==(const allocator< _Ty>  &, const allocator< _Other>  &) throw(); 
#line 171
template<class _Ty, class 
_Other> inline bool  /* __cilk */ __cdecl 
__cilk_op_eq(__cilk_box<const allocator< _Ty>  & > , __cilk_box<const allocator< _Other>  & > ) throw(); 




template<class _Ty, class 
_Other> inline bool 
operator!=(const allocator< _Ty>  &, const allocator< _Other>  &) throw(); 
#line 178
template<class _Ty, class 
_Other> inline bool  /* __cilk */ __cdecl 
__cilk_op_ne(__cilk_box<const allocator< _Ty>  & > , __cilk_box<const allocator< _Other>  & > ) throw(); 
#line 186
template<> class __declspec( dllimport ) allocator< void>  { friend struct __cilk_s;__CILK_METADATA(allocator, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef void _Ty; 
typedef _Ty *pointer; 
typedef const _Ty *const_pointer; 
typedef _Ty value_type; 

template<class _Other> 
struct rebind { friend struct __cilk_s;__CILK_METADATA(rebind, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef std::allocator< _Other>  other; 
}; 

inline allocator() throw(); 



inline allocator(const std::allocator< void>  &) throw(); 



template<class _Other> inline 
allocator(const std::allocator< _Other>  &) throw(); 
#line 208
template<class _Other> inline  /* __cilk */ __thiscall 
allocator(__cilk_box<const std::allocator< _Other>  & > ) throw(); 



template<class _Other> inline std::allocator< void>  &
operator=(const std::allocator< _Other>  &); 
#line 213
template<class _Other> inline std::allocator< void>  & /* __cilk */ __thiscall 
operator=(__cilk_box<const std::allocator< _Other>  & > ); 



}; 
#line 200
inline allocator< void> ::allocator() throw() 
{ 
} 

inline allocator< void> ::allocator(const std::allocator< void>  &__T14615512) throw() 
{ 
} 
#line 221
template<class _Alloc> inline void 
_Destroy_range(typename _Alloc::pointer, typename _Alloc::pointer, _Alloc &); 
#line 221
template<class _Alloc> inline void  /* __cilk */ __cdecl 
__cilkfun__Destroy_range(__cilk_box<typename _Alloc::pointer > , __cilk_box<typename _Alloc::pointer > , __cilk_box<_Alloc & > ); 
#line 228
template<class _Alloc> inline void 
_Destroy_range(typename _Alloc::pointer, typename _Alloc::pointer, _Alloc &, _Nonscalar_ptr_iterator_tag); 
#line 228
template<class _Alloc> inline void  /* __cilk */ __cdecl 
__cilkfun__Destroy_range(__cilk_box<typename _Alloc::pointer > , __cilk_box<typename _Alloc::pointer > , __cilk_box<_Alloc & > , __cilk_box<_Nonscalar_ptr_iterator_tag > ); 
#line 237
template<class _Alloc> inline void 
_Destroy_range(typename _Alloc::pointer, typename _Alloc::pointer, _Alloc &, _Scalar_ptr_iterator_tag); 
#line 237
template<class _Alloc> inline void  /* __cilk */ __cdecl 
__cilkfun__Destroy_range(__cilk_box<typename _Alloc::pointer > , __cilk_box<typename _Alloc::pointer > , __cilk_box<_Alloc & > , __cilk_box<_Scalar_ptr_iterator_tag > ); 




}


#pragma warning(default: 4100)
#pragma warning(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xstring"
#pragma warning(push,3)
#pragma warning(disable:4412)
#line 248 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xmemory"
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xstring"
#pragma pack ( push, 8 )
#line 17
namespace std { 

#pragma warning(disable:4251)

template<class _Elem, class 
_Traits, class 
_Ax> class basic_string; 



template<class _Elem, class 
_Traits, class 
_Alloc> 
class _String_const_iterator : public _Ranit_base< _Elem, typename _Alloc::difference_type, typename _Alloc::const_pointer, typename _Alloc::const_reference, _Iterator_base_secure>  { friend struct __cilk_s;__CILK_METADATA(_String_const_iterator, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;




typedef std::_String_const_iterator< _Elem, _Traits, _Alloc>  _Myt; 
typedef basic_string< _Elem, _Traits, _Alloc>  _Mystring; 

typedef random_access_iterator_tag iterator_category; 
typedef _Elem value_type; 
typedef typename _Alloc::difference_type difference_type; 
typedef typename _Alloc::const_pointer pointer; 
typedef typename _Alloc::const_reference reference; 
typedef _Elem *_Inner_type; 


typedef _Range_checked_iterator_tag _Checked_iterator_category; 



typedef pointer _Checked_iterator_base_type; 

inline _Checked_iterator_base_type _Checked_iterator_base() const; inline _Checked_iterator_base_type  /* __cilk */ __thiscall __cilkfun__Checked_iterator_base() const; 




inline void _Checked_iterator_assign_from_base(_Checked_iterator_base_type); inline void  /* __cilk */ __thiscall __cilkfun__Checked_iterator_assign_from_base(__cilk_box<typename _Alloc::const_pointer > ); 
#line 63
inline _String_const_iterator(); 
#line 83
inline _String_const_iterator(pointer, const _Container_base_secure *); inline  /* __cilk */ __thiscall _String_const_iterator(__cilk_box<typename _Alloc::const_pointer > , __cilk_box<const _Container_base_secure * > ); 
#line 103
inline reference operator*() const; 
#line 127
inline pointer operator->() const; 




inline _Myt &operator++(); 
#line 143
inline _Myt operator++(int); 
#line 150
inline _Myt &operator--(); 
#line 161
inline _Myt operator--(int); 
#line 168
inline _Myt &operator+=(difference_type); inline _Myt & /* __cilk */ __thiscall __cilk_op_plus_assign(__cilk_box<typename _Alloc::difference_type > ); 
#line 181
inline _Myt operator+(difference_type) const; inline _Myt  /* __cilk */ __thiscall __cilk_op_plus(__cilk_box<typename _Alloc::difference_type > ) const; 
#line 187
inline _Myt &operator-=(difference_type); inline _Myt & /* __cilk */ __thiscall __cilk_op_minus_assign(__cilk_box<typename _Alloc::difference_type > ); 




inline _Myt operator-(difference_type) const; inline _Myt  /* __cilk */ __thiscall __cilk_op_minus(__cilk_box<typename _Alloc::difference_type > ) const; 
#line 198
inline difference_type operator-(const _Myt &) const; inline difference_type  /* __cilk */ __thiscall __cilk_op_minus(__cilk_box<const _Myt & > ) const; 
#line 213
inline reference operator[](difference_type) const; inline reference  /* __cilk */ __thiscall __cilk_op_subscript(__cilk_box<typename _Alloc::difference_type > ) const; 




inline bool operator==(const _Myt &) const; inline bool  /* __cilk */ __thiscall __cilk_op_eq(__cilk_box<const _Myt & > ) const; 
#line 233
inline bool operator!=(const _Myt &) const; inline bool  /* __cilk */ __thiscall __cilk_op_ne(__cilk_box<const _Myt & > ) const; 




inline bool operator<(const _Myt &) const; inline bool  /* __cilk */ __thiscall __cilk_op_lt(__cilk_box<const _Myt & > ) const; 
#line 253
inline bool operator>(const _Myt &) const; inline bool  /* __cilk */ __thiscall __cilk_op_gt(__cilk_box<const _Myt & > ) const; 




inline bool operator<=(const _Myt &) const; inline bool  /* __cilk */ __thiscall __cilk_op_le(__cilk_box<const _Myt & > ) const; 




inline bool operator>=(const _Myt &) const; inline bool  /* __cilk */ __thiscall __cilk_op_ge(__cilk_box<const _Myt & > ) const; 
#line 279
static inline void __cdecl _Xlen(); 




static inline void __cdecl _Xran(); 




static inline void __cdecl _Xinvarg(); 




pointer _Myptr; 
}; 

template<class _Elem, class 
_Traits, class 
_Alloc> inline _String_const_iterator< _Elem, _Traits, _Alloc>  
operator+(typename _String_const_iterator< _Elem, _Traits, _Alloc> ::difference_type, _String_const_iterator< _Elem, _Traits, _Alloc> ); 
#line 297
template<class _Elem, class 
_Traits, class 
_Alloc> inline _String_const_iterator< _Elem, _Traits, _Alloc>   /* __cilk */ __cdecl 
__cilk_op_plus(__cilk_box<typename _String_const_iterator< _Elem, _Traits, _Alloc> ::difference_type > , __cilk_box<_String_const_iterator< _Elem, _Traits, _Alloc>  > ); 
#line 309
template<class _Elem, class 
_Traits, class 
_Alloc> 
class _String_iterator : public _String_const_iterator< _Elem, _Traits, _Alloc>  { friend struct __cilk_s;__CILK_METADATA(_String_iterator, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



typedef std::_String_iterator< _Elem, _Traits, _Alloc>  _Myt; 
typedef _String_const_iterator< _Elem, _Traits, _Alloc>  _Mybase; 

typedef random_access_iterator_tag iterator_category; 
typedef _Elem value_type; 
typedef typename _Alloc::difference_type difference_type; 
typedef typename _Alloc::pointer pointer; 
typedef typename _Alloc::reference reference; 

inline _String_iterator(); 
#line 339
inline _String_iterator(pointer, const _Container_base_secure *); inline  /* __cilk */ __thiscall _String_iterator(__cilk_box<typename _Alloc::pointer > , __cilk_box<const _Container_base_secure * > ); 
#line 354
typedef pointer _Checked_iterator_base_type; 

inline _Checked_iterator_base_type _Checked_iterator_base() const; inline _Checked_iterator_base_type  /* __cilk */ __thiscall __cilkfun__Checked_iterator_base() const; 




inline void _Checked_iterator_assign_from_base(_Checked_iterator_base_type); inline void  /* __cilk */ __thiscall __cilkfun__Checked_iterator_assign_from_base(__cilk_box<typename _Alloc::pointer > ); 
#line 367
inline reference operator*() const; 




inline pointer operator->() const; 




inline _Myt &operator++(); 
#line 383
inline _Myt operator++(int); 
#line 390
inline _Myt &operator--(); 
#line 396
inline _Myt operator--(int); 
#line 403
inline _Myt &operator+=(difference_type); inline _Myt & /* __cilk */ __thiscall __cilk_op_plus_assign(__cilk_box<typename _Alloc::difference_type > ); 
#line 409
inline _Myt operator+(difference_type) const; inline _Myt  /* __cilk */ __thiscall __cilk_op_plus(__cilk_box<typename _Alloc::difference_type > ) const; 
#line 415
inline _Myt &operator-=(difference_type); inline _Myt & /* __cilk */ __thiscall __cilk_op_minus_assign(__cilk_box<typename _Alloc::difference_type > ); 




inline _Myt operator-(difference_type) const; inline _Myt  /* __cilk */ __thiscall __cilk_op_minus(__cilk_box<typename _Alloc::difference_type > ) const; 
#line 426
inline difference_type operator-(const _Mybase &) const; inline difference_type  /* __cilk */ __thiscall __cilk_op_minus(__cilk_box<const _Mybase & > ) const; 




inline reference operator[](difference_type) const; inline reference  /* __cilk */ __thiscall __cilk_op_subscript(__cilk_box<typename _Alloc::difference_type > ) const; 



}; 

template<class _Elem, class 
_Traits, class 
_Alloc> inline _String_iterator< _Elem, _Traits, _Alloc>  
operator+(typename _String_iterator< _Elem, _Traits, _Alloc> ::difference_type, _String_iterator< _Elem, _Traits, _Alloc> ); 
#line 437
template<class _Elem, class 
_Traits, class 
_Alloc> inline _String_iterator< _Elem, _Traits, _Alloc>   /* __cilk */ __cdecl 
__cilk_op_plus(__cilk_box<typename _String_iterator< _Elem, _Traits, _Alloc> ::difference_type > , __cilk_box<_String_iterator< _Elem, _Traits, _Alloc>  > ); 
#line 449
class __declspec( dllimport ) _String_base : public _Container_base_secure { friend struct __cilk_s;



public: static void __cdecl _Xlen(); 

static void __cdecl _Xran(); 

static void __cdecl _Xinvarg(); 
}; 


template<class _Ty, class 
_Alloc> 
class _String_val : public _String_base { friend struct __cilk_s;__CILK_METADATA(_String_val, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;




typedef typename _Alloc::template rebind< _Ty> ::other _Alty; 

protected: inline _String_val(typename __cilk_maybe_box<_String_val, typename _Alloc::template rebind< _Ty> ::other >::type  = (__cilk_maybe_box<_String_val, _Alty >::type (_Alty()))); 
#line 476
public: inline _String_val(const std::_String_val< _Ty, _Alloc>  &); 
#line 488
protected: _Alty _Alval; 
}; 


template<class _Elem, class 
_Traits, class 
_Ax> 
class basic_string : public _String_val< _Elem, _Ax>  { friend struct __cilk_s;__CILK_METADATA(basic_string, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



typedef std::basic_string< _Elem, _Traits, _Ax>  _Myt; 
typedef _String_val< _Elem, _Ax>  _Mybase; 
typedef typename _String_val< _Elem, _Ax> ::_Alty _Alloc; 
typedef typename _String_val< _Elem, _Ax> ::_Alty::size_type size_type; 
typedef typename _String_val< _Elem, _Ax> ::_Alty::difference_type _Dift; 
typedef _Dift difference_type; 
typedef typename _String_val< _Elem, _Ax> ::_Alty::pointer _Tptr; 
typedef typename _String_val< _Elem, _Ax> ::_Alty::const_pointer _Ctptr; 
typedef _Tptr pointer; 
typedef _Ctptr const_pointer; 
typedef typename _String_val< _Elem, _Ax> ::_Alty::reference _Reft; 
typedef _Reft reference; 
typedef typename _String_val< _Elem, _Ax> ::_Alty::const_reference const_reference; 
typedef typename _String_val< _Elem, _Ax> ::_Alty::value_type value_type; 



typedef _String_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  iterator; 
typedef _String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  const_iterator; 


friend class _String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty> ; 

typedef std::reverse_iterator< _String_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty> >  reverse_iterator; 
typedef std::reverse_iterator< _String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty> >  const_reverse_iterator; 
#line 563
inline basic_string(); 
#line 601
inline explicit basic_string(const _Alloc &); inline explicit  /* __cilk */ __thiscall basic_string(__cilk_box<const _Alloc & > ); 
#line 607
inline basic_string(const _Myt &, size_type, size_type = npos); inline  /* __cilk */ __thiscall basic_string(__cilk_box<const _Myt & > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(npos))); 
#line 621
inline basic_string(const _Myt &, size_type, size_type, const _Alloc &); inline  /* __cilk */ __thiscall basic_string(__cilk_box<const _Myt & > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<const _Alloc & > ); 
#line 635
inline basic_string(const _Elem *, size_type); inline  /* __cilk */ __thiscall basic_string(__cilk_box<const _Elem * > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ); 
#line 642
inline basic_string(const _Elem *, size_type, const _Alloc &); inline  /* __cilk */ __thiscall basic_string(__cilk_box<const _Elem * > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<const _Alloc & > ); 
#line 649
inline basic_string(const _Elem *); inline  /* __cilk */ __thiscall basic_string(__cilk_box<const _Elem * > ); 
#line 656
inline basic_string(const _Elem *, const _Alloc &); inline  /* __cilk */ __thiscall basic_string(__cilk_box<const _Elem * > , __cilk_box<const _Alloc & > ); 
#line 663
inline basic_string(size_type, _Elem); inline  /* __cilk */ __thiscall basic_string(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<_Elem > ); 
#line 670
inline basic_string(size_type, _Elem, const _Alloc &); inline  /* __cilk */ __thiscall basic_string(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<_Elem > , __cilk_box<const _Alloc & > ); 
#line 677
template<class _It> inline 
basic_string(_It, _It); 
#line 677
template<class _It> inline  /* __cilk */ __thiscall 
basic_string(__cilk_box<_It > , __cilk_box<_It > ); 
#line 685
template<class _It> inline 
basic_string(_It, _It, const _Alloc &); 
#line 685
template<class _It> inline  /* __cilk */ __thiscall 
basic_string(__cilk_box<_It > , __cilk_box<_It > , __cilk_box<const _Alloc & > ); 
#line 693
inline basic_string(const_pointer, const_pointer); inline  /* __cilk */ __thiscall basic_string(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::const_pointer > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::const_pointer > ); 
#line 704
inline basic_string(const_iterator, const_iterator); inline  /* __cilk */ __thiscall basic_string(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > ); 
#line 719
inline basic_string(const _Myt &); 
#line 860
template<class _It> inline void 
_Construct(_It, _It, _Int_iterator_tag); 
#line 860
template<class _It> inline void  /* __cilk */ __thiscall 
__cilkfun__Construct(__cilk_box<_It > , __cilk_box<_It > , __cilk_box<_Int_iterator_tag > ); 
#line 867
template<class _It> inline void 
_Construct(_It, _It, input_iterator_tag); 
#line 867
template<class _It> inline void  /* __cilk */ __thiscall 
__cilkfun__Construct(__cilk_box<_It > , __cilk_box<_It > , __cilk_box<input_iterator_tag > ); 
#line 880
template<class _It> inline void 
_Construct(_It, _It, forward_iterator_tag); 
#line 880
template<class _It> inline void  /* __cilk */ __thiscall 
__cilkfun__Construct(__cilk_box<_It > , __cilk_box<_It > , __cilk_box<forward_iterator_tag > ); 
#line 904
inline ~basic_string(); 




typedef _Traits traits_type; 
typedef _Alloc allocator_type; 

static const size_type npos; 

inline _Myt &operator=(const _Myt &); 




inline _Myt &operator=(const _Elem *); inline _Myt & /* __cilk */ __thiscall operator=(__cilk_box<const _Elem * > ); 




inline _Myt &operator=(_Elem); inline _Myt & /* __cilk */ __thiscall operator=(__cilk_box<_Elem > ); 




inline _Myt &operator+=(const _Myt &); inline _Myt & /* __cilk */ __thiscall __cilk_op_plus_assign(__cilk_box<const _Myt & > ); 




inline _Myt &operator+=(const _Elem *); inline _Myt & /* __cilk */ __thiscall __cilk_op_plus_assign(__cilk_box<const _Elem * > ); 




inline _Myt &operator+=(_Elem); inline _Myt & /* __cilk */ __thiscall __cilk_op_plus_assign(__cilk_box<_Elem > ); 




inline _Myt &append(const _Myt &); inline _Myt & /* __cilk */ __thiscall __cilkfun_append(__cilk_box<const _Myt & > ); 




inline _Myt &append(const _Myt &, size_type, size_type); inline _Myt & /* __cilk */ __thiscall __cilkfun_append(__cilk_box<const _Myt & > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ); 
#line 969
inline _Myt &append(const _Elem *, size_type); inline _Myt & /* __cilk */ __thiscall __cilkfun_append(__cilk_box<const _Elem * > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ); 
#line 991
inline _Myt &append(const _Elem *); inline _Myt & /* __cilk */ __thiscall __cilkfun_append(__cilk_box<const _Elem * > ); 
#line 997
inline _Myt &append(size_type, _Elem); inline _Myt & /* __cilk */ __thiscall __cilkfun_append(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<_Elem > ); 
#line 1011
template<class _It> inline _Myt &
append(_It, _It); 
#line 1011
template<class _It> inline _Myt & /* __cilk */ __thiscall 
__cilkfun_append(__cilk_box<_It > , __cilk_box<_It > ); 




template<class _It> inline _Myt &
_Append(_It, _It, _Int_iterator_tag); 
#line 1017
template<class _It> inline _Myt & /* __cilk */ __thiscall 
__cilkfun__Append(__cilk_box<_It > , __cilk_box<_It > , __cilk_box<_Int_iterator_tag > ); 




template<class _It> inline _Myt &
_Append(_It, _It, input_iterator_tag); 
#line 1023
template<class _It> inline _Myt & /* __cilk */ __thiscall 
__cilkfun__Append(__cilk_box<_It > , __cilk_box<_It > , __cilk_box<input_iterator_tag > ); 




inline _Myt &append(const_pointer, const_pointer); inline _Myt & /* __cilk */ __thiscall __cilkfun_append(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::const_pointer > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::const_pointer > ); 




inline _Myt &append(const_iterator, const_iterator); inline _Myt & /* __cilk */ __thiscall __cilkfun_append(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > ); 




inline _Myt &assign(const _Myt &); inline _Myt & /* __cilk */ __thiscall __cilkfun_assign(__cilk_box<const _Myt & > ); 




inline _Myt &assign(const _Myt &, size_type, size_type); inline _Myt & /* __cilk */ __thiscall __cilkfun_assign(__cilk_box<const _Myt & > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ); 
#line 1063
inline _Myt &assign(const _Elem *, size_type); inline _Myt & /* __cilk */ __thiscall __cilkfun_assign(__cilk_box<const _Elem * > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ); 
#line 1082
inline _Myt &assign(const _Elem *); inline _Myt & /* __cilk */ __thiscall __cilkfun_assign(__cilk_box<const _Elem * > ); 
#line 1088
inline _Myt &assign(size_type, _Elem); inline _Myt & /* __cilk */ __thiscall __cilkfun_assign(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<_Elem > ); 
#line 1101
template<class _It> inline _Myt &
assign(_It, _It); 
#line 1101
template<class _It> inline _Myt & /* __cilk */ __thiscall 
__cilkfun_assign(__cilk_box<_It > , __cilk_box<_It > ); 




template<class _It> inline _Myt &
_Assign(_It, _It, _Int_iterator_tag); 
#line 1107
template<class _It> inline _Myt & /* __cilk */ __thiscall 
__cilkfun__Assign(__cilk_box<_It > , __cilk_box<_It > , __cilk_box<_Int_iterator_tag > ); 




template<class _It> inline _Myt &
_Assign(_It, _It, input_iterator_tag); 
#line 1113
template<class _It> inline _Myt & /* __cilk */ __thiscall 
__cilkfun__Assign(__cilk_box<_It > , __cilk_box<_It > , __cilk_box<input_iterator_tag > ); 




inline _Myt &assign(const_pointer, const_pointer); inline _Myt & /* __cilk */ __thiscall __cilkfun_assign(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::const_pointer > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::const_pointer > ); 




inline _Myt &assign(const_iterator, const_iterator); inline _Myt & /* __cilk */ __thiscall __cilkfun_assign(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > ); 




inline _Myt &insert(size_type, const _Myt &); inline _Myt & /* __cilk */ __thiscall __cilkfun_insert(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<const _Myt & > ); 




inline _Myt &insert(size_type, const _Myt &, size_type, size_type); inline _Myt & /* __cilk */ __thiscall __cilkfun_insert(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<const _Myt & > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ); 
#line 1161
inline _Myt &insert(size_type, const _Elem *, size_type); inline _Myt & /* __cilk */ __thiscall __cilkfun_insert(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<const _Elem * > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ); 
#line 1188
inline _Myt &insert(size_type, const _Elem *); inline _Myt & /* __cilk */ __thiscall __cilkfun_insert(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<const _Elem * > ); 
#line 1194
inline _Myt &insert(size_type, size_type, _Elem); inline _Myt & /* __cilk */ __thiscall __cilkfun_insert(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<_Elem > ); 
#line 1212
inline iterator insert(const_iterator); inline iterator  /* __cilk */ __thiscall __cilkfun_insert(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > ); 




inline iterator insert(const_iterator, _Elem); inline iterator  /* __cilk */ __thiscall __cilkfun_insert(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_Elem > ); 
#line 1224
inline void insert(const_iterator, size_type, _Elem); inline void  /* __cilk */ __thiscall __cilkfun_insert(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<_Elem > ); 
#line 1230
template<class _It> inline void 
insert(const_iterator, _It, _It); 
#line 1230
template<class _It> inline void  /* __cilk */ __thiscall 
__cilkfun_insert(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_It > , __cilk_box<_It > ); 




template<class _It> inline void 
_Insert(const_iterator, _It, _It, _Int_iterator_tag); 
#line 1236
template<class _It> inline void  /* __cilk */ __thiscall 
__cilkfun__Insert(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_It > , __cilk_box<_It > , __cilk_box<_Int_iterator_tag > ); 
#line 1243
template<class _It> inline void 
_Insert(const_iterator, _It, _It, input_iterator_tag); 
#line 1243
template<class _It> inline void  /* __cilk */ __thiscall 
__cilkfun__Insert(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_It > , __cilk_box<_It > , __cilk_box<input_iterator_tag > ); 
#line 1250
inline void insert(const_iterator, const_pointer, const_pointer); inline void  /* __cilk */ __thiscall __cilkfun_insert(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::const_pointer > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::const_pointer > ); 




inline void insert(const_iterator, const_iterator, const_iterator); inline void  /* __cilk */ __thiscall __cilkfun_insert(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > ); 




inline _Myt &erase(size_type = 0, size_type = npos); inline _Myt & /* __cilk */ __thiscall __cilkfun_erase(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(0)), __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(npos))); 
#line 1277
inline iterator erase(const_iterator); inline iterator  /* __cilk */ __thiscall __cilkfun_erase(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > ); 
#line 1284
inline iterator erase(const_iterator, const_iterator); inline iterator  /* __cilk */ __thiscall __cilkfun_erase(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > ); 
#line 1291
inline void clear(); inline void  /* __cilk */ __thiscall __cilkfun_clear(); 




inline _Myt &replace(size_type, size_type, const _Myt &); inline _Myt & /* __cilk */ __thiscall __cilkfun_replace(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<const _Myt & > ); 




inline _Myt &replace(size_type, size_type, const _Myt &, size_type, size_type); inline _Myt & /* __cilk */ __thiscall __cilkfun_replace(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<const _Myt & > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ); 
#line 1361
inline _Myt &replace(size_type, size_type, const _Elem *, size_type); inline _Myt & /* __cilk */ __thiscall __cilkfun_replace(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<const _Elem * > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ); 
#line 1396
inline _Myt &replace(size_type, size_type, const _Elem *); inline _Myt & /* __cilk */ __thiscall __cilkfun_replace(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<const _Elem * > ); 
#line 1402
inline _Myt &replace(size_type, size_type, size_type, _Elem); inline _Myt & /* __cilk */ __thiscall __cilkfun_replace(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<_Elem > ); 
#line 1428
inline _Myt &replace(const_iterator, const_iterator, const _Myt &); inline _Myt & /* __cilk */ __thiscall __cilkfun_replace(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<const _Myt & > ); 
#line 1434
inline _Myt &replace(const_iterator, const_iterator, const _Elem *, size_type); inline _Myt & /* __cilk */ __thiscall __cilkfun_replace(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<const _Elem * > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ); 
#line 1441
inline _Myt &replace(const_iterator, const_iterator, const _Elem *); inline _Myt & /* __cilk */ __thiscall __cilkfun_replace(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<const _Elem * > ); 
#line 1447
inline _Myt &replace(const_iterator, const_iterator, size_type, _Elem); inline _Myt & /* __cilk */ __thiscall __cilkfun_replace(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<_Elem > ); 
#line 1454
template<class _It> inline _Myt &
replace(const_iterator, const_iterator, _It, _It); 
#line 1454
template<class _It> inline _Myt & /* __cilk */ __thiscall 
__cilkfun_replace(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_It > , __cilk_box<_It > ); 
#line 1462
template<class _It> inline _Myt &
_Replace(const_iterator, const_iterator, _It, _It, _Int_iterator_tag); 
#line 1462
template<class _It> inline _Myt & /* __cilk */ __thiscall 
__cilkfun__Replace(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_It > , __cilk_box<_It > , __cilk_box<_Int_iterator_tag > ); 
#line 1469
template<class _It> inline _Myt &
_Replace(const_iterator, const_iterator, _It, _It, input_iterator_tag); 
#line 1469
template<class _It> inline _Myt & /* __cilk */ __thiscall 
__cilkfun__Replace(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_It > , __cilk_box<_It > , __cilk_box<input_iterator_tag > ); 
#line 1478
inline _Myt &replace(const_iterator, const_iterator, const_pointer, const_pointer); inline _Myt & /* __cilk */ __thiscall __cilkfun_replace(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::const_pointer > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::const_pointer > ); 
#line 1489
inline _Myt &replace(const_iterator, const_iterator, const_iterator, const_iterator); inline _Myt & /* __cilk */ __thiscall __cilkfun_replace(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > ); 
#line 1500
inline iterator begin(); inline iterator  /* __cilk */ __thiscall __cilkfun_begin(); 




inline const_iterator begin() const; inline const_iterator  /* __cilk */ __thiscall __cilkfun_begin() const; 




inline iterator end(); inline iterator  /* __cilk */ __thiscall __cilkfun_end(); 




inline const_iterator end() const; inline const_iterator  /* __cilk */ __thiscall __cilkfun_end() const; 




inline reverse_iterator rbegin(); inline reverse_iterator  /* __cilk */ __thiscall __cilkfun_rbegin(); 




inline const_reverse_iterator rbegin() const; inline const_reverse_iterator  /* __cilk */ __thiscall __cilkfun_rbegin() const; 




inline reverse_iterator rend(); inline reverse_iterator  /* __cilk */ __thiscall __cilkfun_rend(); 




inline const_reverse_iterator rend() const; inline const_reverse_iterator  /* __cilk */ __thiscall __cilkfun_rend() const; 




inline reference at(size_type); inline reference  /* __cilk */ __thiscall __cilkfun_at(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ); 
#line 1547
inline const_reference at(size_type) const; inline const_reference  /* __cilk */ __thiscall __cilkfun_at(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ) const; 
#line 1556
inline reference operator[](size_type); inline reference  /* __cilk */ __thiscall __cilk_op_subscript(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ); 
#line 1576
inline const_reference operator[](size_type) const; inline const_reference  /* __cilk */ __thiscall __cilk_op_subscript(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ) const; 
#line 1644
inline void push_back(_Elem); inline void  /* __cilk */ __thiscall __cilkfun_push_back(__cilk_box<_Elem > ); 




inline const _Elem *c_str() const; inline const _Elem * /* __cilk */ __thiscall __cilkfun_c_str() const; 




inline const _Elem *data() const; inline const _Elem * /* __cilk */ __thiscall __cilkfun_data() const; 




inline size_type length() const; inline size_type  /* __cilk */ __thiscall __cilkfun_length() const; 




inline size_type size() const; inline size_type  /* __cilk */ __thiscall __cilkfun_size() const; 




inline size_type max_size() const; inline size_type  /* __cilk */ __thiscall __cilkfun_max_size() const; 
#line 1675
inline void resize(size_type); inline void  /* __cilk */ __thiscall __cilkfun_resize(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ); 




inline void resize(size_type, _Elem); inline void  /* __cilk */ __thiscall __cilkfun_resize(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<_Elem > ); 
#line 1688
inline size_type capacity() const; inline size_type  /* __cilk */ __thiscall __cilkfun_capacity() const; 




inline void reserve(size_type = 0); inline void  /* __cilk */ __thiscall __cilkfun_reserve(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(0))); 
#line 1703
inline bool empty() const; inline bool  /* __cilk */ __thiscall __cilkfun_empty() const; 
#line 1709
inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) size_type copy(_Elem *, size_type, size_type = 0) const; inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) size_type  /* __cilk */ __thiscall __cilkfun_copy(__cilk_box<_Elem * > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(0))) const; 
#line 1722
inline size_type _Copy_s(_Elem *, size_type, size_type, size_type = 0) const; inline size_type  /* __cilk */ __thiscall __cilkfun__Copy_s(__cilk_box<_Elem * > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(0))) const; 
#line 1734
inline void swap(_Myt &); inline void  /* __cilk */ __thiscall __cilkfun_swap(__cilk_box<_Myt & > ); 
#line 1763
inline size_type find(const _Myt &, size_type = 0) const; inline size_type  /* __cilk */ __thiscall __cilkfun_find(__cilk_box<const _Myt & > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(0))) const; 




inline size_type find(const _Elem *, size_type, size_type) const; inline size_type  /* __cilk */ __thiscall __cilkfun_find(__cilk_box<const _Elem * > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ) const; 
#line 1794
inline size_type find(const _Elem *, size_type = 0) const; inline size_type  /* __cilk */ __thiscall __cilkfun_find(__cilk_box<const _Elem * > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(0))) const; 
#line 1800
inline size_type find(_Elem, size_type = 0) const; inline size_type  /* __cilk */ __thiscall __cilkfun_find(__cilk_box<_Elem > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(0))) const; 




inline size_type rfind(const _Myt &, size_type = npos) const; inline size_type  /* __cilk */ __thiscall __cilkfun_rfind(__cilk_box<const _Myt & > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(npos))) const; 




inline size_type rfind(const _Elem *, size_type, size_type) const; inline size_type  /* __cilk */ __thiscall __cilkfun_rfind(__cilk_box<const _Elem * > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ) const; 
#line 1836
inline size_type rfind(const _Elem *, size_type = npos) const; inline size_type  /* __cilk */ __thiscall __cilkfun_rfind(__cilk_box<const _Elem * > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(npos))) const; 
#line 1842
inline size_type rfind(_Elem, size_type = npos) const; inline size_type  /* __cilk */ __thiscall __cilkfun_rfind(__cilk_box<_Elem > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(npos))) const; 




inline size_type find_first_of(const _Myt &, size_type = 0) const; inline size_type  /* __cilk */ __thiscall __cilkfun_find_first_of(__cilk_box<const _Myt & > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(0))) const; 
#line 1853
inline size_type find_first_of(const _Elem *, size_type, size_type) const; inline size_type  /* __cilk */ __thiscall __cilkfun_find_first_of(__cilk_box<const _Elem * > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ) const; 
#line 1873
inline size_type find_first_of(const _Elem *, size_type = 0) const; inline size_type  /* __cilk */ __thiscall __cilkfun_find_first_of(__cilk_box<const _Elem * > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(0))) const; 
#line 1879
inline size_type find_first_of(_Elem, size_type = 0) const; inline size_type  /* __cilk */ __thiscall __cilkfun_find_first_of(__cilk_box<_Elem > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(0))) const; 




inline size_type find_last_of(const _Myt &, size_type = npos) const; inline size_type  /* __cilk */ __thiscall __cilkfun_find_last_of(__cilk_box<const _Myt & > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(npos))) const; 
#line 1890
inline size_type find_last_of(const _Elem *, size_type, size_type) const; inline size_type  /* __cilk */ __thiscall __cilkfun_find_last_of(__cilk_box<const _Elem * > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ) const; 
#line 1910
inline size_type find_last_of(const _Elem *, size_type = npos) const; inline size_type  /* __cilk */ __thiscall __cilkfun_find_last_of(__cilk_box<const _Elem * > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(npos))) const; 
#line 1917
inline size_type find_last_of(_Elem, size_type = npos) const; inline size_type  /* __cilk */ __thiscall __cilkfun_find_last_of(__cilk_box<_Elem > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(npos))) const; 




inline size_type find_first_not_of(const _Myt &, size_type = 0) const; inline size_type  /* __cilk */ __thiscall __cilkfun_find_first_not_of(__cilk_box<const _Myt & > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(0))) const; 
#line 1929
inline size_type find_first_not_of(const _Elem *, size_type, size_type) const; inline size_type  /* __cilk */ __thiscall __cilkfun_find_first_not_of(__cilk_box<const _Elem * > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ) const; 
#line 1948
inline size_type find_first_not_of(const _Elem *, size_type = 0) const; inline size_type  /* __cilk */ __thiscall __cilkfun_find_first_not_of(__cilk_box<const _Elem * > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(0))) const; 
#line 1955
inline size_type find_first_not_of(_Elem, size_type = 0) const; inline size_type  /* __cilk */ __thiscall __cilkfun_find_first_not_of(__cilk_box<_Elem > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(0))) const; 




inline size_type find_last_not_of(const _Myt &, size_type = npos) const; inline size_type  /* __cilk */ __thiscall __cilkfun_find_last_not_of(__cilk_box<const _Myt & > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(npos))) const; 
#line 1966
inline size_type find_last_not_of(const _Elem *, size_type, size_type) const; inline size_type  /* __cilk */ __thiscall __cilkfun_find_last_not_of(__cilk_box<const _Elem * > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ) const; 
#line 1985
inline size_type find_last_not_of(const _Elem *, size_type = npos) const; inline size_type  /* __cilk */ __thiscall __cilkfun_find_last_not_of(__cilk_box<const _Elem * > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(npos))) const; 
#line 1992
inline size_type find_last_not_of(_Elem, size_type = npos) const; inline size_type  /* __cilk */ __thiscall __cilkfun_find_last_not_of(__cilk_box<_Elem > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(npos))) const; 




inline _Myt substr(size_type = 0, size_type = npos) const; inline _Myt  /* __cilk */ __thiscall __cilkfun_substr(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(0)), __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(npos))) const; 




inline int compare(const _Myt &) const; inline int  /* __cilk */ __thiscall __cilkfun_compare(__cilk_box<const _Myt & > ) const; 




inline int compare(size_type, size_type, const _Myt &) const; inline int  /* __cilk */ __thiscall __cilkfun_compare(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<const _Myt & > ) const; 
#line 2013
inline int compare(size_type, size_type, const _Myt &, size_type, size_type) const; inline int  /* __cilk */ __thiscall __cilkfun_compare(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<const _Myt & > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ) const; 
#line 2024
inline int compare(const _Elem *) const; inline int  /* __cilk */ __thiscall __cilkfun_compare(__cilk_box<const _Elem * > ) const; 
#line 2030
inline int compare(size_type, size_type, const _Elem *) const; inline int  /* __cilk */ __thiscall __cilkfun_compare(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<const _Elem * > ) const; 
#line 2036
inline int compare(size_type, size_type, const _Elem *, size_type) const; inline int  /* __cilk */ __thiscall __cilkfun_compare(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<const _Elem * > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ) const; 
#line 2056
inline allocator_type get_allocator() const; inline allocator_type  /* __cilk */ __thiscall __cilkfun_get_allocator() const; 
#line 2062
enum { 
_BUF_SIZE = (((16) / sizeof(_Elem) < (1)) ? (1) : ((16) / sizeof(_Elem)))
}; 



enum { 
_ALLOC_MASK = ((sizeof(_Elem) <= (1)) ? 15 : ((sizeof(_Elem) <= (2)) ? 7 : ((sizeof(_Elem) <= (4)) ? 3 : ((sizeof(_Elem) <= (8)) ? 1 : 0))))


}; 

protected: inline void _Chassign(size_type, size_type, _Elem); inline void  /* __cilk */ __thiscall __cilkfun__Chassign(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<_Elem > ); 
#line 2082
inline void _Copy(size_type, size_type); inline void  /* __cilk */ __thiscall __cilkfun__Copy(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ); 
#line 2112
inline void _Eos(size_type); inline void  /* __cilk */ __thiscall __cilkfun__Eos(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > ); 




inline bool _Grow(size_type, bool = false); inline bool  /* __cilk */ __thiscall __cilkfun__Grow(__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type > , __cilk_box<bool >  = (__cilk_box<bool >(false))); 
#line 2132
inline bool _Inside(const _Elem *); inline bool  /* __cilk */ __thiscall __cilkfun__Inside(__cilk_box<const _Elem * > ); 
#line 2140
static inline size_type _Pdif(const_iterator, const_iterator); static inline size_type  /* __cilk */ __cdecl __cilkfun__Pdif(__cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > , __cilk_box<_String_const_iterator< _Elem, _Traits, typename _String_val< _Elem, _Ax> ::_Alty>  > ); 
#line 2146
inline void _Tidy(bool = false, size_type = 0); inline void  /* __cilk */ __thiscall __cilkfun__Tidy(__cilk_box<bool >  = (__cilk_box<bool >(false)), __cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >  = (__cilk_box<typename _String_val< _Elem, _Ax> ::_Alty::size_type >(0))); 
#line 2162
union _Bxty { friend struct __cilk_s;__CILK_METADATA(_Bxty, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

_Elem _Buf[_BUF_SIZE]; 
_Elem *_Ptr; 
} _Bx; 

inline _Elem *_Myptr(); inline _Elem * /* __cilk */ __thiscall __cilkfun__Myptr(); 




inline const _Elem *_Myptr() const; inline const _Elem * /* __cilk */ __thiscall __cilkfun__Myptr() const; 




size_type _Mysize; 
size_type _Myres; 
}; 


template<class _Elem, class _Traits, class _Ax> 
class _Move_operation_category< basic_string< _Elem, _Traits, _Ax> >  { friend struct __cilk_s;__CILK_METADATA(_Move_operation_category, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef _Swap_move_tag _Move_cat; 
}; 
#line 2200
template<class _Elem, class 
_Traits, class 
_Alloc> inline void 
swap(basic_string< _Elem, _Traits, _Alloc>  &, basic_string< _Elem, _Traits, _Alloc>  &); 
#line 2200
template<class _Elem, class 
_Traits, class 
_Alloc> inline void  /* __cilk */ __cdecl 
__cilkfun_swap(__cilk_box<basic_string< _Elem, _Traits, _Alloc>  & > , __cilk_box<basic_string< _Elem, _Traits, _Alloc>  & > ); 
#line 2210
typedef basic_string< char, char_traits< char> , allocator< char> >  string; 

typedef basic_string< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wstring; 



template class __declspec( dllimport ) allocator< char> ;
template class __declspec( dllimport ) allocator< __wchar_t> ;
template class __declspec( dllimport ) _String_val< char, allocator< char> > ;
template class __declspec( dllimport ) _String_val< __wchar_t, allocator< __wchar_t> > ;
template class __declspec( dllimport ) basic_string< char, char_traits< char> , allocator< char> > ;

template class __declspec( dllimport ) basic_string< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> > ;
#line 2229
}

#pragma warning(default: 4251)
#pragma warning(pop)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdexcept"
#pragma warning(push,3)
#line 2233 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xstring"
#pragma pack ( pop )
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdexcept"
#pragma pack ( push, 8 )


namespace std { 
#line 20
class logic_error : public exception { friend struct __cilk_s;__CILK_METADATA(logic_error, __CILK_VBASE_DETECT)



public: inline explicit __declspec( noinline ) logic_error(const string &); 




inline virtual __declspec( noinline ) ~logic_error() throw(); 



inline virtual __declspec( noinline ) const char *what() const throw(); 
#line 47
private: string _Str; 
}; 
#line 24
inline __declspec( noinline ) logic_error::logic_error(const string &_Message) : _Str(_Message) 

{ 
}  __CILK_BEGIN_INSTANTIATE_METADATA basic_string< char, char_traits< char> , allocator< char> >  __CILK_END_INSTANTIATE_METADATA

inline __declspec( noinline ) logic_error::~logic_error() throw() 
{ 
} 

inline __declspec( noinline ) const char *logic_error::what() const throw() 
{ 
return (this->_Str).c_str(); 
} 
#line 51
class domain_error : public logic_error { friend struct __cilk_s;__CILK_METADATA(domain_error, __CILK_VBASE_DETECT)



public: inline explicit __declspec( noinline ) domain_error(const string &); 




inline virtual __declspec( noinline ) ~domain_error() throw(); 
#line 72
}; 
#line 55
inline __declspec( noinline ) domain_error::domain_error(const string &_Message) : logic_error(_Message) 

{ 
} 

inline __declspec( noinline ) domain_error::~domain_error() throw() 
{ 
} 
#line 75
class invalid_argument : public logic_error { friend struct __cilk_s;__CILK_METADATA(invalid_argument, __CILK_VBASE_DETECT)



public: inline explicit __declspec( noinline ) invalid_argument(const string &); 




inline virtual __declspec( noinline ) ~invalid_argument() throw(); 
#line 96
}; 
#line 79
inline __declspec( noinline ) invalid_argument::invalid_argument(const string &_Message) : logic_error(_Message) 

{ 
} 

inline __declspec( noinline ) invalid_argument::~invalid_argument() throw() 
{ 
} 
#line 99
class length_error : public logic_error { friend struct __cilk_s;__CILK_METADATA(length_error, __CILK_VBASE_DETECT)



public: inline explicit __declspec( noinline ) length_error(const string &); 




inline virtual __declspec( noinline ) ~length_error() throw(); 
#line 120
}; 
#line 103
inline __declspec( noinline ) length_error::length_error(const string &_Message) : logic_error(_Message) 

{ 
} 

inline __declspec( noinline ) length_error::~length_error() throw() 
{ 
} 
#line 123
class out_of_range : public logic_error { friend struct __cilk_s;__CILK_METADATA(out_of_range, __CILK_VBASE_DETECT)



public: inline explicit __declspec( noinline ) out_of_range(const string &); 




inline virtual __declspec( noinline ) ~out_of_range() throw(); 
#line 144
}; 
#line 127
inline __declspec( noinline ) out_of_range::out_of_range(const string &_Message) : logic_error(_Message) 

{ 
} 

inline __declspec( noinline ) out_of_range::~out_of_range() throw() 
{ 
} 
#line 147
class runtime_error : public exception { friend struct __cilk_s;__CILK_METADATA(runtime_error, __CILK_VBASE_DETECT)



public: inline explicit __declspec( noinline ) runtime_error(const string &); 




inline virtual __declspec( noinline ) ~runtime_error() throw(); 



inline virtual __declspec( noinline ) const char *what() const throw(); 
#line 174
private: string _Str; 
}; 
#line 151
inline __declspec( noinline ) runtime_error::runtime_error(const string &_Message) : _Str(_Message) 

{ 
} 

inline __declspec( noinline ) runtime_error::~runtime_error() throw() 
{ 
} 

inline __declspec( noinline ) const char *runtime_error::what() const throw() 
{ 
return (this->_Str).c_str(); 
} 
#line 178
class overflow_error : public runtime_error { friend struct __cilk_s;__CILK_METADATA(overflow_error, __CILK_VBASE_DETECT)



public: inline explicit __declspec( noinline ) overflow_error(const string &); 




inline virtual __declspec( noinline ) ~overflow_error() throw(); 
#line 199
}; 
#line 182
inline __declspec( noinline ) overflow_error::overflow_error(const string &_Message) : runtime_error(_Message) 

{ 
} 

inline __declspec( noinline ) overflow_error::~overflow_error() throw() 
{ 
} 
#line 202
class underflow_error : public runtime_error { friend struct __cilk_s;__CILK_METADATA(underflow_error, __CILK_VBASE_DETECT)



public: inline explicit __declspec( noinline ) underflow_error(const string &); 




inline virtual __declspec( noinline ) ~underflow_error() throw(); 
#line 223
}; 
#line 206
inline __declspec( noinline ) underflow_error::underflow_error(const string &_Message) : runtime_error(_Message) 

{ 
} 

inline __declspec( noinline ) underflow_error::~underflow_error() throw() 
{ 
} 
#line 226
class range_error : public runtime_error { friend struct __cilk_s;__CILK_METADATA(range_error, __CILK_VBASE_DETECT)



public: inline explicit __declspec( noinline ) range_error(const string &); 




inline virtual __declspec( noinline ) ~range_error() throw(); 
#line 247
}; 
#line 230
inline __declspec( noinline ) range_error::range_error(const string &_Message) : runtime_error(_Message) 

{ 
} 

inline __declspec( noinline ) range_error::~range_error() throw() 
{ 
} 
#line 271
}

#pragma warning(pop)
#pragma pack ( pop )
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\typeinfo"
#pragma pack ( push, 8 )
#line 36
struct __type_info_node { friend struct __cilk_s;
void *memPtr; 
__type_info_node *next; 
}; 

extern __type_info_node __type_info_root_node; 

class type_info { friend struct __cilk_s;

public: virtual ~type_info(); 
__declspec( dllimport ) bool operator==(const type_info &) const; 
__declspec( dllimport ) bool operator!=(const type_info &) const; 
__declspec( dllimport ) int before(const type_info &) const; 
__declspec( dllimport ) const char *name(__type_info_node * = (&__type_info_root_node)) const; 
__declspec( dllimport ) const char *raw_name() const; 

private: void *_m_data; 
char _m_d_name[1]; 
type_info(const type_info &); 
type_info &operator=(const type_info &); 
static __declspec( dllimport ) const char *_Name_base(const type_info *, __type_info_node *); 
static __declspec( dllimport ) void _Type_info_dtor(type_info *); 
}; 



namespace std { 

using ::type_info;

}
#line 72
namespace std { 

class __declspec( dllimport ) bad_cast : public exception { friend struct __cilk_s;__CILK_METADATA(bad_cast, __CILK_VBASE_DETECT)
#line 86
public: bad_cast(const char * = ("bad cast")); 
bad_cast(const bad_cast &); 
virtual ~bad_cast(); 

}; 

class __declspec( dllimport ) bad_typeid : public exception { friend struct __cilk_s;
#line 104
public: bad_typeid(const char * = ("bad typeid")); 
bad_typeid(const bad_typeid &); 
virtual ~bad_typeid(); 


}; 

class __declspec( dllimport ) __non_rtti_object : public bad_typeid { friend struct __cilk_s;
#line 123
public: __non_rtti_object(const char *); 
__non_rtti_object(const __non_rtti_object &); 
virtual ~__non_rtti_object(); 

}; 

}
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xdebug"
#pragma warning(push,3)
#line 194 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\typeinfo"
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xdebug"
#pragma pack ( push, 8 )



namespace std { 
struct _DebugHeapTag_t { friend struct __cilk_s;

int _Type; 
}; 
}
#line 154
#pragma warning(pop)
#pragma pack ( pop )
#line 94 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ctype.h"
extern "C" { extern __declspec( dllimport ) int __cdecl _isctype(int, int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _isctype_l(int, int, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl isalpha(int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _isalpha_l(int, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl isupper(int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _isupper_l(int, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl islower(int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _islower_l(int, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl isdigit(int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _isdigit_l(int, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl isxdigit(int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _isxdigit_l(int, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl isspace(int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _isspace_l(int, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl ispunct(int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _ispunct_l(int, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl isalnum(int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _isalnum_l(int, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl isprint(int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _isprint_l(int, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl isgraph(int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _isgraph_l(int, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl iscntrl(int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _iscntrl_l(int, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl toupper(int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl tolower(int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _tolower(int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _tolower_l(int, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _toupper(int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _toupper_l(int, _locale_t); } 
extern "C" { extern __declspec( dllimport ) int __cdecl __isascii(int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl __toascii(int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl __iscsymf(int); } 
extern "C" { extern __declspec( dllimport ) int __cdecl __iscsym(int); } 
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\locale.h"
#pragma pack ( push, 8 )
#line 59
extern "C" { struct lconv { friend struct __cilk_s;
char *decimal_point; 
char *thousands_sep; 
char *grouping; 
char *int_curr_symbol; 
char *currency_symbol; 
char *mon_decimal_point; 
char *mon_thousands_sep; 
char *mon_grouping; 
char *positive_sign; 
char *negative_sign; 
char int_frac_digits; 
char frac_digits; 
char p_cs_precedes; 
char p_sep_by_space; 
char n_cs_precedes; 
char n_sep_by_space; 
char p_sign_posn; 
char n_sign_posn; 
}; }
#line 103
extern "C" { extern __declspec( dllimport ) int __cdecl _configthreadlocale(int); } 
extern "C" { extern __declspec( dllimport ) char *__cdecl setlocale(int, const char *); } 
extern "C" { extern __declspec( dllimport ) lconv *__cdecl localeconv(); } 
extern "C" { extern __declspec( dllimport ) _locale_t __cdecl _get_current_locale(); } 
extern "C" { extern __declspec( dllimport ) _locale_t __cdecl _create_locale(int, const char *); } 
extern "C" { extern __declspec( dllimport ) void __cdecl _free_locale(_locale_t); } 


extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using _get_current_locale instead. See online help for details.")) _locale_t __cdecl __get_current_locale(); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using _create_locale instead. See online help for details.")) _locale_t __cdecl __create_locale(int, const char *); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using _free_locale instead. See online help for details.")) void __cdecl __free_locale(_locale_t); } 
#line 129
#pragma pack ( pop )
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocinfo.h"
#pragma pack ( push, 8 )
#line 57
extern "C" { typedef 
#line 53
struct _Collvec { friend struct __cilk_s;__CILK_METADATA(_Collvec, __CILK_VBASE_DETECT)

unsigned long _Hand; 
unsigned _Page; 
} _Collvec; }
#line 65
extern "C" { typedef 
#line 59
struct _Ctypevec { friend struct __cilk_s;__CILK_METADATA(_Ctypevec, __CILK_VBASE_DETECT)

unsigned long _Hand; 
unsigned _Page; 
const short *_Table; 
int _Delfl; 
} _Ctypevec; }
#line 71
extern "C" { typedef 
#line 67
struct _Cvtvec { friend struct __cilk_s;__CILK_METADATA(_Cvtvec, __CILK_VBASE_DETECT)

unsigned long _Hand; 
unsigned _Page; 
} _Cvtvec; }


extern "C" { extern __declspec( dllimport ) _Collvec __cdecl _Getcoll(); } 
extern "C" { extern __declspec( dllimport ) _Ctypevec __cdecl _Getctype(); } 
extern "C" { extern __declspec( dllimport ) _Cvtvec __cdecl _Getcvt(); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _Getdateorder(); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _Mbrtowc(__wchar_t *, const char *, size_t, mbstate_t *, const _Cvtvec *); } 

extern "C" { extern __declspec( dllimport ) float __cdecl _Stof(const char *, char **, long); } 
extern "C" { extern __declspec( dllimport ) double __cdecl _Stod(const char *, char **, long); } 
extern "C" { extern __declspec( dllimport ) long double __cdecl _Stold(const char *, char **, long); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _Strcoll(const char *, const char *, const char *, const char *, const _Collvec *); } 

extern "C" { extern __declspec( dllimport ) size_t __cdecl _Strxfrm(char *, char *, const char *, const char *, const _Collvec *); } 


extern "C" { extern __declspec( dllimport ) int __cdecl _Tolower(int, const _Ctypevec *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _Toupper(int, const _Ctypevec *); } 
extern "C" { extern __declspec( dllimport ) int __cdecl _Wcrtomb(char *, __wchar_t, mbstate_t *, const _Cvtvec *); } 

extern "C" { extern __declspec( dllimport ) int __cdecl _Wcscoll(const __wchar_t *, const __wchar_t *, const __wchar_t *, const __wchar_t *, const _Collvec *); } 

extern "C" { extern __declspec( dllimport ) size_t __cdecl _Wcsxfrm(__wchar_t *, __wchar_t *, const __wchar_t *, const __wchar_t *, const _Collvec *); } 



extern "C" { extern __declspec( dllimport ) short __cdecl _Getwctype(__wchar_t, const _Ctypevec *); } 
extern "C" { extern __declspec( dllimport ) const __wchar_t *__cdecl _Getwctypes(const __wchar_t *, const __wchar_t *, short *, const _Ctypevec *); } 

extern "C" { extern __declspec( dllimport ) __wchar_t __cdecl _Towlower(__wchar_t, const _Ctypevec *); } 
extern "C" { extern __declspec( dllimport ) __wchar_t __cdecl _Towupper(__wchar_t, const _Ctypevec *); } 
#line 112
extern "C" { extern __declspec( dllimport ) void *__cdecl _Gettnames(); } 
extern "C" { extern __declspec( dllimport ) char *__cdecl _Getdays(); } 
extern "C" { extern __declspec( dllimport ) char *__cdecl _Getmonths(); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl _Strftime(char *, size_t, const char *, const tm *, void *); } 
#line 121
extern "C" { extern _locale_t __cdecl _GetLocaleForCP(unsigned); } 
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocinfo"
#pragma warning(push,3)
#pragma warning(disable:4412)
#line 125 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocinfo.h"
#pragma pack ( pop )
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocinfo"
#pragma pack ( push, 8 )




namespace std { 


class __declspec( dllimport ) _Timevec { friend struct __cilk_s;__CILK_METADATA(_Timevec, __CILK_VBASE_DETECT)


public: inline _Timevec(void * = 0); 




inline _Timevec(const _Timevec &); 




inline __declspec( noinline ) ~_Timevec(); 




inline _Timevec &operator=(const _Timevec &); 
#line 44
inline void *_Getptr() const; 
#line 50
private: void *_Timeptr; 
}; 
#line 22
inline _Timevec::_Timevec(void *_Ptr) : _Timeptr(_Ptr) 

{ 
} 

inline _Timevec::_Timevec(const _Timevec &_Right) 
{ 
((*this) = _Right); 
} 

inline __declspec( noinline ) _Timevec::~_Timevec() 
{ 
free(this->_Timeptr); 
} 

inline _Timevec &_Timevec::operator=(const _Timevec &_Right) 
{ 
(this->_Timeptr) = _Right._Timeptr; 
(((_Timevec &)_Right)._Timeptr) = (0); 
return *this; 
} 

inline void *_Timevec::_Getptr() const 
{ 
return this->_Timeptr; 
} 
#line 56
#pragma warning(push)
#pragma warning(disable:4412)
class __declspec( dllimport ) _Locinfo { friend struct __cilk_s;__CILK_METADATA(_Locinfo, __CILK_VBASE_DETECT)


public: typedef ::_Collvec _Collvec; 
typedef ::_Ctypevec _Ctypevec; 
typedef ::_Cvtvec _Cvtvec; 
typedef std::_Timevec _Timevec; 

static void __cdecl _Locinfo_ctor(_Locinfo *, const char *); 
static void __cdecl _Locinfo_ctor(_Locinfo *, const string &); 
static void __cdecl _Locinfo_ctor(_Locinfo *, int, const char *); 
static void __cdecl _Locinfo_dtor(_Locinfo *); 
static _Locinfo &__cdecl _Locinfo_Addcats(_Locinfo *, int, const char *); 

inline __declspec( noinline ) _Locinfo(const char * = ("C")); 
#line 82
inline __declspec( noinline ) _Locinfo(int, const char *); 
#line 92
inline __declspec( noinline ) _Locinfo(const string &); 
#line 100
inline __declspec( noinline ) ~_Locinfo(); 




inline __declspec( noinline ) _Locinfo &_Addcats(int, const char *); 
#line 112
inline __declspec( noinline ) string _Getname() const; 




inline __declspec( noinline ) _Collvec _Getcoll() const; 




inline __declspec( noinline ) _Ctypevec _Getctype() const; 




inline __declspec( noinline ) _Cvtvec _Getcvt() const; 




inline __declspec( noinline ) const lconv *_Getlconv() const; 




inline __declspec( noinline ) _Timevec _Gettnames() const; 




inline __declspec( noinline ) const char *_Getdays() const; 
#line 155
inline __declspec( noinline ) const char *_Getmonths() const; 
#line 170
inline const char *_Getfalse() const; 




inline const char *_Gettrue() const; 




inline __declspec( noinline ) int _Getdateorder() const; 
#line 191
private: _Lockit _Lock; 

string _Days; 
string _Months; 
string _Oldlocname; 
string _Newlocname; 
}; 
#line 72
inline __declspec( noinline ) _Locinfo::_Locinfo(const char *_Pch) : _Lock(0) 



{ 
if (_Pch == (0)) { 
__cilk_s::throw0<runtime_error >( ((runtime_error)("bad locale name"))); }  
_Locinfo_ctor(this, _Pch); 
} 

inline __declspec( noinline ) _Locinfo::_Locinfo(int _I, const char *_Pch) : _Lock(0) 



{ 
if (_Pch == (0)) { 
__cilk_s::throw0<runtime_error >( ((runtime_error)("bad locale name"))); }  
_Locinfo_ctor(this, _I, _Pch); 
} 

inline __declspec( noinline ) _Locinfo::_Locinfo(const string &locstr) : _Lock(0) 



{ 
_Locinfo_ctor(this, locstr); 
} 

inline __declspec( noinline ) _Locinfo::~_Locinfo() 
{ 
_Locinfo_dtor(this); 
} 

inline __declspec( noinline ) _Locinfo &_Locinfo::_Addcats(int _I, const char *_Pch) 
{ 
if (_Pch == (0)) { 
__cilk_s::throw0<runtime_error >( ((runtime_error)("bad locale name"))); }  
return _Locinfo_Addcats(this, _I, _Pch); 
} 

inline __declspec( noinline ) string _Locinfo::_Getname() const 
{ 
return this->_Newlocname; 
} 

inline __declspec( noinline ) _Locinfo::_Collvec _Locinfo::_Getcoll() const 
{ 
return ::_Getcoll(); 
} 

inline __declspec( noinline ) _Locinfo::_Ctypevec _Locinfo::_Getctype() const 
{ 
return ::_Getctype(); 
} 

inline __declspec( noinline ) _Locinfo::_Cvtvec _Locinfo::_Getcvt() const 
{ 
return ::_Getcvt(); 
} 

inline __declspec( noinline ) const lconv *_Locinfo::_Getlconv() const 
{ 
return localeconv(); 
} 

inline __declspec( noinline ) _Locinfo::_Timevec _Locinfo::_Gettnames() const 
{ 
return ((_Timevec)(::_Gettnames())); 
} 

inline __declspec( noinline ) const char *_Locinfo::_Getdays() const 
{ 
auto const char *_Ptr = (::_Getdays()); 
if (_Ptr != (0)) 
{ 
((((_Locinfo &)(*this))._Days) = _Ptr); 
free((void *)_Ptr); 
}  
return ((this->_Days).size() != (0)) ? (this->_Days).c_str() : (":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday"); 


} 

inline __declspec( noinline ) const char *_Locinfo::_Getmonths() const 
{ 
auto const char *_Ptr = (::_Getmonths()); 
if (_Ptr != (0)) 
{ 
((((_Locinfo &)(*this))._Months) = _Ptr); 
free((void *)_Ptr); 
}  
return ((this->_Months).size() != (0)) ? (this->_Months).c_str() : (":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June:Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:De" "cember"); 




} 

inline const char *_Locinfo::_Getfalse() const 
{ 
return "false"; 
} 

inline const char *_Locinfo::_Gettrue() const 
{ 
return "true"; 
} 

inline __declspec( noinline ) int _Locinfo::_Getdateorder() const 
{ 
return ::_Getdateorder(); 
} 
#line 198
#pragma warning(pop)


template<class _Elem> inline int __cdecl 
_LStrcoll(const _Elem *, const _Elem *, const _Elem *, const _Elem *, const _Locinfo::_Collvec *); template<> inline __declspec( noinline ) int __cdecl _LStrcoll(const char *, const char *, const char *, const char *, const _Locinfo::_Collvec *); 
#line 215
template<> inline __declspec( noinline ) int __cdecl _LStrcoll(const char *_First1, const char *_Last1, const char *
_First2, const char *_Last2, const _Locinfo::_Collvec *
_Vector) 
{ 
return _Strcoll(_First1, _Last1, _First2, _Last2, _Vector); 
} 
#line 202
template<> inline __declspec( noinline ) int __cdecl _LStrcoll(const __wchar_t *, const __wchar_t *, const __wchar_t *, const __wchar_t *, const _Locinfo::_Collvec *); 
#line 223
template<> inline __declspec( noinline ) int __cdecl _LStrcoll(const __wchar_t *_First1, const __wchar_t *_Last1, const __wchar_t *
_First2, const __wchar_t *_Last2, const _Locinfo::_Collvec *
_Vector) 
{ 
return _Wcscoll(_First1, _Last1, _First2, _Last2, _Vector); 
} 


template<class _Elem> inline size_t __cdecl 
_LStrxfrm(_Elem *, _Elem *, const _Elem *, const _Elem *, const _Locinfo::_Collvec *); template<> inline __declspec( noinline ) size_t __cdecl _LStrxfrm(char *, char *, const char *, const char *, const _Locinfo::_Collvec *); 
#line 243
template<> inline __declspec( noinline ) size_t __cdecl _LStrxfrm(char *
_First1, char *
_Last1, const char *
_First2, const char *_Last2, const _Locinfo::_Collvec *
_Vector) 
{ 
return _Strxfrm(_First1, _Last1, _First2, _Last2, _Vector); 
} 
#line 232
template<> inline __declspec( noinline ) size_t __cdecl _LStrxfrm(__wchar_t *, __wchar_t *, const __wchar_t *, const __wchar_t *, const _Locinfo::_Collvec *); 
#line 253
template<> inline __declspec( noinline ) size_t __cdecl _LStrxfrm(__wchar_t *
_First1, __wchar_t *
_Last1, const __wchar_t *
_First2, const __wchar_t *_Last2, const _Locinfo::_Collvec *
_Vector) 
{ 
return _Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector); 
} 
}

#pragma warning(pop)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocale"
#pragma warning(push,3)
#pragma warning(disable:4412)
#line 264 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocinfo"
#pragma pack ( pop )
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocale"
#pragma pack ( push, 8 )




namespace std { 


template<class _Dummy> 
class _Locbase { friend struct __cilk_s;__CILK_METADATA(_Locbase, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


static const int collate = ((1 << 1) >> 1); 
static const int ctype = ((1 << 2) >> 1); 
static const int monetary = ((1 << 3) >> 1); 
static const int numeric = ((1 << 4) >> 1); 
static const int time = ((1 << 5) >> 1); 
static const int messages = ((1 << 6) >> 1); 
static const int all = (((1 << 7) >> 1) - 1); 
static const int none = 0; 
}; 
#line 54
class __declspec( dllimport ) locale; 
template<class _Facet> inline const _Facet &__cdecl use_facet(const locale &); 



#pragma warning(push)
#pragma warning(disable:4412)
class __declspec( dllimport ) locale : public _Locbase< int>  { friend struct __cilk_s;__CILK_METADATA(locale, __CILK_VBASE_DETECT)



public: typedef int category; 


class __declspec( dllimport ) id { friend struct __cilk_s;__CILK_METADATA(id, __CILK_VBASE_DETECT)


public: inline id(size_t = (0)); 




inline __declspec( noinline ) operator size_t(); 
#line 89
private: id(const id &); 
id &operator=(const id &); 

size_t _Id; 
static int &__cdecl _Id_cnt_func(); 



static int _Id_cnt; 

}; 

class __declspec( dllimport ) _Locimp; 


class facet { friend struct __cilk_s;__CILK_METADATA(facet, __CILK_VBASE_DETECT)

friend class locale; 
friend class _Locimp; 


public: static inline __declspec( dllimport ) size_t _Getcat(const facet ** = 0, const locale * = 0); 
#line 116
inline __declspec( dllimport noinline ) void _Incref(); 
#line 124
inline __declspec( dllimport noinline ) facet *_Decref(); 
#line 133
inline void _Register(); 
#line 169
inline virtual __declspec( dllimport ) ~facet(); 




protected: inline explicit __declspec( dllimport ) facet(size_t = (0)); 
#line 183
private: static void facet_Register(facet *); 


facet(const facet &); 
facet &operator=(const facet &); 

size_t _Refs; 
}; 

#pragma warning(push)
#pragma warning(disable:4275)

class __declspec( dllimport ) _Locimp : public facet { friend struct __cilk_s;__CILK_METADATA(_Locimp, __CILK_VBASE_DETECT)



protected: inline virtual __declspec( noinline ) ~_Locimp(); 
#line 205
private: static void __cdecl _Locimp_dtor(_Locimp *); 
static void _Locimp_ctor(_Locimp *, const _Locimp &); 
static void __cdecl _Locimp_Addfac(_Locimp *, facet *, size_t); 
friend class locale; 

inline __declspec( noinline ) _Locimp(bool = false); 




inline __declspec( noinline ) _Locimp(const _Locimp &); 
#line 222
inline __declspec( noinline ) void _Addfac(facet *, size_t); 




static _Locimp *_Makeloc(const _Locinfo &, category, _Locimp *, const locale *); 


static void _Makewloc(const _Locinfo &, category, _Locimp *, const locale *); 



static void _Makeushloc(const _Locinfo &, category, _Locimp *, const locale *); 



static void _Makexloc(const _Locinfo &, category, _Locimp *, const locale *); 


facet **_Facetvec; 
size_t _Facetcount; 
category _Catmask; 
bool _Xparent; 
string _Name; 

static _Locimp *&__cdecl _Clocptr_func(); 



static _Locimp *_Clocptr; 


_Locimp &operator=(const _Locimp &); 

}; 
#pragma warning(pop)

inline __declspec( noinline ) __declspec(deprecated("This is an obsolete part of the Standard C++ Library Implementation. Do not use it.")) locale &_Addfac(facet *, size_t, size_t); 
#line 275
template<class _Elem, class 
_Traits, class 
_Alloc> inline bool 
operator()(const basic_string< _Elem, _Traits, _Alloc>  &, const basic_string< _Elem, _Traits, _Alloc>  &) const; 
#line 275
template<class _Elem, class 
_Traits, class 
_Alloc> inline bool  /* __cilk */ __thiscall 
__cilk_op_function_call(__cilk_box<const basic_string< _Elem, _Traits, _Alloc>  & > , __cilk_box<const basic_string< _Elem, _Traits, _Alloc>  & > ) const; 
#line 288
template<class _Facet> inline locale 
combine(const locale &) const; 
#line 288
template<class _Facet> inline locale  /* __cilk */ __thiscall 
__cilkfun_combine(__cilk_box<const locale & > ) const; 
#line 306
template<class _Facet> inline 
locale(const locale &, const _Facet *); 
#line 306
template<class _Facet> inline  /* __cilk */ __thiscall 
locale(__cilk_box<const locale & > , __cilk_box<const _Facet * > ); 
#line 322
inline __declspec( noinline ) locale() throw(); 
#line 328
inline locale(_Uninitialized); 



inline __declspec( noinline ) locale(const locale &) throw(); 
#line 338
inline __declspec( noinline ) locale(const locale &, const locale &, category); 
#line 353
inline explicit __declspec( noinline ) locale(const char *, category = (all)); 
#line 370
inline __declspec( noinline ) locale(const locale &, const char *, category); 
#line 389
inline __declspec( noinline ) ~locale() throw(); 
#line 395
inline __declspec( noinline ) locale &operator=(const locale &) throw(); 
#line 406
inline __declspec( noinline ) string name() const; 




inline __declspec( noinline ) const facet *_Getfacet(size_t) const; 
#line 427
inline __declspec( noinline ) bool operator==(const locale &) const; 
#line 433
inline bool operator!=(const locale &) const; 




static const locale &__cdecl classic(); 

static locale __cdecl global(const locale &); 

static locale __cdecl empty(); 


private: inline locale(_Locimp *); 




static _Locimp *__cdecl _Getgloballocale(); 
static _Locimp *__cdecl _Init(); 
static void __cdecl _Setgloballocale(void *); 

_Locimp *_Ptr; 
}; 
#line 71
inline locale::id::id(size_t _Val) : _Id(_Val) 

{ 
} 

inline __declspec( noinline ) locale::id::operator size_t() 
{ 
if (this->_Id == (0)) 
{ 
{ auto _Lockit _Lock(0); 
if (this->_Id == (0)) { 
(this->_Id) = ++_Id_cnt; }  
} 
}  
return this->_Id; 
} 
#line 110
inline __declspec( dllimport ) size_t locale::facet::_Getcat(const facet **__T16534896, const locale *__T16534988) 

{ 
return (size_t)(-1); 
} 

inline __declspec( dllimport noinline ) void locale::facet::_Incref() 
{ 
{ auto _Lockit _Lock(0); 
if (this->_Refs < ((size_t)(-1))) { 
++(this->_Refs); }  
} 
} 

inline __declspec( dllimport noinline ) locale::facet *locale::facet::_Decref() 
{ 
{ auto _Lockit _Lock(0); 
if (((0) < this->_Refs) && (this->_Refs < ((size_t)(-1)))) { 
--(this->_Refs); }  
return (this->_Refs == (0)) ? this : (0); 
} 
} 

inline void locale::facet::_Register() 
{ 



facet_Register(this); 

} 
#line 169
inline __declspec( dllimport ) locale::facet::~facet() 
{ 
} 


inline __declspec( dllimport ) locale::facet::facet(size_t _Initrefs) : _Refs(_Initrefs) 

{ 
} 
#line 199
inline __declspec( noinline ) locale::_Locimp::~_Locimp() 
{ 
_Locimp_dtor(this); 
} 
#line 210
inline __declspec( noinline ) locale::_Locimp::_Locimp(bool _Transparent) : facet(1), _Facetvec((0)), _Facetcount((0)), _Catmask((none)), _Xparent(_Transparent), _Name("*") 


{ } 

inline __declspec( noinline ) locale::_Locimp::_Locimp(const _Locimp &_Right) : facet(1), _Facetvec((0)), _Facetcount((_Right._Facetcount)), _Catmask((_Right._Catmask)), _Xparent((_Right._Xparent)), _Name(_Right._Name) 


{ 
_Locimp_ctor(this, _Right); 
} 

inline __declspec( noinline ) void locale::_Locimp::_Addfac(facet *_Pfacet, size_t _Id) 
{ 
_Locimp_Addfac(this, _Pfacet, _Id); 
} 
#line 259
inline __declspec( noinline ) __declspec(deprecated("This is an obsolete part of the Standard C++ Library Implementation. Do not use it.")) locale &locale::_Addfac(facet *_Fac, size_t _Id, size_t 
_Catmask) 
{ 
if ((1) < (*(this->_Ptr))._Refs) 
{ 
(*(this->_Ptr))._Decref(); 
(this->_Ptr) = (new _Locimp(*(this->_Ptr))); 
}  
(*(this->_Ptr))._Addfac(_Fac, _Id); 

if (_Catmask != (0)) { 
(((*(this->_Ptr))._Name) = (("*"))); }  
return *this; 
} 
#line 322
inline __declspec( noinline ) locale::locale() throw() : _Ptr(_Init()) 

{ 
(*_Getgloballocale())._Incref(); 
} 

inline locale::locale(_Uninitialized __T16552076) 
{ 
} 

inline __declspec( noinline ) locale::locale(const locale &_Right) throw() : _Ptr((_Right._Ptr)) 

{ 
(*(this->_Ptr))._Incref(); 
} 

inline __declspec( noinline ) locale::locale(const locale &_Loc, const locale &_Other, category 
_Cat) : _Ptr((new _Locimp(*(_Loc._Ptr)))) 

{ 
try { 
{ auto _Locinfo _Lobj((*(_Loc._Ptr))._Catmask, ((*(_Loc._Ptr))._Name).c_str()); 
_Locimp::_Makeloc(_Lobj._Addcats(_Cat & (*(_Other._Ptr))._Catmask, ((*(_Other._Ptr))._Name).c_str()), _Cat, this->_Ptr, (&_Other)); 

} 
} catch (...) { 
delete (*(this->_Ptr))._Decref(); 
__cilk_s::rethrow(); 
}  
} 

inline __declspec( noinline ) locale::locale(const char *_Locname, category 
_Cat) : _Ptr((new _Locimp)) 

{ 
try { 
_Init(); 
{ auto _Locinfo _Lobj(_Cat, _Locname); 
if (_Lobj._Getname().compare("*") == 0) { 
__cilk_s::throw0<runtime_error >( ((runtime_error)("bad locale name"))); }  
_Locimp::_Makeloc(_Lobj, _Cat, this->_Ptr, 0); 
} 
} catch (...) { 
delete (*(this->_Ptr))._Decref(); 
__cilk_s::rethrow(); 
}  
} 

inline __declspec( noinline ) locale::locale(const locale &_Loc, const char *_Locname, category 
_Cat) : _Ptr((new _Locimp(*(_Loc._Ptr)))) 

{ 
try { 
{ auto _Locinfo _Lobj((*(_Loc._Ptr))._Catmask, ((*(_Loc._Ptr))._Name).c_str()); 
auto bool _Hadname = (_Lobj._Getname().compare("*") != 0); 
_Lobj._Addcats(_Cat, _Locname); 

if (_Hadname && (_Lobj._Getname().compare("*") == 0)) { 
__cilk_s::throw0<runtime_error >( ((runtime_error)("bad locale name"))); }  
_Locimp::_Makeloc(_Lobj, _Cat, this->_Ptr, 0); 
} 
} catch (...) { 
delete (*(this->_Ptr))._Decref(); 
__cilk_s::rethrow(); 
}  
} 

inline __declspec( noinline ) locale::~locale() throw() 
{ 
if (this->_Ptr != (0)) { 
delete (*(this->_Ptr))._Decref(); }  
} 

inline __declspec( noinline ) locale &locale::operator=(const locale &_Right) throw() 
{ 
if (this->_Ptr != _Right._Ptr) 
{ 
delete (*(this->_Ptr))._Decref(); 
(this->_Ptr) = _Right._Ptr; 
(*(this->_Ptr))._Incref(); 
}  
return *this; 
} 

inline __declspec( noinline ) string locale::name() const 
{ 
return (*(this->_Ptr))._Name; 
} 

inline __declspec( noinline ) const locale::facet *locale::_Getfacet(size_t _Id) const 
{ 
auto const facet *_Facptr = ((_Id < (*(this->_Ptr))._Facetcount) ? (((*(this->_Ptr))._Facetvec)[_Id]) : (0)); 

if ((_Facptr != (0)) || (!((*(this->_Ptr))._Xparent))) { 
return _Facptr; } else 

{ 
auto _Locimp *_Ptr = _Getgloballocale(); 
return (_Id < _Ptr->_Facetcount) ? ((_Ptr->_Facetvec)[_Id]) : (0); 


}  
} 


inline __declspec( noinline ) bool locale::operator==(const locale &_Loc) const 
{ 
return (this->_Ptr == _Loc._Ptr) || ((this->name().compare("*") != 0) && (this->name().compare(_Loc.name()) == 0)); 

} 

inline bool locale::operator!=(const locale &_Right) const 
{ 
return !((*this) == _Right); 
} 
#line 445
inline locale::locale(_Locimp *_Ptrimp) : _Ptr(_Ptrimp) 

{ 
} 
#line 456
#pragma warning(pop)


template<class _Facet> 
struct _Facetptr { friend struct __cilk_s;__CILK_METADATA(_Facetptr, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

static const locale::facet *_Psave; 
}; 




template<class _Facet> inline __declspec(deprecated("This is an obsolete part of the Standard C++ Library Implementation. Do not use it.")) locale 
_Addfac(locale, const _Facet *); 
#line 468
template<class _Facet> inline __declspec(deprecated("This is an obsolete part of the Standard C++ Library Implementation. Do not use it.")) locale  /* __cilk */ __cdecl 
__cilkfun__Addfac(__cilk_box<locale > , __cilk_box<const _Facet * > ); 
#line 482
template<class _Facet> inline const _Facet &__cdecl 
use_facet(const locale &); 
#line 521
template<class _Facet> inline __declspec(deprecated("This is an obsolete part of the Standard C++ Library Implementation. Do not use it.")) const _Facet &__cdecl 
use_facet(const locale &, const _Facet *, bool = false); 
#line 529
template<class _Elem, class 
_InIt> inline int __cdecl 
_Getloctxt(_InIt &, _InIt &, size_t, const _Elem *); 
#line 577
template<class _Elem> inline char __cdecl 
_Maklocbyte(_Elem, const _Locinfo::_Cvtvec &); template<> inline __declspec( noinline ) char __cdecl _Maklocbyte(__wchar_t, const _Locinfo::_Cvtvec &); 
#line 585
template<> inline __declspec( noinline ) char __cdecl _Maklocbyte(__wchar_t _Char, const _Locinfo::_Cvtvec &
_Cvt) 
{ 
auto char _Byte = '\000'; 
auto mbstate_t _Mbst1 = (0); 
_Wcrtomb(&_Byte, _Char, &_Mbst1, (&_Cvt)); 
return _Byte; 
} 
#line 599
template<class _Elem> inline _Elem __cdecl 
_Maklocchr(char, _Elem *, const _Locinfo::_Cvtvec &); template<> inline __declspec( noinline ) __wchar_t __cdecl _Maklocchr(char, __wchar_t *, const _Locinfo::_Cvtvec &); 
#line 607
template<> inline __declspec( noinline ) __wchar_t __cdecl _Maklocchr(char _Byte, __wchar_t *__T16582340, const _Locinfo::_Cvtvec &
_Cvt) 
{ 
auto __wchar_t _Wc = L'\x0'; 
auto mbstate_t _Mbst1 = (0); 
_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, (&_Cvt)); 
return _Wc; 
} 
#line 621
template<class _Elem> inline _Elem *__cdecl 
_Maklocstr(const char *, _Elem *, const _Locinfo::_Cvtvec &); template<> inline __declspec( noinline ) __wchar_t *__cdecl _Maklocstr(const char *, __wchar_t *, const _Locinfo::_Cvtvec &); 
#line 638
template<> inline __declspec( noinline ) __wchar_t *__cdecl _Maklocstr(const char *_Ptr, __wchar_t *__T16597444, const _Locinfo::_Cvtvec &
_Cvt) 
{ 
auto size_t _Count; auto size_t _Count1; 
auto size_t _Wchars; 
auto const char *_Ptr1; 
auto int _Bytes; 
auto __wchar_t _Wc; 
auto mbstate_t _Mbst1 = (0); 

_Count1 = ::strlen(_Ptr) + (1); 
for (((_Count = _Count1), (_Wchars = (0))), (_Ptr1 = _Ptr); (0) < _Count; ((_Count -= _Bytes), (_Ptr1 += _Bytes)), (++_Wchars)) { 

if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, (&_Cvt))) <= 0) { 
break; }  }  
++_Wchars; 

auto __wchar_t *_Ptrdest = (new __wchar_t [_Wchars]); 
auto __wchar_t *_Ptrnext = _Ptrdest; 
auto mbstate_t _Mbst2 = (0); 
#pragma warning(push)
#pragma warning(disable: 6011)

for (; (0) < _Wchars; (((_Count -= _Bytes), (_Ptr += _Bytes)), (--_Wchars)), (++_Ptrnext)) { 

if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, (&_Cvt))) <= 0) { 
break; }  }  
(*_Ptrnext) = L'\x0'; 
#pragma warning(pop)
return _Ptrdest; 
} 


#pragma warning(push)
#pragma warning(disable:4275)

class __declspec( dllimport ) codecvt_base : public locale::facet { friend struct __cilk_s;__CILK_METADATA(codecvt_base, __CILK_VBASE_DETECT)




public: enum { 
ok, partial, error, noconv}; 
typedef int result; 

inline __declspec( noinline ) codecvt_base(size_t = (0)); 




inline __declspec( noinline ) bool always_noconv() const throw(); 




inline __declspec( noinline ) int max_length() const throw(); 




inline __declspec( noinline ) int encoding() const throw(); 




inline virtual __declspec( noinline ) ~codecvt_base(); 




protected: inline virtual bool do_always_noconv() const throw(); 




inline virtual int do_max_length() const throw(); 




inline virtual int do_encoding() const throw(); 



}; 
#line 683
inline __declspec( noinline ) codecvt_base::codecvt_base(size_t _Refs) : locale::facet(_Refs) 

{ 
} 

inline __declspec( noinline ) bool codecvt_base::always_noconv() const throw() 
{ 
return this->do_always_noconv(); 
} 

inline __declspec( noinline ) int codecvt_base::max_length() const throw() 
{ 
return this->do_max_length(); 
} 

inline __declspec( noinline ) int codecvt_base::encoding() const throw() 
{ 
return this->do_encoding(); 
} 

inline __declspec( noinline ) codecvt_base::~codecvt_base() 
{ 
} 


inline bool codecvt_base::do_always_noconv() const throw() 
{ 
return true; 
} 

inline int codecvt_base::do_max_length() const throw() 
{ 
return 1; 
} 

inline int codecvt_base::do_encoding() const throw() 
{ 
return 1; 
} 

#pragma warning(pop)


template<class _Elem, class 
_Byte, class 
_Statype> 
class codecvt : public codecvt_base { friend struct __cilk_s;__CILK_METADATA(codecvt, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



typedef _Elem intern_type; 
typedef _Byte extern_type; 
typedef _Statype state_type; 

inline result in(_Statype &, const _Byte *, const _Byte *, const _Byte *&, _Elem *, _Elem *, _Elem *&) const; inline result  /* __cilk */ __thiscall __cilkfun_in(__cilk_box<_Statype & > , __cilk_box<const _Byte * > , __cilk_box<const _Byte * > , __cilk_box<const _Byte *& > , __cilk_box<_Elem * > , __cilk_box<_Elem * > , __cilk_box<_Elem *& > ) const; 
#line 745
inline result out(_Statype &, const _Elem *, const _Elem *, const _Elem *&, _Byte *, _Byte *, _Byte *&) const; inline result  /* __cilk */ __thiscall __cilkfun_out(__cilk_box<_Statype & > , __cilk_box<const _Elem * > , __cilk_box<const _Elem * > , __cilk_box<const _Elem *& > , __cilk_box<_Byte * > , __cilk_box<_Byte * > , __cilk_box<_Byte *& > ) const; 
#line 753
inline result unshift(_Statype &, _Byte *, _Byte *, _Byte *&) const; inline result  /* __cilk */ __thiscall __cilkfun_unshift(__cilk_box<_Statype & > , __cilk_box<_Byte * > , __cilk_box<_Byte * > , __cilk_box<_Byte *& > ) const; 
#line 759
inline int length(const _Statype &, const _Byte *, const _Byte *, size_t) const; inline int  /* __cilk */ __thiscall __cilkfun_length(__cilk_box<const _Statype & > , __cilk_box<const _Byte * > , __cilk_box<const _Byte * > , __cilk_box<unsigned > ) const; 
#line 765
static locale::id id; 

inline explicit codecvt(typename __cilk_maybe_box<codecvt, unsigned >::type  = (__cilk_maybe_box<codecvt, size_t >::type (0))); 
#line 775
inline codecvt(const _Locinfo &, size_t = (0)); inline  /* __cilk */ __thiscall codecvt(__cilk_box<const _Locinfo & > , __cilk_box<unsigned >  = (__cilk_box<unsigned >(0))); 
#line 781
static inline size_t _Getcat(const locale::facet ** = 0, const locale * = 0); static inline size_t  /* __cilk */ __cdecl __cilkfun__Getcat(__cilk_box<const locale::facet ** >  = (__cilk_box<const locale::facet ** >(0)), __cilk_box<const locale * >  = (__cilk_box<const locale * >(0))); 
#line 791
protected: inline virtual ~codecvt(); 




inline void _Init(const _Locinfo &); inline void  /* __cilk */ __thiscall __cilkfun__Init(__cilk_box<const _Locinfo & > ); 



inline virtual result do_in(typename __cilk_maybe_box<codecvt, _Statype & >::type , typename __cilk_maybe_box<codecvt, const _Byte * >::type , typename __cilk_maybe_box<codecvt, const _Byte * >::type , typename __cilk_maybe_box<codecvt, const _Byte *& >::type , typename __cilk_maybe_box<codecvt, _Elem * >::type , typename __cilk_maybe_box<codecvt, _Elem * >::type , typename __cilk_maybe_box<codecvt, _Elem *& >::type ) const; 
#line 808
inline virtual result do_out(typename __cilk_maybe_box<codecvt, _Statype & >::type , typename __cilk_maybe_box<codecvt, const _Elem * >::type , typename __cilk_maybe_box<codecvt, const _Elem * >::type , typename __cilk_maybe_box<codecvt, const _Elem *& >::type , typename __cilk_maybe_box<codecvt, _Byte * >::type , typename __cilk_maybe_box<codecvt, _Byte * >::type , typename __cilk_maybe_box<codecvt, _Byte *& >::type ) const; 
#line 816
inline virtual result do_unshift(typename __cilk_maybe_box<codecvt, _Statype & >::type , typename __cilk_maybe_box<codecvt, _Byte * >::type , typename __cilk_maybe_box<codecvt, _Byte * >::type , typename __cilk_maybe_box<codecvt, _Byte *& >::type ) const; 
#line 823
inline virtual int do_length(typename __cilk_maybe_box<codecvt, const _Statype & >::type , typename __cilk_maybe_box<codecvt, const _Byte * >::type , typename __cilk_maybe_box<codecvt, const _Byte * >::type , typename __cilk_maybe_box<codecvt, unsigned >::type ) const; 
#line 829
}; 
#line 838
template<> class __declspec( dllimport ) codecvt< __wchar_t, char, int>  : public codecvt_base { friend struct __cilk_s;__CILK_METADATA(codecvt, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



typedef __wchar_t _Elem; 
typedef char _Byte; 
typedef _Mbstatet _Statype; 
typedef _Elem intern_type; 
typedef _Byte extern_type; 
typedef _Statype state_type; 

inline __declspec( noinline ) result in(_Statype &, const _Byte *, const _Byte *, const _Byte *&, _Elem *, _Elem *, _Elem *&) const; 
#line 857
inline __declspec( noinline ) result out(_Statype &, const _Elem *, const _Elem *, const _Elem *&, _Byte *, _Byte *, _Byte *&) const; 
#line 865
inline __declspec( noinline ) result unshift(_Statype &, _Byte *, _Byte *, _Byte *&) const; 
#line 872
inline __declspec( noinline ) int length(const _Statype &, const _Byte *, const _Byte *, size_t) const; 
#line 878
static locale::id &__cdecl _Id_func(); 



static locale::id id; 


inline explicit __declspec( noinline ) codecvt(size_t = (0)); 
#line 893
inline __declspec( noinline ) codecvt(const _Locinfo &, size_t = (0)); 
#line 899
static inline size_t _Getcat(const locale::facet ** = 0, const locale * = 0); 
#line 909
protected: inline virtual __declspec( noinline ) ~codecvt(); 




inline void _Init(const _Locinfo &); 




inline virtual __declspec( noinline ) result do_in(_Statype &, const _Byte *, const _Byte *, const _Byte *&, _Elem *, _Elem *, _Elem *&) const; 
#line 955
inline virtual __declspec( noinline ) result do_out(_Statype &, const _Elem *, const _Elem *, const _Elem *&, _Byte *, _Byte *, _Byte *&) const; 
#line 994
inline virtual __declspec( noinline ) result do_unshift(_Statype &, _Byte *, _Byte *, _Byte *&) const; 
#line 1019
inline virtual __declspec( noinline ) int do_length(const _Statype &, const _Byte *, const _Byte *, size_t) const; 
#line 1064
inline virtual bool do_always_noconv() const throw(); 




inline virtual int do_max_length() const throw(); 
#line 1075
private: _Locinfo::_Cvtvec _Cvt; 
}; 
#line 849
inline __declspec( noinline ) codecvt_base::result codecvt< __wchar_t, char, int> ::in(_Statype &_State, const _Byte *
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
{ 
return this->do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 

} 

inline __declspec( noinline ) codecvt_base::result codecvt< __wchar_t, char, int> ::out(_Statype &_State, const _Elem *
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
return this->do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 

} 

inline __declspec( noinline ) codecvt_base::result codecvt< __wchar_t, char, int> ::unshift(_Statype &_State, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
return this->do_unshift(_State, _First2, _Last2, _Mid2); 

} 

inline __declspec( noinline ) int codecvt< __wchar_t, char, int> ::length(const _Statype &_State, const _Byte *_First1, const _Byte *
_Last1, size_t _Count) const 
{ 
return this->do_length(_State, _First1, _Last1, _Count); 
} 
#line 885
inline __declspec( noinline ) codecvt< __wchar_t, char, int> ::codecvt(size_t _Refs) : codecvt_base(_Refs) 

{ 
{ auto _Locinfo _Lobj; 
this->_Init(_Lobj); 
} 
} 

inline __declspec( noinline ) codecvt< __wchar_t, char, int> ::codecvt(const _Locinfo &_Lobj, size_t _Refs) : codecvt_base(_Refs) 

{ 
this->_Init(_Lobj); 
} 

inline size_t codecvt< __wchar_t, char, int> ::_Getcat(const locale::facet **_Ppf, const locale *
_Ploc) 
{ 
if ((_Ppf != (0)) && (*_Ppf == (0))) { 
(*_Ppf) = (new std::codecvt< __wchar_t, char, int> (((_Locinfo)(_Ploc->name())))); }  

return 2; 
} 


inline __declspec( noinline ) codecvt< __wchar_t, char, int> ::~codecvt() 
{ 
} 


inline void codecvt< __wchar_t, char, int> ::_Init(const _Locinfo &_Lobj) 
{ 
(this->_Cvt) = _Lobj._Getcvt(); 
} 

inline __declspec( noinline ) codecvt_base::result codecvt< __wchar_t, char, int> ::do_in(_Statype &_State, const _Byte *
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
{ 
; 
; 
(_Mid1 = _First1), (_Mid2 = _First2); 
auto result _Ans = ((_Mid1 == _Last1) ? ok : partial); 
auto int _Bytes; 

while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, _Last1 - _Mid1, (&_State), &(this->_Cvt))) 

{ 
case (-2): 
_Mid1 = _Last1; 
return _Ans; 

case (-1): 
return error; 

case 0: 
if (*(_Mid2) == ((_Elem)0)) { 
_Bytes = (int)::strlen(_Mid1) + 1; }  


default: 
if (_Bytes == (-3)) { 
_Bytes = 0; }  
_Mid1 += _Bytes; 
++_Mid2; 
_Ans = (ok); break;
}  }  
return _Ans; 
} 

inline __declspec( noinline ) codecvt_base::result codecvt< __wchar_t, char, int> ::do_out(_Statype &_State, const _Elem *
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
; 
; 
(_Mid1 = _First1), (_Mid2 = _First2); 
auto result _Ans = ((_Mid1 == _Last1) ? ok : partial); 
auto int _Bytes; 

while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
if ((int)___mb_cur_max_func() <= _Last2 - _Mid2) { 
if ((_Bytes = _Wcrtomb(_Mid2, *(_Mid1), (&_State), &(this->_Cvt))) < 0) { 

return error; } else { 

((++_Mid1), (_Mid2 += _Bytes)), (_Ans = (ok)); }  } else 

{ 
auto _Byte _Buf[5]; 
auto _Statype _Stsave = (_State); 

if ((_Bytes = _Wcrtomb(_Buf, *(_Mid1), (&_State), &(this->_Cvt))) < 0) { 

return error; } else { 
if (_Last2 - _Mid2 < _Bytes) 
{ 
_State = _Stsave; 
return _Ans; 
} else 

{ 
::memcpy_s(_Mid2, _Last2 - _Mid2, _Buf, _Bytes); 
((++_Mid1), (_Mid2 += _Bytes)), (_Ans = (ok)); 
}  }  
}  }  
return _Ans; 
} 

inline __declspec( noinline ) codecvt_base::result codecvt< __wchar_t, char, int> ::do_unshift(_Statype &_State, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
; 
_Mid2 = _First2; 
auto result _Ans = (ok); 
auto int _Bytes; 
auto _Byte _Buf[5]; 
auto _Statype _Stsave = (_State); 

if ((_Bytes = _Wcrtomb(_Buf, L'\x0', (&_State), &(this->_Cvt))) <= 0) { 
_Ans = (error); } else { 
if (_Last2 - _Mid2 < --_Bytes) 
{ 
_State = _Stsave; 
_Ans = (partial); 
} else { 
if (0 < _Bytes) 
{ 
::memcpy_s(_Mid2, _Last2 - _Mid2, _Buf, _Bytes); 
_Mid2 += _Bytes; 
}  }  }  
return _Ans; 
} 

inline __declspec( noinline ) int codecvt< __wchar_t, char, int> ::do_length(const _Statype &_State, const _Byte *_First1, const _Byte *
_Last1, size_t _Count) const 
{ 
#line 1028
; 
auto int _Wchars; 
auto const _Byte *_Mid1; 
auto _Statype _Mystate = (_State); 

for ((_Wchars = 0), (_Mid1 = _First1); ((size_t)_Wchars < _Count) && (_Mid1 != _Last1);) 

{ 
auto int _Bytes; 
auto _Elem _Ch; 

switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, _Last1 - _Mid1, &_Mystate, &(this->_Cvt))) 

{ 
case (-2): 
return _Wchars; 

case (-1): 
return _Wchars; 

case 0: 
if (_Ch == ((_Elem)0)) { 
_Bytes = (int)::strlen(_Mid1) + 1; }  


default: 
if (_Bytes == (-3)) { 
_Bytes = 0; }  
_Mid1 += _Bytes; 
++_Wchars; break;
}  
}  
return _Wchars; 

} 

inline bool codecvt< __wchar_t, char, int> ::do_always_noconv() const throw() 
{ 
return false; 
} 

inline int codecvt< __wchar_t, char, int> ::do_max_length() const throw() 
{ 
return 5; 
} 
#line 1080
template<> class __declspec( dllimport ) codecvt< unsigned short, char, int>  : public codecvt_base { friend struct __cilk_s;__CILK_METADATA(codecvt, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



typedef unsigned short _Elem; 
typedef char _Byte; 
typedef _Mbstatet _Statype; 
typedef _Elem intern_type; 
typedef _Byte extern_type; 
typedef _Statype state_type; 

inline __declspec( noinline ) result in(_Statype &, const _Byte *, const _Byte *, const _Byte *&, _Elem *, _Elem *, _Elem *&) const; 
#line 1099
inline __declspec( noinline ) result out(_Statype &, const _Elem *, const _Elem *, const _Elem *&, _Byte *, _Byte *, _Byte *&) const; 
#line 1107
inline __declspec( noinline ) result unshift(_Statype &, _Byte *, _Byte *, _Byte *&) const; 
#line 1114
inline __declspec( noinline ) int length(const _Statype &, const _Byte *, const _Byte *, size_t) const; 
#line 1120
static locale::id &__cdecl _Id_func(); 



static locale::id id; 


inline explicit __declspec( noinline ) codecvt(size_t = (0)); 
#line 1135
inline __declspec( noinline ) codecvt(const _Locinfo &, size_t = (0)); 
#line 1141
static inline size_t _Getcat(const locale::facet ** = 0, const locale * = 0); 
#line 1151
protected: inline virtual __declspec( noinline ) ~codecvt(); 




inline __declspec( noinline ) codecvt(const char *, size_t = (0)); 
#line 1164
inline void _Init(const _Locinfo &); 




inline virtual __declspec( noinline ) result do_in(_Statype &, const _Byte *, const _Byte *, const _Byte *&, _Elem *, _Elem *, _Elem *&) const; 
#line 1205
inline virtual __declspec( noinline ) result do_out(_Statype &, const _Elem *, const _Elem *, const _Elem *&, _Byte *, _Byte *, _Byte *&) const; 
#line 1244
inline virtual __declspec( noinline ) result do_unshift(_Statype &, _Byte *, _Byte *, _Byte *&) const; 
#line 1269
inline virtual __declspec( noinline ) int do_length(const _Statype &, const _Byte *, const _Byte *, size_t) const; 
#line 1307
inline virtual bool do_always_noconv() const throw(); 




inline virtual int do_max_length() const throw(); 
#line 1318
private: _Locinfo::_Cvtvec _Cvt; 
}; 
#line 1091
inline __declspec( noinline ) codecvt_base::result codecvt< unsigned short, char, int> ::in(_Statype &_State, const _Byte *
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
{ 
return this->do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 

} 

inline __declspec( noinline ) codecvt_base::result codecvt< unsigned short, char, int> ::out(_Statype &_State, const _Elem *
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
return this->do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 

} 

inline __declspec( noinline ) codecvt_base::result codecvt< unsigned short, char, int> ::unshift(_Statype &_State, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
return this->do_unshift(_State, _First2, _Last2, _Mid2); 

} 

inline __declspec( noinline ) int codecvt< unsigned short, char, int> ::length(const _Statype &_State, const _Byte *_First1, const _Byte *
_Last1, size_t _Count) const 
{ 
return this->do_length(_State, _First1, _Last1, _Count); 
} 
#line 1127
inline __declspec( noinline ) codecvt< unsigned short, char, int> ::codecvt(size_t _Refs) : codecvt_base(_Refs) 

{ 
{ auto _Locinfo _Lobj; 
this->_Init(_Lobj); 
} 
} 

inline __declspec( noinline ) codecvt< unsigned short, char, int> ::codecvt(const _Locinfo &_Lobj, size_t _Refs) : codecvt_base(_Refs) 

{ 
this->_Init(_Lobj); 
} 

inline size_t codecvt< unsigned short, char, int> ::_Getcat(const locale::facet **_Ppf, const locale *
_Ploc) 
{ 
if ((_Ppf != (0)) && (*_Ppf == (0))) { 
(*_Ppf) = (new std::codecvt< unsigned short, char, int> (((_Locinfo)(_Ploc->name())))); }  

return 2; 
} 


inline __declspec( noinline ) codecvt< unsigned short, char, int> ::~codecvt() 
{ 
} 


inline __declspec( noinline ) codecvt< unsigned short, char, int> ::codecvt(const char *_Locname, size_t _Refs) : codecvt_base(_Refs) 

{ 
{ auto _Locinfo _Lobj(_Locname); 
this->_Init(_Lobj); 
} 
} 

inline void codecvt< unsigned short, char, int> ::_Init(const _Locinfo &_Lobj) 
{ 
(this->_Cvt) = _Lobj._Getcvt(); 
} 

inline __declspec( noinline ) codecvt_base::result codecvt< unsigned short, char, int> ::do_in(_Statype &_State, const _Byte *
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
{ 
; 
; 
(_Mid1 = _First1), (_Mid2 = _First2); 
auto result _Ans = ((_Mid1 == _Last1) ? ok : partial); 
auto int _Bytes; 

while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
switch (_Bytes = _Mbrtowc((__wchar_t *)(_Mid2), _Mid1, _Last1 - _Mid1, (&_State), &(this->_Cvt))) 

{ 
case (-2): 
_Mid1 = _Last1; 
return _Ans; 

case (-1): 
return error; 

case 0: 
if (*(_Mid2) == ((_Elem)0)) { 
_Bytes = (int)::strlen(_Mid1) + 1; }  


default: 
if (_Bytes == (-3)) { 
_Bytes = 0; }  
_Mid1 += _Bytes; 
++_Mid2; 
_Ans = (ok); break;
}  }  
return _Ans; 
} 

inline __declspec( noinline ) codecvt_base::result codecvt< unsigned short, char, int> ::do_out(_Statype &_State, const _Elem *
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
; 
; 
(_Mid1 = _First1), (_Mid2 = _First2); 
auto result _Ans = ((_Mid1 == _Last1) ? ok : partial); 
auto int _Bytes; 

while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
if (5 <= _Last2 - _Mid2) { 
if ((_Bytes = _Wcrtomb(_Mid2, *(_Mid1), (&_State), &(this->_Cvt))) < 0) { 

return error; } else { 

((++_Mid1), (_Mid2 += _Bytes)), (_Ans = (ok)); }  } else 

{ 
auto _Byte _Buf[5]; 
auto _Statype _Stsave = (_State); 

if ((_Bytes = _Wcrtomb(_Buf, *(_Mid1), (&_State), &(this->_Cvt))) < 0) { 

return error; } else { 
if (_Last2 - _Mid2 < _Bytes) 
{ 
_State = _Stsave; 
return _Ans; 
} else 

{ 
::memcpy_s(_Mid2, _Last2 - _Mid2, _Buf, _Bytes); 
((++_Mid1), (_Mid2 += _Bytes)), (_Ans = (ok)); 
}  }  
}  }  
return _Ans; 
} 

inline __declspec( noinline ) codecvt_base::result codecvt< unsigned short, char, int> ::do_unshift(_Statype &_State, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
; 
_Mid2 = _First2; 
auto result _Ans = (ok); 
auto int _Bytes; 
auto _Byte _Buf[5]; 
auto _Statype _Stsave = (_State); 

if ((_Bytes = _Wcrtomb(_Buf, L'\x0', (&_State), &(this->_Cvt))) <= 0) { 
_Ans = (error); } else { 
if (_Last2 - _Mid2 < --_Bytes) 
{ 
_State = _Stsave; 
_Ans = (partial); 
} else { 
if (0 < _Bytes) 
{ 
::memcpy_s(_Mid2, _Last2 - _Mid2, _Buf, _Bytes); 
_Mid2 += _Bytes; 
}  }  }  
return _Ans; 
} 

inline __declspec( noinline ) int codecvt< unsigned short, char, int> ::do_length(const _Statype &_State, const _Byte *_First1, const _Byte *
_Last1, size_t _Count) const 
{ 
; 
auto int _Wchars; 
auto const _Byte *_Mid1; 
auto _Statype _Mystate = (_State); 

for ((_Wchars = 0), (_Mid1 = _First1); ((size_t)_Wchars < _Count) && (_Mid1 != _Last1);) 

{ 
auto int _Bytes; 
auto _Elem _Ch; 

switch (_Bytes = _Mbrtowc((__wchar_t *)(&_Ch), _Mid1, _Last1 - _Mid1, &_Mystate, &(this->_Cvt))) 

{ 
case (-2): 
return _Wchars; 

case (-1): 
return _Wchars; 

case 0: 
if (_Ch == ((_Elem)0)) { 
_Bytes = (int)::strlen(_Mid1) + 1; }  


default: 
if (_Bytes == (-3)) { 
_Bytes = 0; }  
_Mid1 += _Bytes; 
++_Wchars; break;
}  
}  
return _Wchars; 
} 

inline bool codecvt< unsigned short, char, int> ::do_always_noconv() const throw() 
{ 
return false; 
} 

inline int codecvt< unsigned short, char, int> ::do_max_length() const throw() 
{ 
return 5; 
} 
#line 1323
template<class _Elem, class 
_Byte, class 
_Statype> 
class codecvt_byname : public codecvt< _Elem, _Byte, _Statype>  { friend struct __cilk_s;__CILK_METADATA(codecvt_byname, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



inline explicit codecvt_byname(const char *, size_t = (0)); inline explicit  /* __cilk */ __thiscall codecvt_byname(__cilk_box<const char * > , __cilk_box<unsigned >  = (__cilk_box<unsigned >(0))); 
#line 1336
protected: inline virtual ~codecvt_byname(); 


}; 

#pragma warning(push)
#pragma warning(disable:4275)

struct __declspec( dllimport ) ctype_base : public locale::facet { friend struct __cilk_s;__CILK_METADATA(ctype_base, __CILK_VBASE_DETECT)



enum { 
alnum = 263, alpha = 259, 
cntrl = 32, digit = 4, graph = 279, 
lower = 2, print = 471, 
punct = 16, space = 72, upper = 1, 
xdigit = 128}; 
typedef short mask; 

inline __declspec( noinline ) ctype_base(size_t = (0)); 




inline virtual __declspec( noinline ) ~ctype_base(); 




protected: static inline __declspec( noinline ) void _Xran(); 



}; 
#line 1356
inline __declspec( noinline ) ctype_base::ctype_base(size_t _Refs) : locale::facet(_Refs) 

{ 
} 

inline __declspec( noinline ) ctype_base::~ctype_base() 
{ 
} 


inline __declspec( noinline ) void ctype_base::_Xran() 
{ 
__cilk_s::throw0<out_of_range >( ((out_of_range)("out_of_range in ctype<T>"))); 
} 

#pragma warning(pop)


template<class _Elem> 
class ctype : public ctype_base { friend struct __cilk_s;__CILK_METADATA(ctype, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



typedef _Elem char_type; 

inline bool is(mask, _Elem) const; inline bool  /* __cilk */ __thiscall __cilkfun_is(__cilk_box<short > , __cilk_box<_Elem > ) const; 




inline const _Elem *is(const _Elem *, const _Elem *, mask *) const; inline const _Elem * /* __cilk */ __thiscall __cilkfun_is(__cilk_box<const _Elem * > , __cilk_box<const _Elem * > , __cilk_box<mask * > ) const; 
#line 1392
inline const _Elem *scan_is(mask, const _Elem *, const _Elem *) const; inline const _Elem * /* __cilk */ __thiscall __cilkfun_scan_is(__cilk_box<short > , __cilk_box<const _Elem * > , __cilk_box<const _Elem * > ) const; 
#line 1398
inline const _Elem *scan_not(mask, const _Elem *, const _Elem *) const; inline const _Elem * /* __cilk */ __thiscall __cilkfun_scan_not(__cilk_box<short > , __cilk_box<const _Elem * > , __cilk_box<const _Elem * > ) const; 
#line 1404
inline _Elem tolower(_Elem) const; inline _Elem  /* __cilk */ __thiscall __cilkfun_tolower(__cilk_box<_Elem > ) const; 




inline const _Elem *tolower(_Elem *, const _Elem *) const; inline const _Elem * /* __cilk */ __thiscall __cilkfun_tolower(__cilk_box<_Elem * > , __cilk_box<const _Elem * > ) const; 




inline _Elem toupper(_Elem) const; inline _Elem  /* __cilk */ __thiscall __cilkfun_toupper(__cilk_box<_Elem > ) const; 




inline const _Elem *toupper(_Elem *, const _Elem *) const; inline const _Elem * /* __cilk */ __thiscall __cilkfun_toupper(__cilk_box<_Elem * > , __cilk_box<const _Elem * > ) const; 




inline _Elem widen(char) const; inline _Elem  /* __cilk */ __thiscall __cilkfun_widen(__cilk_box<char > ) const; 
#line 1430
inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const char *widen(const char *, const char *, _Elem *) const; inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const char * /* __cilk */ __thiscall __cilkfun_widen(__cilk_box<const char * > , __cilk_box<const char * > , __cilk_box<_Elem * > ) const; 
#line 1439
inline const char *_Widen_s(const char *, const char *, _Elem *, size_t) const; inline const char * /* __cilk */ __thiscall __cilkfun__Widen_s(__cilk_box<const char * > , __cilk_box<const char * > , __cilk_box<_Elem * > , __cilk_box<unsigned > ) const; 
#line 1445
inline char narrow(_Elem, char = '\000') const; inline char  /* __cilk */ __thiscall __cilkfun_narrow(__cilk_box<_Elem > , __cilk_box<char >  = (__cilk_box<char >('\000'))) const; 
#line 1451
inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const _Elem *narrow(const _Elem *, const _Elem *, char, char *) const; inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const _Elem * /* __cilk */ __thiscall __cilkfun_narrow(__cilk_box<const _Elem * > , __cilk_box<const _Elem * > , __cilk_box<char > , __cilk_box<char * > ) const; 
#line 1461
inline const _Elem *_Narrow_s(const _Elem *, const _Elem *, char, char *, size_t) const; inline const _Elem * /* __cilk */ __thiscall __cilkfun__Narrow_s(__cilk_box<const _Elem * > , __cilk_box<const _Elem * > , __cilk_box<char > , __cilk_box<char * > , __cilk_box<unsigned > ) const; 
#line 1467
static locale::id id; 

inline explicit ctype(typename __cilk_maybe_box<ctype, unsigned >::type  = (__cilk_maybe_box<ctype, size_t >::type (0))); 
#line 1477
inline ctype(const _Locinfo &, size_t = (0)); inline  /* __cilk */ __thiscall ctype(__cilk_box<const _Locinfo & > , __cilk_box<unsigned >  = (__cilk_box<unsigned >(0))); 
#line 1483
static inline size_t _Getcat(const locale::facet ** = 0, const locale * = 0); static inline size_t  /* __cilk */ __cdecl __cilkfun__Getcat(__cilk_box<const locale::facet ** >  = (__cilk_box<const locale::facet ** >(0)), __cilk_box<const locale * >  = (__cilk_box<const locale * >(0))); 
#line 1493
protected: inline virtual ~ctype(); 
#line 1500
inline void _Init(const _Locinfo &); inline void  /* __cilk */ __thiscall __cilkfun__Init(__cilk_box<const _Locinfo & > ); 




inline virtual bool do_is(typename __cilk_maybe_box<ctype, short >::type , typename __cilk_maybe_box<ctype, _Elem >::type ) const; 
#line 1511
inline virtual const _Elem *do_is(typename __cilk_maybe_box<ctype, const _Elem * >::type , typename __cilk_maybe_box<ctype, const _Elem * >::type , typename __cilk_maybe_box<ctype, mask * >::type ) const; 
#line 1521
inline virtual const _Elem *do_scan_is(typename __cilk_maybe_box<ctype, short >::type , typename __cilk_maybe_box<ctype, const _Elem * >::type , typename __cilk_maybe_box<ctype, const _Elem * >::type ) const; 
#line 1530
inline virtual const _Elem *do_scan_not(typename __cilk_maybe_box<ctype, short >::type , typename __cilk_maybe_box<ctype, const _Elem * >::type , typename __cilk_maybe_box<ctype, const _Elem * >::type ) const; 
#line 1539
inline virtual _Elem do_tolower(typename __cilk_maybe_box<ctype, _Elem >::type ) const; 
#line 1548
inline virtual const _Elem *do_tolower(typename __cilk_maybe_box<ctype, _Elem * >::type , typename __cilk_maybe_box<ctype, const _Elem * >::type ) const; 
#line 1560
inline virtual _Elem do_toupper(typename __cilk_maybe_box<ctype, _Elem >::type ) const; 
#line 1569
inline virtual const _Elem *do_toupper(typename __cilk_maybe_box<ctype, _Elem * >::type , typename __cilk_maybe_box<ctype, const _Elem * >::type ) const; 
#line 1581
inline virtual _Elem do_widen(typename __cilk_maybe_box<ctype, char >::type ) const; 
#line 1587
inline virtual __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const char *do_widen(typename __cilk_maybe_box<ctype, const char * >::type , typename __cilk_maybe_box<ctype, const char * >::type , typename __cilk_maybe_box<ctype, _Elem * >::type ) const; 
#line 1594
inline virtual const char *_Do_widen_s(typename __cilk_maybe_box<ctype, const char * >::type , typename __cilk_maybe_box<ctype, const char * >::type , typename __cilk_maybe_box<ctype, _Elem * >::type , typename __cilk_maybe_box<ctype, unsigned >::type ) const; 
#line 1605
inline char _Donarrow(_Elem, char) const; inline char  /* __cilk */ __thiscall __cilkfun__Donarrow(__cilk_box<_Elem > , __cilk_box<char > ) const; 
#line 1616
inline virtual char do_narrow(typename __cilk_maybe_box<ctype, _Elem >::type , typename __cilk_maybe_box<ctype, char >::type ) const; 
#line 1622
inline virtual __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const _Elem *do_narrow(typename __cilk_maybe_box<ctype, const _Elem * >::type , typename __cilk_maybe_box<ctype, const _Elem * >::type , typename __cilk_maybe_box<ctype, char >::type , typename __cilk_maybe_box<ctype, char * >::type ) const; 
#line 1629
inline virtual const _Elem *_Do_narrow_s(typename __cilk_maybe_box<ctype, const _Elem * >::type , typename __cilk_maybe_box<ctype, const _Elem * >::type , typename __cilk_maybe_box<ctype, char >::type , typename __cilk_maybe_box<ctype, char * >::type , typename __cilk_maybe_box<ctype, unsigned >::type ) const; 
#line 1643
private: _Locinfo::_Ctypevec _Ctype; 
_Locinfo::_Cvtvec _Cvt; 
}; 
#line 1652
template<> class __declspec( dllimport ) ctype< char>  : public ctype_base { friend struct __cilk_s;__CILK_METADATA(ctype, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef std::ctype< char>  _Myt; 


typedef char _Elem; 
typedef _Elem char_type; 

inline bool is(mask, _Elem) const; 




inline const _Elem *is(const _Elem *, const _Elem *, mask *) const; 
#line 1676
inline const _Elem *scan_is(mask, const _Elem *, const _Elem *) const; 
#line 1685
inline const _Elem *scan_not(mask, const _Elem *, const _Elem *) const; 
#line 1694
inline __declspec( noinline ) _Elem tolower(_Elem) const; 




inline __declspec( noinline ) const _Elem *tolower(_Elem *, const _Elem *) const; 




inline __declspec( noinline ) _Elem toupper(_Elem) const; 




inline __declspec( noinline ) const _Elem *toupper(_Elem *, const _Elem *) const; 




inline __declspec( noinline ) _Elem widen(char) const; 
#line 1720
inline __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const _Elem *widen(const char *, const char *, _Elem *) const; 
#line 1730
inline __declspec( noinline ) const _Elem *_Widen_s(const char *, const char *, _Elem *, size_t) const; 
#line 1736
inline __declspec( noinline ) _Elem narrow(_Elem, char = '\000') const; 
#line 1742
inline __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const _Elem *narrow(const _Elem *, const _Elem *, char, char *) const; 
#line 1752
inline __declspec( noinline ) const _Elem *_Narrow_s(const _Elem *, const _Elem *, char, char *, size_t) const; 
#line 1759
static locale::id &__cdecl _Id_func(); 



static locale::id id; 


inline explicit __declspec( noinline ) ctype(const mask * = 0, bool = false, size_t = (0)); 
#line 1782
inline __declspec( noinline ) ctype(const _Locinfo &, size_t = (0)); 
#line 1788
static inline size_t _Getcat(const locale::facet ** = 0, const locale * = 0); 
#line 1797
static const size_t table_size = (1 << 8); 


protected: inline virtual __declspec( noinline ) ~ctype(); 
#line 1806
inline void _Init(const _Locinfo &); 




inline __declspec( noinline ) void _Tidy(); 
#line 1819
inline virtual __declspec( noinline ) _Elem do_tolower(_Elem) const; 




inline virtual __declspec( noinline ) const _Elem *do_tolower(_Elem *, const _Elem *) const; 
#line 1833
inline virtual __declspec( noinline ) _Elem do_toupper(_Elem) const; 




inline virtual __declspec( noinline ) const _Elem *do_toupper(_Elem *, const _Elem *) const; 
#line 1847
inline virtual _Elem do_widen(char) const; 
#line 1853
inline virtual __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const _Elem *do_widen(const char *, const char *, _Elem *) const; 
#line 1860
inline virtual __declspec( noinline ) const _Elem *_Do_widen_s(const char *, const char *, _Elem *, size_t) const; 
#line 1870
inline virtual _Elem do_narrow(_Elem, char) const; 
#line 1876
inline virtual __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const _Elem *do_narrow(const _Elem *, const _Elem *, char, char *) const; 
#line 1884
inline virtual __declspec( noinline ) const _Elem *_Do_narrow_s(const _Elem *, const _Elem *, char, char *, size_t) const; 
#line 1895
inline const mask *table() const throw(); 




static inline __declspec( noinline ) const mask *classic_table() throw(); 
#line 1907
private: _Locinfo::_Ctypevec _Ctype; 
}; 
#line 1661
inline bool ctype< char> ::is(mask _Maskval, _Elem _Ch) const 
{ 
return (((this->_Ctype)._Table)[(unsigned char)_Ch] & _Maskval) != 0; 
} 

inline const ctype< char> ::_Elem *ctype< char> ::is(const _Elem *_First, const _Elem *
_Last, mask *_Dest) const 
{ 
; 
; 
for (; _First != _Last; (++_First), (++_Dest)) { 
(*_Dest) = ((this->_Ctype)._Table)[(unsigned char)(*_First)]; }  
return _First; 
} 

inline const ctype< char> ::_Elem *ctype< char> ::scan_is(mask _Maskval, const _Elem *
_First, const _Elem *_Last) const 
{ 
; 
for (; (_First != _Last) && (!this->is(_Maskval, *_First)); ++_First) { 
; }  
return _First; 
} 

inline const ctype< char> ::_Elem *ctype< char> ::scan_not(mask _Maskval, const _Elem *
_First, const _Elem *_Last) const 
{ 
; 
for (; (_First != _Last) && this->is(_Maskval, *_First); ++_First) { 
; }  
return _First; 
} 

inline __declspec( noinline ) ctype< char> ::_Elem ctype< char> ::tolower(_Elem _Ch) const 
{ 
return this->do_tolower(_Ch); 
} 

inline __declspec( noinline ) const ctype< char> ::_Elem *ctype< char> ::tolower(_Elem *_First, const _Elem *_Last) const 
{ 
return this->do_tolower(_First, _Last); 
} 

inline __declspec( noinline ) ctype< char> ::_Elem ctype< char> ::toupper(_Elem _Ch) const 
{ 
return this->do_toupper(_Ch); 
} 

inline __declspec( noinline ) const ctype< char> ::_Elem *ctype< char> ::toupper(_Elem *_First, const _Elem *_Last) const 
{ 
return this->do_toupper(_First, _Last); 
} 

inline __declspec( noinline ) ctype< char> ::_Elem ctype< char> ::widen(char _Byte) const 
{ 
return this->do_widen(_Byte); 
} 


inline __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const ctype< char> ::_Elem *ctype< char> ::widen(const char *_First, const char *_Last, _Elem *
_Dest) const 
{ 

#pragma warning(push)
#pragma warning(disable:4996)
return this->do_widen(_First, _Last, _Dest); 
#pragma warning(pop)
} 

inline __declspec( noinline ) const ctype< char> ::_Elem *ctype< char> ::_Widen_s(const char *_First, const char *_Last, _Elem *
_Dest, size_t _Dest_size) const 
{ 
return this->_Do_widen_s(_First, _Last, _Dest, _Dest_size); 
} 

inline __declspec( noinline ) ctype< char> ::_Elem ctype< char> ::narrow(_Elem _Ch, char _Dflt) const 
{ 
return this->do_narrow(_Ch, _Dflt); 
} 


inline __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const ctype< char> ::_Elem *ctype< char> ::narrow(const _Elem *_First, const _Elem *_Last, char 
_Dflt, char *_Dest) const 
{ 

#pragma warning(push)
#pragma warning(disable:4996)
return this->do_narrow(_First, _Last, _Dflt, _Dest); 
#pragma warning(pop)
} 

inline __declspec( noinline ) const ctype< char> ::_Elem *ctype< char> ::_Narrow_s(const _Elem *_First, const _Elem *_Last, char 
_Dflt, char *_Dest, size_t 
_Dest_size) const 
{ 
return this->_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size); 
} 
#line 1766
inline __declspec( noinline ) ctype< char> ::ctype(const mask *_Table, bool 
_Deletetable, size_t 
_Refs) : ctype_base(_Refs) 

{ 
{ auto _Locinfo _Lobj; 
this->_Init(_Lobj); 
} 
if (_Table != (0)) 
{ 
this->_Tidy(); 
((this->_Ctype)._Table) = _Table; 
((this->_Ctype)._Delfl) = _Deletetable ? (-1) : 0; 
}  
} 

inline __declspec( noinline ) ctype< char> ::ctype(const _Locinfo &_Lobj, size_t _Refs) : ctype_base(_Refs) 

{ 
this->_Init(_Lobj); 
} 

inline size_t ctype< char> ::_Getcat(const locale::facet **_Ppf, const locale *
_Ploc) 
{ 
if ((_Ppf != (0)) && (*_Ppf == (0))) { 
(*_Ppf) = (new std::ctype< char> (((_Locinfo)(_Ploc->name())))); }  

return 2; 
} 




inline __declspec( noinline ) ctype< char> ::~ctype() 
{ 
this->_Tidy(); 
} 


inline void ctype< char> ::_Init(const _Locinfo &_Lobj) 
{ 
(this->_Ctype) = _Lobj._Getctype(); 
} 

inline __declspec( noinline ) void ctype< char> ::_Tidy() 
{ 
if (0 < (this->_Ctype)._Delfl) { 
free((void *)((this->_Ctype)._Table)); } else { 
if ((this->_Ctype)._Delfl < 0) { 
delete [] ((void *)((this->_Ctype)._Table)); }  }  
} 

inline __declspec( noinline ) ctype< char> ::_Elem ctype< char> ::do_tolower(_Elem _Ch) const 
{ 
return (_Elem)_Tolower((unsigned char)_Ch, &(this->_Ctype)); 
} 

inline __declspec( noinline ) const ctype< char> ::_Elem *ctype< char> ::do_tolower(_Elem *_First, const _Elem *
_Last) const 
{ 
; 
for (; _First != _Last; ++_First) { 
(*_First) = (_Elem)_Tolower((unsigned char)(*_First), &(this->_Ctype)); }  
return (const _Elem *)_First; 
} 

inline __declspec( noinline ) ctype< char> ::_Elem ctype< char> ::do_toupper(_Elem _Ch) const 
{ 
return (_Elem)_Toupper((unsigned char)_Ch, &(this->_Ctype)); 
} 

inline __declspec( noinline ) const ctype< char> ::_Elem *ctype< char> ::do_toupper(_Elem *_First, const _Elem *
_Last) const 
{ 
; 
for (; _First != _Last; ++_First) { 
(*_First) = (_Elem)_Toupper((unsigned char)(*_First), &(this->_Ctype)); }  
return (const _Elem *)_First; 
} 

inline ctype< char> ::_Elem ctype< char> ::do_widen(char _Byte) const 
{ 
return _Byte; 
} 


inline __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const ctype< char> ::_Elem *ctype< char> ::do_widen(const char *_First, const char *
_Last, _Elem *_Dest) const 
{ 

return this->_Do_widen_s(_First, _Last, _Dest, _Last - _First); 
} 

inline __declspec( noinline ) const ctype< char> ::_Elem *ctype< char> ::_Do_widen_s(const char *_First, const char *
_Last, _Elem *_Dest, size_t _Dest_size) const 
{ 
; 
; 
{ if (!(_Dest_size >= (size_t)(_Last - _First))) { (void)0; ::_invalid_parameter_noinfo(); }  ; } ; 
::memcpy_s(_Dest, _Dest_size, _First, _Last - _First); 
return _Last; 
} 

inline ctype< char> ::_Elem ctype< char> ::do_narrow(_Elem _Ch, char __T16960032) const 
{ 
return _Ch; 
} 


inline __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const ctype< char> ::_Elem *ctype< char> ::do_narrow(const _Elem *_First, const _Elem *
_Last, char _Dflt, char *
_Dest) const 
{ 

return this->_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last - _First); 
} 

inline __declspec( noinline ) const ctype< char> ::_Elem *ctype< char> ::_Do_narrow_s(const _Elem *_First, const _Elem *
_Last, char __T16962176, char *_Dest, size_t 
_Dest_size) const 
{ 
; 
; 
{ if (!(_Dest_size >= (size_t)(_Last - _First))) { (void)0; ::_invalid_parameter_noinfo(); }  ; } ; 
::memcpy_s(_Dest, _Dest_size, _First, _Last - _First); 
return _Last; 
} 

inline const ctype_base::mask *ctype< char> ::table() const throw() 
{ 
return (this->_Ctype)._Table; 
} 
#line 483
template<> inline __declspec( noinline ) const ctype< char> ::_Myt &__cdecl use_facet< ctype< char> > (const locale &); 
#line 1900
inline __declspec( noinline ) const ctype_base::mask *ctype< char> ::classic_table() throw() 
{ 
auto const _Myt &_Ctype_fac = use_facet< std::ctype< char> > (locale::classic()); 
return _Ctype_fac.table(); 
} 
#line 1911
template<> class __declspec( dllimport ) ctype< __wchar_t>  : public ctype_base { friend struct __cilk_s;__CILK_METADATA(ctype, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef std::ctype< __wchar_t>  _Myt; 


typedef __wchar_t _Elem; 
typedef _Elem char_type; 

inline __declspec( noinline ) bool is(mask, _Elem) const; 




inline __declspec( noinline ) const _Elem *is(const _Elem *, const _Elem *, mask *) const; 
#line 1931
inline __declspec( noinline ) const _Elem *scan_is(mask, const _Elem *, const _Elem *) const; 
#line 1937
inline __declspec( noinline ) const _Elem *scan_not(mask, const _Elem *, const _Elem *) const; 
#line 1943
inline __declspec( noinline ) _Elem tolower(_Elem) const; 




inline __declspec( noinline ) const _Elem *tolower(_Elem *, const _Elem *) const; 




inline __declspec( noinline ) _Elem toupper(_Elem) const; 




inline __declspec( noinline ) const _Elem *toupper(_Elem *, const _Elem *) const; 




inline __declspec( noinline ) _Elem widen(char) const; 
#line 1969
inline __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const char *widen(const char *, const char *, _Elem *) const; 
#line 1979
inline __declspec( noinline ) const char *_Widen_s(const char *, const char *, _Elem *, size_t) const; 
#line 1985
inline __declspec( noinline ) char narrow(_Elem, char = '\000') const; 
#line 1991
inline __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const _Elem *narrow(const _Elem *, const _Elem *, char, char *) const; 
#line 2001
inline __declspec( noinline ) const _Elem *_Narrow_s(const _Elem *, const _Elem *, char, char *, size_t) const; 
#line 2008
static locale::id &__cdecl _Id_func(); 



static locale::id id; 


inline explicit __declspec( noinline ) ctype(size_t = (0)); 
#line 2023
inline __declspec( noinline ) ctype(const _Locinfo &, size_t = (0)); 
#line 2029
static inline size_t _Getcat(const locale::facet ** = 0, const locale * = 0); 
#line 2039
protected: inline virtual __declspec( noinline ) ~ctype(); 
#line 2046
inline void _Init(const _Locinfo &); 
#line 2052
inline virtual __declspec( noinline ) bool do_is(mask, _Elem) const; 




inline virtual __declspec( noinline ) const __wchar_t *do_is(const _Elem *, const _Elem *, mask *) const; 
#line 2065
inline virtual const _Elem *do_scan_is(mask, const _Elem *, const _Elem *) const; 
#line 2074
inline virtual const _Elem *do_scan_not(mask, const _Elem *, const _Elem *) const; 
#line 2083
inline virtual __declspec( noinline ) _Elem do_tolower(_Elem) const; 




inline virtual __declspec( noinline ) const _Elem *do_tolower(_Elem *, const _Elem *) const; 
#line 2097
inline virtual __declspec( noinline ) _Elem do_toupper(_Elem) const; 




inline virtual __declspec( noinline ) const _Elem *do_toupper(_Elem *, const _Elem *) const; 
#line 2111
inline __declspec( noinline ) _Elem _Dowiden(char) const; 
#line 2119
inline virtual _Elem do_widen(char) const; 
#line 2125
inline virtual __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const char *do_widen(const char *, const char *, _Elem *) const; 
#line 2132
inline virtual __declspec( noinline ) const char *_Do_widen_s(const char *, const char *, _Elem *, size_t) const; 
#line 2143
inline __declspec( noinline ) char _Donarrow(_Elem, char) const; 
#line 2151
inline virtual char do_narrow(_Elem, char) const; 
#line 2157
inline virtual __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const _Elem *do_narrow(const _Elem *, const _Elem *, char, char *) const; 
#line 2165
inline virtual __declspec( noinline ) const _Elem *_Do_narrow_s(const _Elem *, const _Elem *, char, char *, size_t) const; 
#line 2179
private: _Locinfo::_Ctypevec _Ctype; 
_Locinfo::_Cvtvec _Cvt; 
}; 
#line 1920
inline __declspec( noinline ) bool ctype< __wchar_t> ::is(mask _Maskval, _Elem _Ch) const 
{ 
return this->do_is(_Maskval, _Ch); 
} 

inline __declspec( noinline ) const ctype< __wchar_t> ::_Elem *ctype< __wchar_t> ::is(const _Elem *_First, const _Elem *_Last, mask *
_Dest) const 
{ 
return this->do_is(_First, _Last, _Dest); 
} 

inline __declspec( noinline ) const ctype< __wchar_t> ::_Elem *ctype< __wchar_t> ::scan_is(mask _Maskval, const _Elem *_First, const _Elem *
_Last) const 
{ 
return this->do_scan_is(_Maskval, _First, _Last); 
} 

inline __declspec( noinline ) const ctype< __wchar_t> ::_Elem *ctype< __wchar_t> ::scan_not(mask _Maskval, const _Elem *_First, const _Elem *
_Last) const 
{ 
return this->do_scan_not(_Maskval, _First, _Last); 
} 

inline __declspec( noinline ) ctype< __wchar_t> ::_Elem ctype< __wchar_t> ::tolower(_Elem _Ch) const 
{ 
return this->do_tolower(_Ch); 
} 

inline __declspec( noinline ) const ctype< __wchar_t> ::_Elem *ctype< __wchar_t> ::tolower(_Elem *_First, const _Elem *_Last) const 
{ 
return this->do_tolower(_First, _Last); 
} 

inline __declspec( noinline ) ctype< __wchar_t> ::_Elem ctype< __wchar_t> ::toupper(_Elem _Ch) const 
{ 
return this->do_toupper(_Ch); 
} 

inline __declspec( noinline ) const ctype< __wchar_t> ::_Elem *ctype< __wchar_t> ::toupper(_Elem *_First, const _Elem *_Last) const 
{ 
return this->do_toupper(_First, _Last); 
} 

inline __declspec( noinline ) ctype< __wchar_t> ::_Elem ctype< __wchar_t> ::widen(char _Byte) const 
{ 
return this->do_widen(_Byte); 
} 


inline __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const char *ctype< __wchar_t> ::widen(const char *_First, const char *_Last, _Elem *
_Dest) const 
{ 

#pragma warning(push)
#pragma warning(disable:4996)
return this->do_widen(_First, _Last, _Dest); 
#pragma warning(pop)
} 

inline __declspec( noinline ) const char *ctype< __wchar_t> ::_Widen_s(const char *_First, const char *_Last, _Elem *
_Dest, size_t _Dest_size) const 
{ 
return this->_Do_widen_s(_First, _Last, _Dest, _Dest_size); 
} 

inline __declspec( noinline ) char ctype< __wchar_t> ::narrow(_Elem _Ch, char _Dflt) const 
{ 
return this->do_narrow(_Ch, _Dflt); 
} 


inline __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const ctype< __wchar_t> ::_Elem *ctype< __wchar_t> ::narrow(const _Elem *_First, const _Elem *_Last, char 
_Dflt, char *_Dest) const 
{ 

#pragma warning(push)
#pragma warning(disable:4996)
return this->do_narrow(_First, _Last, _Dflt, _Dest); 
#pragma warning(pop)
} 

inline __declspec( noinline ) const ctype< __wchar_t> ::_Elem *ctype< __wchar_t> ::_Narrow_s(const _Elem *_First, const _Elem *_Last, char 
_Dflt, char *_Dest, size_t 
_Dest_size) const 
{ 
return this->_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size); 
} 
#line 2015
inline __declspec( noinline ) ctype< __wchar_t> ::ctype(size_t _Refs) : ctype_base(_Refs) 

{ 
{ auto _Locinfo _Lobj; 
this->_Init(_Lobj); 
} 
} 

inline __declspec( noinline ) ctype< __wchar_t> ::ctype(const _Locinfo &_Lobj, size_t _Refs) : ctype_base(_Refs) 

{ 
this->_Init(_Lobj); 
} 

inline size_t ctype< __wchar_t> ::_Getcat(const locale::facet **_Ppf, const locale *
_Ploc) 
{ 
if ((_Ppf != (0)) && (*_Ppf == (0))) { 
(*_Ppf) = (new std::ctype< __wchar_t> (((_Locinfo)(_Ploc->name())))); }  

return 2; 
} 


inline __declspec( noinline ) ctype< __wchar_t> ::~ctype() 
{ 
if ((this->_Ctype)._Delfl) { 
free((void *)((this->_Ctype)._Table)); }  
} 


inline void ctype< __wchar_t> ::_Init(const _Locinfo &_Lobj) 
{ 
(this->_Ctype) = _Lobj._Getctype(); 
(this->_Cvt) = _Lobj._Getcvt(); 
} 

inline __declspec( noinline ) bool ctype< __wchar_t> ::do_is(mask _Maskval, _Elem _Ch) const 
{ 
return (::_Getwctype(_Ch, &(this->_Ctype)) & _Maskval) != 0; 
} 

inline __declspec( noinline ) const __wchar_t *ctype< __wchar_t> ::do_is(const _Elem *_First, const _Elem *
_Last, mask *_Dest) const 
{ 
; 
; 
return ::_Getwctypes(_First, _Last, _Dest, &(this->_Ctype)); 
} 

inline const ctype< __wchar_t> ::_Elem *ctype< __wchar_t> ::do_scan_is(mask _Maskval, const _Elem *
_First, const _Elem *_Last) const 
{ 
; 
for (; (_First != _Last) && (!this->is(_Maskval, *_First)); ++_First) { 
; }  
return _First; 
} 

inline const ctype< __wchar_t> ::_Elem *ctype< __wchar_t> ::do_scan_not(mask _Maskval, const _Elem *
_First, const _Elem *_Last) const 
{ 
; 
for (; (_First != _Last) && this->is(_Maskval, *_First); ++_First) { 
; }  
return _First; 
} 

inline __declspec( noinline ) ctype< __wchar_t> ::_Elem ctype< __wchar_t> ::do_tolower(_Elem _Ch) const 
{ 
return _Towlower(_Ch, &(this->_Ctype)); 
} 

inline __declspec( noinline ) const ctype< __wchar_t> ::_Elem *ctype< __wchar_t> ::do_tolower(_Elem *_First, const _Elem *
_Last) const 
{ 
; 
for (; _First != _Last; ++_First) { 
(*_First) = _Towlower(*_First, &(this->_Ctype)); }  
return (const _Elem *)_First; 
} 

inline __declspec( noinline ) ctype< __wchar_t> ::_Elem ctype< __wchar_t> ::do_toupper(_Elem _Ch) const 
{ 
return _Towupper(_Ch, &(this->_Ctype)); 
} 

inline __declspec( noinline ) const ctype< __wchar_t> ::_Elem *ctype< __wchar_t> ::do_toupper(_Elem *_First, const _Elem *
_Last) const 
{ 
; 
for (; _First != _Last; ++_First) { 
(*_First) = _Towupper(*_First, &(this->_Ctype)); }  
return (const _Elem *)_First; 
} 

inline __declspec( noinline ) ctype< __wchar_t> ::_Elem ctype< __wchar_t> ::_Dowiden(char _Byte) const 
{ 
auto mbstate_t _Mbst = (0); 
auto __wchar_t _Wc; 
return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &(this->_Cvt)) < 0) ? ((__wchar_t)((wint_t)65535)) : _Wc; 

} 

inline ctype< __wchar_t> ::_Elem ctype< __wchar_t> ::do_widen(char _Byte) const 
{ 
return this->_Dowiden(_Byte); 
} 


inline __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const char *ctype< __wchar_t> ::do_widen(const char *_First, const char *
_Last, _Elem *_Dest) const 
{ 

return this->_Do_widen_s(_First, _Last, _Dest, _Last - _First); 
} 

inline __declspec( noinline ) const char *ctype< __wchar_t> ::_Do_widen_s(const char *_First, const char *
_Last, _Elem *_Dest, size_t _Dest_size) const 
{ 
; 
; 
{ if (!(_Dest_size >= (size_t)(_Last - _First))) { (void)0; ::_invalid_parameter_noinfo(); }  ; } ; 
for (; _First != _Last; (++_First), (++_Dest)) { 
(*_Dest) = this->_Dowiden(*_First); }  
return _First; 
} 

inline __declspec( noinline ) char ctype< __wchar_t> ::_Donarrow(_Elem _Ch, char _Dflt) const 
{ 
auto char _Buf[5]; 
auto mbstate_t _Mbst = (0); 
return (_Wcrtomb(_Buf, _Ch, &_Mbst, &(this->_Cvt)) != 1) ? _Dflt : ((_Buf)[0]); 

} 

inline char ctype< __wchar_t> ::do_narrow(_Elem _Ch, char _Dflt) const 
{ 
return this->_Donarrow(_Ch, _Dflt); 
} 


inline __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const ctype< __wchar_t> ::_Elem *ctype< __wchar_t> ::do_narrow(const _Elem *_First, const _Elem *
_Last, char _Dflt, char *
_Dest) const 
{ 

return this->_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last - _First); 
} 

inline __declspec( noinline ) const ctype< __wchar_t> ::_Elem *ctype< __wchar_t> ::_Do_narrow_s(const _Elem *_First, const _Elem *
_Last, char _Dflt, char *
_Dest, size_t 
_Dest_size) const 
{ 
; 
; 
{ if (!(_Dest_size >= (size_t)(_Last - _First))) { (void)0; ::_invalid_parameter_noinfo(); }  ; } ; 
for (; _First != _Last; (++_First), (++_Dest)) { 
(*_Dest) = this->_Donarrow(*_First, _Dflt); }  
return _First; 
} 
#line 2185
template<> class __declspec( dllimport ) ctype< unsigned short>  : public ctype_base { friend struct __cilk_s;__CILK_METADATA(ctype, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef std::ctype< unsigned short>  _Myt; 


typedef unsigned short _Elem; 
typedef _Elem char_type; 

inline __declspec( noinline ) bool is(mask, _Elem) const; 




inline __declspec( noinline ) const _Elem *is(const _Elem *, const _Elem *, mask *) const; 
#line 2205
inline __declspec( noinline ) const _Elem *scan_is(mask, const _Elem *, const _Elem *) const; 
#line 2211
inline __declspec( noinline ) const _Elem *scan_not(mask, const _Elem *, const _Elem *) const; 
#line 2217
inline __declspec( noinline ) _Elem tolower(_Elem) const; 




inline __declspec( noinline ) const _Elem *tolower(_Elem *, const _Elem *) const; 




inline __declspec( noinline ) _Elem toupper(_Elem) const; 




inline __declspec( noinline ) const _Elem *toupper(_Elem *, const _Elem *) const; 




inline __declspec( noinline ) _Elem widen(char) const; 
#line 2243
inline __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const char *widen(const char *, const char *, _Elem *) const; 
#line 2253
inline __declspec( noinline ) const char *_Widen_s(const char *, const char *, _Elem *, size_t) const; 
#line 2259
inline __declspec( noinline ) char narrow(_Elem, char = '\000') const; 
#line 2265
inline __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const _Elem *narrow(const _Elem *, const _Elem *, char, char *) const; 
#line 2275
inline __declspec( noinline ) const _Elem *_Narrow_s(const _Elem *, const _Elem *, char, char *, size_t) const; 
#line 2282
static locale::id &__cdecl _Id_func(); 



static locale::id id; 


inline explicit __declspec( noinline ) ctype(size_t = (0)); 
#line 2297
inline __declspec( noinline ) ctype(const _Locinfo &, size_t = (0)); 
#line 2303
static inline size_t _Getcat(const locale::facet ** = 0, const locale * = 0); 
#line 2313
protected: inline virtual __declspec( noinline ) ~ctype(); 
#line 2320
inline __declspec( noinline ) ctype(const char *, size_t = (0)); 
#line 2328
inline void _Init(const _Locinfo &); 
#line 2334
inline virtual __declspec( noinline ) bool do_is(mask, _Elem) const; 




inline virtual __declspec( noinline ) const _Elem *do_is(const _Elem *, const _Elem *, mask *) const; 
#line 2348
inline virtual const _Elem *do_scan_is(mask, const _Elem *, const _Elem *) const; 
#line 2357
inline virtual const _Elem *do_scan_not(mask, const _Elem *, const _Elem *) const; 
#line 2366
inline virtual __declspec( noinline ) _Elem do_tolower(_Elem) const; 




inline virtual __declspec( noinline ) const _Elem *do_tolower(_Elem *, const _Elem *) const; 
#line 2380
inline virtual __declspec( noinline ) _Elem do_toupper(_Elem) const; 




inline virtual __declspec( noinline ) const _Elem *do_toupper(_Elem *, const _Elem *) const; 
#line 2394
inline __declspec( noinline ) _Elem _Dowiden(char) const; 
#line 2402
inline virtual _Elem do_widen(char) const; 
#line 2408
inline virtual __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const char *do_widen(const char *, const char *, _Elem *) const; 
#line 2415
inline virtual __declspec( noinline ) const char *_Do_widen_s(const char *, const char *, _Elem *, size_t) const; 
#line 2426
inline __declspec( noinline ) char _Donarrow(_Elem, char) const; 
#line 2434
inline virtual char do_narrow(_Elem, char) const; 
#line 2440
inline virtual __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const _Elem *do_narrow(const _Elem *, const _Elem *, char, char *) const; 
#line 2447
inline virtual __declspec( noinline ) const _Elem *_Do_narrow_s(const _Elem *, const _Elem *, char, char *, size_t) const; 
#line 2461
private: _Locinfo::_Ctypevec _Ctype; 
_Locinfo::_Cvtvec _Cvt; 
}; 
#line 2194
inline __declspec( noinline ) bool ctype< unsigned short> ::is(mask _Maskval, _Elem _Ch) const 
{ 
return this->do_is(_Maskval, _Ch); 
} 

inline __declspec( noinline ) const ctype< unsigned short> ::_Elem *ctype< unsigned short> ::is(const _Elem *_First, const _Elem *_Last, mask *
_Dest) const 
{ 
return this->do_is(_First, _Last, _Dest); 
} 

inline __declspec( noinline ) const ctype< unsigned short> ::_Elem *ctype< unsigned short> ::scan_is(mask _Maskval, const _Elem *_First, const _Elem *
_Last) const 
{ 
return this->do_scan_is(_Maskval, _First, _Last); 
} 

inline __declspec( noinline ) const ctype< unsigned short> ::_Elem *ctype< unsigned short> ::scan_not(mask _Maskval, const _Elem *_First, const _Elem *
_Last) const 
{ 
return this->do_scan_not(_Maskval, _First, _Last); 
} 

inline __declspec( noinline ) ctype< unsigned short> ::_Elem ctype< unsigned short> ::tolower(_Elem _Ch) const 
{ 
return this->do_tolower(_Ch); 
} 

inline __declspec( noinline ) const ctype< unsigned short> ::_Elem *ctype< unsigned short> ::tolower(_Elem *_First, const _Elem *_Last) const 
{ 
return this->do_tolower(_First, _Last); 
} 

inline __declspec( noinline ) ctype< unsigned short> ::_Elem ctype< unsigned short> ::toupper(_Elem _Ch) const 
{ 
return this->do_toupper(_Ch); 
} 

inline __declspec( noinline ) const ctype< unsigned short> ::_Elem *ctype< unsigned short> ::toupper(_Elem *_First, const _Elem *_Last) const 
{ 
return this->do_toupper(_First, _Last); 
} 

inline __declspec( noinline ) ctype< unsigned short> ::_Elem ctype< unsigned short> ::widen(char _Byte) const 
{ 
return this->do_widen(_Byte); 
} 


inline __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const char *ctype< unsigned short> ::widen(const char *_First, const char *_Last, _Elem *
_Dest) const 
{ 

#pragma warning(push)
#pragma warning(disable:4996)
return this->do_widen(_First, _Last, _Dest); 
#pragma warning(pop)
} 

inline __declspec( noinline ) const char *ctype< unsigned short> ::_Widen_s(const char *_First, const char *_Last, _Elem *
_Dest, size_t _Dest_size) const 
{ 
return this->_Do_widen_s(_First, _Last, _Dest, _Dest_size); 
} 

inline __declspec( noinline ) char ctype< unsigned short> ::narrow(_Elem _Ch, char _Dflt) const 
{ 
return this->do_narrow(_Ch, _Dflt); 
} 


inline __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const ctype< unsigned short> ::_Elem *ctype< unsigned short> ::narrow(const _Elem *_First, const _Elem *_Last, char 
_Dflt, char *_Dest) const 
{ 

#pragma warning(push)
#pragma warning(disable:4996)
return this->do_narrow(_First, _Last, _Dflt, _Dest); 
#pragma warning(pop)
} 

inline __declspec( noinline ) const ctype< unsigned short> ::_Elem *ctype< unsigned short> ::_Narrow_s(const _Elem *_First, const _Elem *_Last, char 
_Dflt, char *_Dest, size_t 
_Dest_size) const 
{ 
return this->_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size); 
} 
#line 2289
inline __declspec( noinline ) ctype< unsigned short> ::ctype(size_t _Refs) : ctype_base(_Refs) 

{ 
{ auto _Locinfo _Lobj; 
this->_Init(_Lobj); 
} 
} 

inline __declspec( noinline ) ctype< unsigned short> ::ctype(const _Locinfo &_Lobj, size_t _Refs) : ctype_base(_Refs) 

{ 
this->_Init(_Lobj); 
} 

inline size_t ctype< unsigned short> ::_Getcat(const locale::facet **_Ppf, const locale *
_Ploc) 
{ 
if ((_Ppf != (0)) && (*_Ppf == (0))) { 
(*_Ppf) = (new std::ctype< unsigned short> (((_Locinfo)(_Ploc->name())))); }  

return 2; 
} 


inline __declspec( noinline ) ctype< unsigned short> ::~ctype() 
{ 
if ((this->_Ctype)._Delfl) { 
free((void *)((this->_Ctype)._Table)); }  
} 


inline __declspec( noinline ) ctype< unsigned short> ::ctype(const char *_Locname, size_t _Refs) : ctype_base(_Refs) 

{ 
{ auto _Locinfo _Lobj(_Locname); 
this->_Init(_Lobj); 
} 
} 

inline void ctype< unsigned short> ::_Init(const _Locinfo &_Lobj) 
{ 
(this->_Ctype) = _Lobj._Getctype(); 
(this->_Cvt) = _Lobj._Getcvt(); 
} 

inline __declspec( noinline ) bool ctype< unsigned short> ::do_is(mask _Maskval, _Elem _Ch) const 
{ 
return (::_Getwctype(_Ch, &(this->_Ctype)) & _Maskval) != 0; 
} 

inline __declspec( noinline ) const ctype< unsigned short> ::_Elem *ctype< unsigned short> ::do_is(const _Elem *_First, const _Elem *
_Last, mask *_Dest) const 
{ 
; 
; 
return (const _Elem *)::_Getwctypes((const __wchar_t *)_First, (const __wchar_t *)_Last, _Dest, &(this->_Ctype)); 

} 

inline const ctype< unsigned short> ::_Elem *ctype< unsigned short> ::do_scan_is(mask _Maskval, const _Elem *
_First, const _Elem *_Last) const 
{ 
; 
for (; (_First != _Last) && (!this->is(_Maskval, *_First)); ++_First) { 
; }  
return _First; 
} 

inline const ctype< unsigned short> ::_Elem *ctype< unsigned short> ::do_scan_not(mask _Maskval, const _Elem *
_First, const _Elem *_Last) const 
{ 
; 
for (; (_First != _Last) && this->is(_Maskval, *_First); ++_First) { 
; }  
return _First; 
} 

inline __declspec( noinline ) ctype< unsigned short> ::_Elem ctype< unsigned short> ::do_tolower(_Elem _Ch) const 
{ 
return _Towlower(_Ch, &(this->_Ctype)); 
} 

inline __declspec( noinline ) const ctype< unsigned short> ::_Elem *ctype< unsigned short> ::do_tolower(_Elem *_First, const _Elem *
_Last) const 
{ 
; 
for (; _First != _Last; ++_First) { 
(*_First) = _Towlower(*_First, &(this->_Ctype)); }  
return (const _Elem *)_First; 
} 

inline __declspec( noinline ) ctype< unsigned short> ::_Elem ctype< unsigned short> ::do_toupper(_Elem _Ch) const 
{ 
return _Towupper(_Ch, &(this->_Ctype)); 
} 

inline __declspec( noinline ) const ctype< unsigned short> ::_Elem *ctype< unsigned short> ::do_toupper(_Elem *_First, const _Elem *
_Last) const 
{ 
; 
for (; _First != _Last; ++_First) { 
(*_First) = _Towupper(*_First, &(this->_Ctype)); }  
return (const _Elem *)_First; 
} 

inline __declspec( noinline ) ctype< unsigned short> ::_Elem ctype< unsigned short> ::_Dowiden(char _Byte) const 
{ 
auto mbstate_t _Mbst = (0); 
auto unsigned short _Wc; 
return (_Mbrtowc((__wchar_t *)(&_Wc), &_Byte, 1, &_Mbst, &(this->_Cvt)) < 0) ? ((unsigned short)((wint_t)65535)) : _Wc; 

} 

inline ctype< unsigned short> ::_Elem ctype< unsigned short> ::do_widen(char _Byte) const 
{ 
return this->_Dowiden(_Byte); 
} 


inline __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const char *ctype< unsigned short> ::do_widen(const char *_First, const char *
_Last, _Elem *_Dest) const 
{ 

return this->_Do_widen_s(_First, _Last, _Dest, _Last - _First); 
} 

inline __declspec( noinline ) const char *ctype< unsigned short> ::_Do_widen_s(const char *_First, const char *
_Last, _Elem *_Dest, size_t _Dest_size) const 
{ 
; 
; 
{ if (!(_Dest_size >= (size_t)(_Last - _First))) { (void)0; ::_invalid_parameter_noinfo(); }  ; } ; 
for (; _First != _Last; (++_First), (++_Dest)) { 
(*_Dest) = this->_Dowiden(*_First); }  
return _First; 
} 

inline __declspec( noinline ) char ctype< unsigned short> ::_Donarrow(_Elem _Ch, char _Dflt) const 
{ 
auto char _Buf[5]; 
auto mbstate_t _Mbst = (0); 
return (_Wcrtomb(_Buf, _Ch, &_Mbst, &(this->_Cvt)) != 1) ? _Dflt : ((_Buf)[0]); 

} 

inline char ctype< unsigned short> ::do_narrow(_Elem _Ch, char _Dflt) const 
{ 
return this->_Donarrow(_Ch, _Dflt); 
} 


inline __declspec( noinline ) __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const ctype< unsigned short> ::_Elem *ctype< unsigned short> ::do_narrow(const _Elem *_First, const _Elem *
_Last, char _Dflt, char *_Dest) const 
{ 

return this->_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last - _First); 
} 

inline __declspec( noinline ) const ctype< unsigned short> ::_Elem *ctype< unsigned short> ::_Do_narrow_s(const _Elem *_First, const _Elem *
_Last, char _Dflt, char *
_Dest, size_t 
_Dest_size) const 
{ 
; 
; 
{ if (!(_Dest_size >= (size_t)(_Last - _First))) { (void)0; ::_invalid_parameter_noinfo(); }  ; } ; 
for (; _First != _Last; (++_First), (++_Dest)) { 
(*_Dest) = this->_Donarrow(*_First, _Dflt); }  
return _First; 
} 
#line 2467
template<class _Elem> 
class ctype_byname : public ctype< _Elem>  { friend struct __cilk_s;__CILK_METADATA(ctype_byname, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



inline explicit ctype_byname(const char *, size_t = (0)); inline explicit  /* __cilk */ __thiscall ctype_byname(__cilk_box<const char * > , __cilk_box<unsigned >  = (__cilk_box<unsigned >(0))); 
#line 2478
protected: inline virtual ~ctype_byname(); 


}; 


template<> class ctype_byname< char>  : public ctype< char>  { friend struct __cilk_s;__CILK_METADATA(ctype_byname, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



inline explicit __declspec( noinline ) ctype_byname(const char *, size_t = (0)); 
#line 2494
protected: inline virtual __declspec( noinline ) ~ctype_byname(); 


}; 
#line 2488
inline __declspec( noinline ) ctype_byname< char> ::ctype_byname(const char *_Locname, size_t _Refs) : std::ctype< char> (_Locname, _Refs) 

{ 
} 


inline __declspec( noinline ) ctype_byname< char> ::~ctype_byname() 
{ 
} 




template class __declspec( dllimport ) codecvt< char, char, int> ;


}


#pragma warning(pop)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xiosbase"
#pragma warning(push,3)
#pragma warning(disable:4412)
#line 2508 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocale"
#pragma pack ( pop )
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xiosbase"
#pragma pack ( push, 8 )




namespace std { 
#line 42
template<class _Dummy> 
class _Iosb { friend struct __cilk_s;__CILK_METADATA(_Iosb, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


enum _Dummy_enum { _Dummy_enum_val = 1}; 

enum _Fmtflags { 

_Fmtmask = 65535, _Fmtzero = 0}; 

static const _Fmtflags skipws = ((_Fmtflags)1); 
static const _Fmtflags unitbuf = ((_Fmtflags)2); 
static const _Fmtflags uppercase = ((_Fmtflags)4); 
static const _Fmtflags showbase = ((_Fmtflags)8); 
static const _Fmtflags showpoint = ((_Fmtflags)16); 
static const _Fmtflags showpos = ((_Fmtflags)32); 
static const _Fmtflags left = ((_Fmtflags)64); 
static const _Fmtflags right = ((_Fmtflags)128); 
static const _Fmtflags internal = ((_Fmtflags)256); 
static const _Fmtflags dec = ((_Fmtflags)512); 
static const _Fmtflags oct = ((_Fmtflags)1024); 
static const _Fmtflags hex = ((_Fmtflags)2048); 
static const _Fmtflags scientific = ((_Fmtflags)4096); 
static const _Fmtflags fixed = ((_Fmtflags)8192); 

static const _Fmtflags hexfloat = ((_Fmtflags)12288); 


static const _Fmtflags boolalpha = ((_Fmtflags)16384); 
static const _Fmtflags _Stdio = ((_Fmtflags)32768); 
static const _Fmtflags adjustfield = ((_Fmtflags)((64 | 128) | 256)); 

static const _Fmtflags basefield = ((_Fmtflags)((512 | 1024) | 2048)); 

static const _Fmtflags floatfield = ((_Fmtflags)(4096 | 8192)); 


enum _Iostate { 

_Statmask = 23}; 

static const _Iostate goodbit = ((_Iostate)0); 
static const _Iostate eofbit = ((_Iostate)1); 
static const _Iostate failbit = ((_Iostate)2); 
static const _Iostate badbit = ((_Iostate)4); 
static const _Iostate _Hardfail = ((_Iostate)16); 

enum _Openmode { 

_Openmask = 255}; 

static const _Openmode in = ((_Openmode)1); 
static const _Openmode out = ((_Openmode)2); 
static const _Openmode ate = ((_Openmode)4); 
static const _Openmode app = ((_Openmode)8); 
static const _Openmode trunc = ((_Openmode)16); 
static const _Openmode _Nocreate = ((_Openmode)64); 
static const _Openmode _Noreplace = ((_Openmode)128); 
static const _Openmode binary = ((_Openmode)32); 

enum _Seekdir { 

_Seekmask = 3}; 
static const _Seekdir beg = ((_Seekdir)0); 
static const _Seekdir cur = ((_Seekdir)1); 
static const _Seekdir end = ((_Seekdir)2); 


enum { 
_Openprot = 64}; 
}; 
#line 194
class __declspec( dllimport ) ios_base : public _Iosb< int>  { friend struct __cilk_s;__CILK_METADATA(ios_base, __CILK_VBASE_DETECT)



public: typedef int fmtflags; 
typedef int iostate; 
typedef int openmode; 
typedef int seekdir; 

typedef std::streamoff streamoff; 
typedef std::streampos streampos; 

enum event { 

erase_event, imbue_event, copyfmt_event}; 

typedef void (*event_callback)(event, ios_base &, int); 
typedef unsigned io_state; typedef unsigned open_mode; typedef unsigned seek_dir; 


class failure : public runtime_error { friend struct __cilk_s;__CILK_METADATA(failure, __CILK_VBASE_DETECT)



public: inline explicit __declspec( noinline ) failure(const string &); 




inline virtual __declspec( noinline ) ~failure() throw(); 
#line 236
}; 


class __declspec( dllimport ) Init { friend struct __cilk_s;__CILK_METADATA(Init, __CILK_VBASE_DETECT)


public: inline __declspec( noinline ) Init(); 




inline __declspec( noinline ) ~Init(); 
#line 253
private: static void __cdecl _Init_ctor(Init *); 
static void __cdecl _Init_dtor(Init *); 

static int &__cdecl _Init_cnt_func(); 



static int _Init_cnt; 

}; 

inline ios_base &operator=(const ios_base &); 
#line 274
inline operator void *() const; 




inline bool operator!() const; 




inline __declspec( noinline ) void clear(iostate, bool); 
#line 299
inline void clear(iostate = ((_Iostate)0)); 




inline void clear(io_state); 




inline iostate rdstate() const; 
#line 315
inline void setstate(iostate, bool); 
#line 321
inline void setstate(iostate); 
#line 327
inline void setstate(io_state); 




inline bool good() const; 




inline bool eof() const; 




inline bool fail() const; 
#line 348
inline bool bad() const; 
#line 356
inline iostate exceptions() const; 




inline void exceptions(iostate); 
#line 367
inline void exceptions(io_state); 




inline fmtflags flags() const; 




inline fmtflags flags(fmtflags); 
#line 384
inline fmtflags setf(fmtflags); 
#line 392
inline fmtflags setf(fmtflags, fmtflags); 
#line 400
inline void unsetf(fmtflags); 




inline streamsize precision() const; 




inline streamsize precision(streamsize); 
#line 417
inline streamsize width() const; 




inline streamsize width(streamsize); 
#line 429
inline locale getloc() const; 




inline locale imbue(const locale &); 
#line 442
static inline __declspec( noinline ) int xalloc(); 
#line 449
inline long &iword(int); 




inline void *&pword(int); 




inline void register_callback(event_callback, int); 




inline ios_base &copyfmt(const ios_base &); 
#line 492
inline virtual __declspec( noinline ) ~ios_base(); 




static inline __declspec( noinline ) bool sync_with_stdio(bool = true); 
#line 506
static void __cdecl _Addstd(ios_base *); 
size_t _Stdstr; 


protected: inline ios_base(); 



inline void _Init(); 
#line 530
public: struct _Iosarray { friend struct __cilk_s;__CILK_METADATA(_Iosarray, __CILK_VBASE_DETECT)


inline _Iosarray(int, _Iosarray *); 




_Iosarray *_Next; 
int _Index; 
long _Lo; 
void *_Vp; 
}; 


struct _Fnarray { friend struct __cilk_s;__CILK_METADATA(_Fnarray, __CILK_VBASE_DETECT)

inline _Fnarray(int, event_callback, _Fnarray *); 




_Fnarray *_Next; 
int _Index; 
event_callback _Pfn; 
}; 

private: inline __declspec( noinline ) void _Callfns(event); 
#line 563
inline _Iosarray &_Findarr(int); 
#line 583
inline void _Tidy(); 
#line 598
static void __cdecl _Ios_base_dtor(ios_base *); 

iostate _Mystate; 
iostate _Except; 
fmtflags _Fmtfl; 
streamsize _Prec; 
streamsize _Wide; 
_Iosarray *_Arr; 
_Fnarray *_Calls; 
locale *_Ploc; 
#line 613
static int _Index; 
static bool _Sync; 

static int &__cdecl _Index_func(); 
static bool &__cdecl _Sync_func(); 
}; 
#line 218
inline __declspec( noinline ) ios_base::failure::failure(const string &_Message) : runtime_error(_Message) 

{ 
} 

inline __declspec( noinline ) ios_base::failure::~failure() throw() 
{ 
} 
#line 242
inline __declspec( noinline ) ios_base::Init::Init() 
{ 
_Init_ctor(this); 
} 

inline __declspec( noinline ) ios_base::Init::~Init() 
{ 
_Init_dtor(this); 
} 
#line 264
inline ios_base &ios_base::operator=(const ios_base &_Right) 
{ 
if (this != (&_Right)) 
{ 
(this->_Mystate) = _Right._Mystate; 
this->copyfmt(_Right); 
}  
return *this; 
} 

inline ios_base::operator void *() const 
{ 
return this->fail() ? (0) : ((void *)this); 
} 

inline bool ios_base::operator!() const 
{ 
return this->fail(); 
} 

inline __declspec( noinline ) void ios_base::clear(iostate _State, bool _Reraise) 
{ 
(this->_Mystate) = (iostate)(_State & (_Statmask)); 
if ((this->_Mystate & this->_Except) == 0) { 
; } else { 
if (_Reraise) { 
__cilk_s::rethrow(); } else { 
if ((this->_Mystate & this->_Except) & ((_Iostate)4)) { 
__cilk_s::throw0<failure >( ((failure)("ios_base::badbit set"))); } else { 
if ((this->_Mystate & this->_Except) & ((_Iostate)2)) { 
__cilk_s::throw0<failure >( ((failure)("ios_base::failbit set"))); } else { 

__cilk_s::throw0<failure >( ((failure)("ios_base::eofbit set"))); }  }  }  }  
} 

inline void ios_base::clear(iostate _State) 
{ 
this->clear(_State, false); 
} 

inline void ios_base::clear(io_state _State) 
{ 
this->clear((iostate)_State); 
} 

inline ios_base::iostate ios_base::rdstate() const 
{ 
return this->_Mystate; 
} 


inline void ios_base::setstate(iostate _State, bool _Exreraise) 
{ 
if (_State != ((_Iostate)0)) { 
this->clear((iostate)((int)this->rdstate() | _State), _Exreraise); }  
} 

inline void ios_base::setstate(iostate _State) 
{ 
if (_State != ((_Iostate)0)) { 
this->clear((iostate)((int)this->rdstate() | _State), false); }  
} 

inline void ios_base::setstate(io_state _State) 
{ 
this->setstate((iostate)_State); 
} 

inline bool ios_base::good() const 
{ 
return this->rdstate() == ((_Iostate)0); 
} 

inline bool ios_base::eof() const 
{ 
return (int)this->rdstate() & ((int)((_Iostate)1)); 
} 

inline bool ios_base::fail() const 
{ 
return ((int)this->rdstate() & (((int)((_Iostate)4)) | ((int)((_Iostate)2)))) != 0; 

} 

inline bool ios_base::bad() const 
{ 
return ((int)this->rdstate() & ((int)((_Iostate)4))) != 0; 
} 




inline ios_base::iostate ios_base::exceptions() const 
{ 
return this->_Except; 
} 

inline void ios_base::exceptions(iostate _Newexcept) 
{ 
(this->_Except) = (iostate)(_Newexcept & ((int)_Statmask)); 
this->clear(this->_Mystate); 
} 

inline void ios_base::exceptions(io_state _State) 
{ 
this->exceptions((iostate)_State); 
} 

inline ios_base::fmtflags ios_base::flags() const 
{ 
return this->_Fmtfl; 
} 

inline ios_base::fmtflags ios_base::flags(fmtflags _Newfmtflags) 
{ 
auto fmtflags _Oldfmtflags = (this->_Fmtfl); 
(this->_Fmtfl) = (fmtflags)(_Newfmtflags & ((int)_Fmtmask)); 
return _Oldfmtflags; 
} 

inline ios_base::fmtflags ios_base::setf(fmtflags _Newfmtflags) 
{ 
auto fmtflags _Oldfmtflags = (this->_Fmtfl); 
(this->_Fmtfl) = (fmtflags)(this->_Fmtfl | _Newfmtflags & ((int)_Fmtmask)); 

return _Oldfmtflags; 
} 

inline ios_base::fmtflags ios_base::setf(fmtflags _Newfmtflags, fmtflags _Mask) 
{ 
auto fmtflags _Oldfmtflags = (this->_Fmtfl); 
(this->_Fmtfl) = (fmtflags)(this->_Fmtfl & (int)(~_Mask) | (_Newfmtflags & _Mask) & ((int)_Fmtmask)); 

return _Oldfmtflags; 
} 

inline void ios_base::unsetf(fmtflags _Mask) 
{ 
(this->_Fmtfl) = (fmtflags)(this->_Fmtfl & (int)(~_Mask)); 
} 

inline streamsize ios_base::precision() const 
{ 
return this->_Prec; 
} 

inline streamsize ios_base::precision(streamsize _Newprecision) 
{ 
auto streamsize _Oldprecision = (this->_Prec); 
(this->_Prec) = _Newprecision; 
return _Oldprecision; 
} 

inline streamsize ios_base::width() const 
{ 
return this->_Wide; 
} 

inline streamsize ios_base::width(streamsize _Newwidth) 
{ 
auto streamsize _Oldwidth = (this->_Wide); 
(this->_Wide) = _Newwidth; 
return _Oldwidth; 
} 

inline locale ios_base::getloc() const 
{ 
return *(this->_Ploc); 
} 

inline locale ios_base::imbue(const locale &_Loc) 
{ 
auto locale _Oldlocale = *(this->_Ploc); 
((*(this->_Ploc)) = _Loc); 
this->_Callfns(imbue_event); 
return _Oldlocale; 
} 

inline __declspec( noinline ) int ios_base::xalloc() 
{ 
{ auto _Lockit _Lock(2); 
return _Index++; 
} 
} 

inline long &ios_base::iword(int _Idx) 
{ 
return this->_Findarr(_Idx)._Lo; 
} 

inline void *&ios_base::pword(int _Idx) 
{ 
return this->_Findarr(_Idx)._Vp; 
} 

inline void ios_base::register_callback(event_callback _Pfn, int _Idx) 
{ 
(this->_Calls) = (new _Fnarray(_Idx, _Pfn, this->_Calls)); 
} 

inline ios_base &ios_base::copyfmt(const ios_base &_Other) 
{ 
if (this != (&_Other)) 
{ 
this->_Tidy(); 
((*(this->_Ploc)) = (*(_Other._Ploc))); 
(this->_Fmtfl) = _Other._Fmtfl; 
(this->_Prec) = _Other._Prec; 
(this->_Wide) = _Other._Wide; 
auto _Iosarray *_Ptr = (_Other._Arr); 

for ((this->_Arr) = (0); _Ptr != (0); _Ptr = _Ptr->_Next) { 
if ((_Ptr->_Lo != (0)) || (_Ptr->_Vp != (0))) 
{ 
this->iword(_Ptr->_Index) = _Ptr->_Lo; 
this->pword(_Ptr->_Index) = _Ptr->_Vp; 
}  }  

for (_Fnarray *_Q = (_Other._Calls); _Q != (0); _Q = _Q->_Next) { 
this->register_callback(_Q->_Pfn, _Q->_Index); }  

this->_Callfns(copyfmt_event); 
this->exceptions(_Other._Except); 
}  
return *this; 
} 


inline __declspec( noinline ) ios_base::~ios_base() 
{ 
_Ios_base_dtor(this); 
} 

inline __declspec( noinline ) bool ios_base::sync_with_stdio(bool _Newsync) 
{ 
{ auto _Lockit _Lock(2); 
auto const bool _Oldsync = _Sync; 
_Sync = _Newsync; 
return _Oldsync; 
} 
} 
#line 510
inline ios_base::ios_base() 
{ 
} 

inline void ios_base::_Init() 
{ 
(this->_Ploc) = (0); 
(this->_Stdstr) = (0); 
(this->_Except) = ((_Iostate)0); 
(this->_Fmtfl) = (((_Fmtflags)1) | ((_Fmtflags)512)); 
(this->_Prec) = (6); 
(this->_Wide) = (0); 
(this->_Arr) = (0); 
(this->_Calls) = (0); 
this->clear((_Iostate)0); 
(this->_Ploc) = (new locale); 
} 
#line 533
inline ios_base::_Iosarray::_Iosarray(int _Idx, _Iosarray *_Link) : _Next(_Link), _Index(_Idx), _Lo((0)), _Vp((0)) 

{ 
} 
#line 547
inline ios_base::_Fnarray::_Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link) : _Next(_Link), _Index(_Idx), _Pfn(_Pnew) 

{ 
} 
#line 557
inline __declspec( noinline ) void ios_base::_Callfns(event _Ev) 
{ 
for (_Fnarray *_Ptr = (this->_Calls); _Ptr != (0); _Ptr = _Ptr->_Next) { 
(_Ptr->_Pfn)(_Ev, *this, _Ptr->_Index); }  
} 

inline ios_base::_Iosarray &ios_base::_Findarr(int _Idx) 
{ 
auto _Iosarray *_Ptr; auto _Iosarray *_Q; 

for ((_Ptr = this->_Arr), (_Q = (0)); _Ptr != (0); _Ptr = _Ptr->_Next) { 
if (_Ptr->_Index == _Idx) { 
return *_Ptr; } else { 
if (((_Q == (0)) && (_Ptr->_Lo == (0))) && (_Ptr->_Vp == (0))) { 
_Q = _Ptr; }  }  }  

if (_Q != (0)) 
{ 
(_Q->_Index) = _Idx; 
return *_Q; 
}  

(this->_Arr) = (new _Iosarray(_Idx, this->_Arr)); 
return *(this->_Arr); 
} 

inline void ios_base::_Tidy() 
{ 
this->_Callfns(erase_event); 
auto _Iosarray *_Q1; auto _Iosarray *_Q2; 

for (_Q1 = this->_Arr; _Q1 != (0); _Q1 = _Q2) { 
(_Q2 = _Q1->_Next), (delete _Q1); }  
(this->_Arr) = (0); 

auto _Fnarray *_Q3; auto _Fnarray *_Q4; 
for (_Q3 = this->_Calls; _Q3 != (0); _Q3 = _Q4) { 
(_Q4 = _Q3->_Next), (delete _Q3); }  
(this->_Calls) = (0); 
} 
#line 624
}

#pragma warning(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\streambuf"
#pragma warning(push,3)
#line 627 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xiosbase"
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\streambuf"
#pragma pack ( push, 8 )


namespace std { 


template<class _Elem, class 
_Traits> 
class basic_streambuf { friend struct __cilk_s;__CILK_METADATA(basic_streambuf, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


private: basic_streambuf(const std::basic_streambuf< _Elem, _Traits>  &); 

std::basic_streambuf< _Elem, _Traits>  &operator=(const std::basic_streambuf< _Elem, _Traits>  &); 



protected: inline basic_streambuf(); 
#line 32
inline basic_streambuf(_Uninitialized); inline  /* __cilk */ __thiscall basic_streambuf(__cilk_box<_Uninitialized > ); 




public: typedef std::basic_streambuf< _Elem, _Traits>  _Myt; 
typedef _Elem char_type; 
typedef _Traits traits_type; 

inline virtual ~basic_streambuf(); 




typedef typename _Traits::int_type int_type; 
typedef typename _Traits::pos_type pos_type; 
typedef typename _Traits::off_type off_type; 

inline pos_type pubseekoff(off_type, ios_base::seekdir, ios_base::openmode = (((_Iosb< int> ::_Openmode)1) | ((_Iosb< int> ::_Openmode)2))); inline pos_type  /* __cilk */ __thiscall __cilkfun_pubseekoff(__cilk_box<typename _Traits::off_type > , __cilk_box<int > , __cilk_box<int >  = (__cilk_box<int >(((_Iosb< int> ::_Openmode)1) | ((_Iosb< int> ::_Openmode)2)))); 
#line 56
inline pos_type pubseekoff(off_type, ios_base::seek_dir, ios_base::open_mode); inline pos_type  /* __cilk */ __thiscall __cilkfun_pubseekoff(__cilk_box<typename _Traits::off_type > , __cilk_box<unsigned > , __cilk_box<unsigned > ); 
#line 63
inline pos_type pubseekpos(pos_type, ios_base::openmode = (((_Iosb< int> ::_Openmode)1) | ((_Iosb< int> ::_Openmode)2))); inline pos_type  /* __cilk */ __thiscall __cilkfun_pubseekpos(__cilk_box<typename _Traits::pos_type > , __cilk_box<int >  = (__cilk_box<int >(((_Iosb< int> ::_Openmode)1) | ((_Iosb< int> ::_Openmode)2)))); 
#line 69
inline pos_type pubseekpos(pos_type, ios_base::open_mode); inline pos_type  /* __cilk */ __thiscall __cilkfun_pubseekpos(__cilk_box<typename _Traits::pos_type > , __cilk_box<unsigned > ); 




inline _Myt *pubsetbuf(_Elem *, streamsize); inline _Myt * /* __cilk */ __thiscall __cilkfun_pubsetbuf(__cilk_box<_Elem * > , __cilk_box<int > ); 




inline locale pubimbue(const locale &); inline locale  /* __cilk */ __thiscall __cilkfun_pubimbue(__cilk_box<const locale & > ); 
#line 87
inline locale getloc() const; inline locale  /* __cilk */ __thiscall __cilkfun_getloc() const; 




inline streamsize in_avail(); inline streamsize  /* __cilk */ __thiscall __cilkfun_in_avail(); 
#line 98
inline int pubsync(); inline int  /* __cilk */ __thiscall __cilkfun_pubsync(); 




inline int_type sbumpc(); inline int_type  /* __cilk */ __thiscall __cilkfun_sbumpc(); 
#line 109
inline int_type sgetc(); inline int_type  /* __cilk */ __thiscall __cilkfun_sgetc(); 
#line 115
inline streamsize _Sgetn_s(_Elem *, size_t, streamsize); inline streamsize  /* __cilk */ __thiscall __cilkfun__Sgetn_s(__cilk_box<_Elem * > , __cilk_box<unsigned > , __cilk_box<int > ); 
#line 121
inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) streamsize sgetn(_Elem *, streamsize); inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) streamsize  /* __cilk */ __thiscall __cilkfun_sgetn(__cilk_box<_Elem * > , __cilk_box<int > ); 
#line 129
inline int_type snextc(); inline int_type  /* __cilk */ __thiscall __cilkfun_snextc(); 
#line 137
inline int_type sputbackc(_Elem); inline int_type  /* __cilk */ __thiscall __cilkfun_sputbackc(__cilk_box<_Elem > ); 
#line 145
inline void stossc(); inline void  /* __cilk */ __thiscall __cilkfun_stossc(); 
#line 153
inline int_type sungetc(); inline int_type  /* __cilk */ __thiscall __cilkfun_sungetc(); 
#line 159
inline int_type sputc(_Elem); inline int_type  /* __cilk */ __thiscall __cilkfun_sputc(__cilk_box<_Elem > ); 
#line 166
inline streamsize sputn(const _Elem *, streamsize); inline streamsize  /* __cilk */ __thiscall __cilkfun_sputn(__cilk_box<const _Elem * > , __cilk_box<int > ); 




inline void _Lock(); inline void  /* __cilk */ __thiscall __cilkfun__Lock(); 




inline void _Unlock(); inline void  /* __cilk */ __thiscall __cilkfun__Unlock(); 
#line 183
protected: inline _Elem *eback() const; inline _Elem * /* __cilk */ __thiscall __cilkfun_eback() const; 




inline _Elem *gptr() const; inline _Elem * /* __cilk */ __thiscall __cilkfun_gptr() const; 




inline _Elem *pbase() const; inline _Elem * /* __cilk */ __thiscall __cilkfun_pbase() const; 




inline _Elem *pptr() const; inline _Elem * /* __cilk */ __thiscall __cilkfun_pptr() const; 




inline _Elem *egptr() const; inline _Elem * /* __cilk */ __thiscall __cilkfun_egptr() const; 




inline void gbump(int); inline void  /* __cilk */ __thiscall __cilkfun_gbump(__cilk_box<int > ); 
#line 214
inline void setg(_Elem *, _Elem *, _Elem *); inline void  /* __cilk */ __thiscall __cilkfun_setg(__cilk_box<_Elem * > , __cilk_box<_Elem * > , __cilk_box<_Elem * > ); 
#line 221
inline _Elem *epptr() const; inline _Elem * /* __cilk */ __thiscall __cilkfun_epptr() const; 




inline _Elem *_Gndec(); inline _Elem * /* __cilk */ __thiscall __cilkfun__Gndec(); 
#line 232
inline _Elem *_Gninc(); inline _Elem * /* __cilk */ __thiscall __cilkfun__Gninc(); 
#line 238
inline _Elem *_Gnpreinc(); inline _Elem * /* __cilk */ __thiscall __cilkfun__Gnpreinc(); 
#line 244
inline streamsize _Gnavail() const; inline streamsize  /* __cilk */ __thiscall __cilkfun__Gnavail() const; 




inline void pbump(int); inline void  /* __cilk */ __thiscall __cilkfun_pbump(__cilk_box<int > ); 
#line 255
inline void setp(_Elem *, _Elem *); inline void  /* __cilk */ __thiscall __cilkfun_setp(__cilk_box<_Elem * > , __cilk_box<_Elem * > ); 
#line 262
inline void setp(_Elem *, _Elem *, _Elem *); inline void  /* __cilk */ __thiscall __cilkfun_setp(__cilk_box<_Elem * > , __cilk_box<_Elem * > , __cilk_box<_Elem * > ); 
#line 269
inline _Elem *_Pninc(); inline _Elem * /* __cilk */ __thiscall __cilkfun__Pninc(); 
#line 275
inline streamsize _Pnavail() const; inline streamsize  /* __cilk */ __thiscall __cilkfun__Pnavail() const; 




inline void _Init(); inline void  /* __cilk */ __thiscall __cilkfun__Init(); 
#line 288
inline void _Init(_Elem **, _Elem **, int *, _Elem **, _Elem **, int *); inline void  /* __cilk */ __thiscall __cilkfun__Init(__cilk_box<_Elem ** > , __cilk_box<_Elem ** > , __cilk_box<int * > , __cilk_box<_Elem ** > , __cilk_box<_Elem ** > , __cilk_box<int * > ); 
#line 296
inline virtual int_type overflow(typename __cilk_maybe_box<basic_streambuf, typename _Traits::int_type >::type  = (__cilk_maybe_box<basic_streambuf, int_type >::type (_Traits::eof()))); 




inline virtual int_type pbackfail(typename __cilk_maybe_box<basic_streambuf, typename _Traits::int_type >::type  = (__cilk_maybe_box<basic_streambuf, int_type >::type (_Traits::eof()))); 




inline virtual streamsize showmanyc(); 




inline virtual int_type underflow(); 




inline virtual int_type uflow(); 
#line 323
inline virtual __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) streamsize xsgetn(typename __cilk_maybe_box<basic_streambuf, _Elem * >::type , typename __cilk_maybe_box<basic_streambuf, int >::type ); 
#line 330
inline virtual streamsize _Xsgetn_s(typename __cilk_maybe_box<basic_streambuf, _Elem * >::type , typename __cilk_maybe_box<basic_streambuf, unsigned >::type , typename __cilk_maybe_box<basic_streambuf, int >::type ); 
#line 360
inline virtual streamsize xsputn(typename __cilk_maybe_box<basic_streambuf, const _Elem * >::type , typename __cilk_maybe_box<basic_streambuf, int >::type ); 
#line 390
inline virtual pos_type seekoff(typename __cilk_maybe_box<basic_streambuf, typename _Traits::off_type >::type , typename __cilk_maybe_box<basic_streambuf, int >::type , typename __cilk_maybe_box<basic_streambuf, int >::type  = (__cilk_maybe_box<basic_streambuf, ios_base::openmode >::type (((_Iosb< int> ::_Openmode)1) | ((_Iosb< int> ::_Openmode)2)))); 
#line 396
inline virtual pos_type seekpos(typename __cilk_maybe_box<basic_streambuf, typename _Traits::pos_type >::type , typename __cilk_maybe_box<basic_streambuf, int >::type  = (__cilk_maybe_box<basic_streambuf, ios_base::openmode >::type (((_Iosb< int> ::_Openmode)1) | ((_Iosb< int> ::_Openmode)2)))); 
#line 402
inline virtual _Myt *setbuf(typename __cilk_maybe_box<basic_streambuf, _Elem * >::type , typename __cilk_maybe_box<basic_streambuf, int >::type ); 




inline virtual int sync(); 




inline virtual void imbue(typename __cilk_maybe_box<basic_streambuf, const locale & >::type ); 




private: _Mutex _Mylock; 
_Elem *_Gfirst; 
_Elem *_Pfirst; 
_Elem **_IGfirst; 
_Elem **_IPfirst; 
_Elem *_Gnext; 
_Elem *_Pnext; 
_Elem **_IGnext; 
_Elem **_IPnext; 
int _Gcount; 
int _Pcount; 
int *_IGcount; 
int *_IPcount; 
locale *_Plocale; 
}; 



template class __declspec( dllimport ) basic_streambuf< char, char_traits< char> > ;
template class __declspec( dllimport ) basic_streambuf< __wchar_t, char_traits< __wchar_t> > ;
#line 443
template<class _Elem, class 
_Traits> 
class istreambuf_iterator : public iterator< input_iterator_tag, _Elem, typename _Traits::off_type, _Elem *, _Elem &>  { friend struct __cilk_s;__CILK_METADATA(istreambuf_iterator, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



typedef std::istreambuf_iterator< _Elem, _Traits>  _Myt; 

typedef _Elem char_type; 
typedef _Traits traits_type; 
typedef basic_streambuf< _Elem, _Traits>  streambuf_type; 
typedef basic_istream< _Elem, _Traits>  istream_type; 

typedef typename _Traits::int_type int_type; 


typedef _Range_checked_iterator_tag _Checked_iterator_category; 


inline istreambuf_iterator(typename __cilk_maybe_box<istreambuf_iterator, streambuf_type * >::type  = (__cilk_maybe_box<istreambuf_iterator, streambuf_type * >::type (0))) throw(); 




inline istreambuf_iterator(istream_type &) throw(); inline  /* __cilk */ __thiscall istreambuf_iterator(__cilk_box<istream_type & > ) throw(); 




inline _Elem operator*() const; 
#line 485
inline _Myt &operator++(); 
#line 497
inline _Myt operator++(int); 
#line 506
inline bool equal(const _Myt &) const; inline bool  /* __cilk */ __thiscall __cilkfun_equal(__cilk_box<const _Myt & > ) const; 
#line 517
private: inline void _Inc(); inline void  /* __cilk */ __thiscall __cilkfun__Inc(); 
#line 527
inline _Elem _Peek(); inline _Elem  /* __cilk */ __thiscall __cilkfun__Peek(); 
#line 540
streambuf_type *_Strbuf; 
bool _Got; 
_Elem _Val; 
}; 


template<class _Elem, class 
_Traits> inline bool 
operator==(const istreambuf_iterator< _Elem, _Traits>  &, const istreambuf_iterator< _Elem, _Traits>  &); 
#line 546
template<class _Elem, class 
_Traits> inline bool  /* __cilk */ __cdecl 
__cilk_op_eq(__cilk_box<const istreambuf_iterator< _Elem, _Traits>  & > , __cilk_box<const istreambuf_iterator< _Elem, _Traits>  & > ); 
#line 555
template<class _Elem, class 
_Traits> inline bool 
operator!=(const istreambuf_iterator< _Elem, _Traits>  &, const istreambuf_iterator< _Elem, _Traits>  &); 
#line 555
template<class _Elem, class 
_Traits> inline bool  /* __cilk */ __cdecl 
__cilk_op_ne(__cilk_box<const istreambuf_iterator< _Elem, _Traits>  & > , __cilk_box<const istreambuf_iterator< _Elem, _Traits>  & > ); 
#line 565
template<class _Elem, class 
_Traits> 
class ostreambuf_iterator : public _Outit { friend struct __cilk_s;__CILK_METADATA(ostreambuf_iterator, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef std::ostreambuf_iterator< _Elem, _Traits>  _Myt; 

typedef _Elem char_type; 
typedef _Traits traits_type; 
typedef basic_streambuf< _Elem, _Traits>  streambuf_type; 
typedef basic_ostream< _Elem, _Traits>  ostream_type; 


typedef _Range_checked_iterator_tag _Checked_iterator_category; 


inline ostreambuf_iterator(streambuf_type *) throw(); inline  /* __cilk */ __thiscall ostreambuf_iterator(__cilk_box<streambuf_type * > ) throw(); 




inline ostreambuf_iterator(ostream_type &) throw(); inline  /* __cilk */ __thiscall ostreambuf_iterator(__cilk_box<ostream_type & > ) throw(); 




inline _Myt &operator=(_Elem); inline _Myt & /* __cilk */ __thiscall operator=(__cilk_box<_Elem > ); 
#line 600
inline _Myt &operator*(); 




inline _Myt &operator++(); 




inline _Myt &operator++(int); 




inline bool failed() const throw(); inline bool  /* __cilk */ __thiscall __cilkfun_failed() const throw(); 
#line 621
private: bool _Failed; 
streambuf_type *_Strbuf; 
}; 
}

#pragma warning(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocnum"
#pragma warning(push,3)
#line 627 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\streambuf"
#pragma pack ( pop )
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocnum"
#pragma pack ( push, 8 )
#line 21
extern "C" { extern __declspec( dllimport ) float __cdecl _Stofx(const char *, char **, long, int *); } 

extern "C" { extern __declspec( dllimport ) double __cdecl _Stodx(const char *, char **, long, int *); } 

extern "C" { extern __declspec( dllimport ) long double __cdecl _Stoldx(const char *, char **, long, int *); } 

extern "C" { extern __declspec( dllimport ) long __cdecl _Stolx(const char *, char **, int, int *); } 

extern "C" { extern __declspec( dllimport ) unsigned long __cdecl _Stoulx(const char *, char **, int, int *); } 




extern "C" { extern __declspec( dllimport ) __int64 __cdecl _Stollx(const char *, char **, int, int *); } 

extern "C" { extern __declspec( dllimport ) unsigned __int64 __cdecl _Stoullx(const char *, char **, int, int *); } 
#line 50
namespace std { 



#pragma warning(push)
#pragma warning(disable:4275)

template<class _Elem> 
class numpunct : public locale::facet { friend struct __cilk_s;__CILK_METADATA(numpunct, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;




typedef basic_string< _Elem, char_traits< _Elem> , allocator< _Elem> >  string_type; 
typedef _Elem char_type; 

static locale::id id; 

inline _Elem decimal_point() const; inline _Elem  /* __cilk */ __thiscall __cilkfun_decimal_point() const; 




inline _Elem thousands_sep() const; inline _Elem  /* __cilk */ __thiscall __cilkfun_thousands_sep() const; 




inline string grouping() const; inline string  /* __cilk */ __thiscall __cilkfun_grouping() const; 




inline string_type falsename() const; inline string_type  /* __cilk */ __thiscall __cilkfun_falsename() const; 




inline string_type truename() const; inline string_type  /* __cilk */ __thiscall __cilkfun_truename() const; 




inline explicit numpunct(typename __cilk_maybe_box<numpunct, unsigned >::type  = (__cilk_maybe_box<numpunct, size_t >::type (0))); 
#line 104
inline numpunct(const _Locinfo &, size_t = (0), bool = false); inline  /* __cilk */ __thiscall numpunct(__cilk_box<const _Locinfo & > , __cilk_box<unsigned >  = (__cilk_box<unsigned >(0)), __cilk_box<bool >  = (__cilk_box<bool >(false))); 
#line 110
static inline size_t _Getcat(const locale::facet ** = 0, const locale * = 0); static inline size_t  /* __cilk */ __cdecl __cilkfun__Getcat(__cilk_box<const locale::facet ** >  = (__cilk_box<const locale::facet ** >(0)), __cilk_box<const locale * >  = (__cilk_box<const locale * >(0))); 
#line 120
protected: inline virtual ~numpunct(); 
#line 126
inline numpunct(const char *, size_t = (0), bool = false); inline  /* __cilk */ __thiscall numpunct(__cilk_box<const char * > , __cilk_box<unsigned >  = (__cilk_box<unsigned >(0)), __cilk_box<bool >  = (__cilk_box<bool >(false))); 
#line 134
inline void _Init(const _Locinfo &, bool = false); inline void  /* __cilk */ __thiscall __cilkfun__Init(__cilk_box<const _Locinfo & > , __cilk_box<bool >  = (__cilk_box<bool >(false))); 
#line 163
inline virtual _Elem do_decimal_point() const; 




inline virtual _Elem do_thousands_sep() const; 




inline virtual string do_grouping() const; 




inline virtual string_type do_falsename() const; 




inline virtual string_type do_truename() const; 
#line 189
private: inline void _Tidy(); inline void  /* __cilk */ __thiscall __cilkfun__Tidy(); 
#line 196
const char *_Grouping; 
_Elem _Dp; 
_Elem _Kseparator; 
const _Elem *_Falsename; 
const _Elem *_Truename; 
}; 

typedef numpunct< char>  _Npc; 
typedef numpunct< __wchar_t>  _Npwc; 


template<class _Elem> 
class numpunct_byname : public numpunct< _Elem>  { friend struct __cilk_s;__CILK_METADATA(numpunct_byname, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



inline explicit numpunct_byname(const char *, size_t = (0)); inline explicit  /* __cilk */ __thiscall numpunct_byname(__cilk_box<const char * > , __cilk_box<unsigned >  = (__cilk_box<unsigned >(0))); 
#line 218
protected: inline virtual ~numpunct_byname(); 


}; 
#line 228
template<class _Elem, class 
_InIt> 
class num_get : public locale::facet { friend struct __cilk_s;__CILK_METADATA(num_get, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



typedef numpunct< _Elem>  _Mypunct; 

typedef basic_string< _Elem, char_traits< _Elem> , allocator< _Elem> >  _Mystr; 

static inline size_t _Getcat(const locale::facet ** = 0, const locale * = 0); static inline size_t  /* __cilk */ __cdecl __cilkfun__Getcat(__cilk_box<const locale::facet ** >  = (__cilk_box<const locale::facet ** >(0)), __cilk_box<const locale * >  = (__cilk_box<const locale * >(0))); 
#line 247
static locale::id id; 


protected: inline virtual ~num_get(); 




inline void _Init(const _Locinfo &); inline void  /* __cilk */ __thiscall __cilkfun__Init(__cilk_box<const _Locinfo & > ); 




_Locinfo::_Cvtvec _Cvt; 


public: inline explicit num_get(typename __cilk_maybe_box<num_get, unsigned >::type  = (__cilk_maybe_box<num_get, size_t >::type (0))); 
#line 271
inline num_get(const _Locinfo &, size_t = (0)); inline  /* __cilk */ __thiscall num_get(__cilk_box<const _Locinfo & > , __cilk_box<unsigned >  = (__cilk_box<unsigned >(0))); 
#line 277
typedef _Elem char_type; 
typedef _InIt iter_type; 

inline _InIt get(_InIt, _InIt, ios_base &, ios_base::iostate &, _Bool &) const; inline _InIt  /* __cilk */ __thiscall __cilkfun_get(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<ios_base & > , __cilk_box<ios_base::iostate & > , __cilk_box<_Bool & > ) const; 
#line 287
inline _InIt get(_InIt, _InIt, ios_base &, ios_base::iostate &, unsigned short &) const; inline _InIt  /* __cilk */ __thiscall __cilkfun_get(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<ios_base & > , __cilk_box<ios_base::iostate & > , __cilk_box<unsigned short & > ) const; 
#line 294
inline _InIt get(_InIt, _InIt, ios_base &, ios_base::iostate &, unsigned &) const; inline _InIt  /* __cilk */ __thiscall __cilkfun_get(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<ios_base & > , __cilk_box<ios_base::iostate & > , __cilk_box<unsigned & > ) const; 
#line 301
inline _InIt get(_InIt, _InIt, ios_base &, ios_base::iostate &, long &) const; inline _InIt  /* __cilk */ __thiscall __cilkfun_get(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<ios_base & > , __cilk_box<ios_base::iostate & > , __cilk_box<long & > ) const; 
#line 308
inline _InIt get(_InIt, _InIt, ios_base &, ios_base::iostate &, unsigned long &) const; inline _InIt  /* __cilk */ __thiscall __cilkfun_get(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<ios_base & > , __cilk_box<ios_base::iostate & > , __cilk_box<unsigned long & > ) const; 
#line 316
inline _InIt get(_InIt, _InIt, ios_base &, ios_base::iostate &, __int64 &) const; inline _InIt  /* __cilk */ __thiscall __cilkfun_get(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<ios_base & > , __cilk_box<ios_base::iostate & > , __cilk_box<__int64 & > ) const; 
#line 323
inline _InIt get(_InIt, _InIt, ios_base &, ios_base::iostate &, unsigned __int64 &) const; inline _InIt  /* __cilk */ __thiscall __cilkfun_get(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<ios_base & > , __cilk_box<ios_base::iostate & > , __cilk_box<unsigned __int64 & > ) const; 
#line 331
inline _InIt get(_InIt, _InIt, ios_base &, ios_base::iostate &, float &) const; inline _InIt  /* __cilk */ __thiscall __cilkfun_get(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<ios_base & > , __cilk_box<ios_base::iostate & > , __cilk_box<float & > ) const; 
#line 338
inline _InIt get(_InIt, _InIt, ios_base &, ios_base::iostate &, double &) const; inline _InIt  /* __cilk */ __thiscall __cilkfun_get(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<ios_base & > , __cilk_box<ios_base::iostate & > , __cilk_box<double & > ) const; 
#line 345
inline _InIt get(_InIt, _InIt, ios_base &, ios_base::iostate &, long double &) const; inline _InIt  /* __cilk */ __thiscall __cilkfun_get(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<ios_base & > , __cilk_box<ios_base::iostate & > , __cilk_box<long double & > ) const; 
#line 352
inline _InIt get(_InIt, _InIt, ios_base &, ios_base::iostate &, void *&) const; inline _InIt  /* __cilk */ __thiscall __cilkfun_get(__cilk_box<_InIt > , __cilk_box<_InIt > , __cilk_box<ios_base & > , __cilk_box<ios_base::iostate & > , __cilk_box<void *& > ) const; 
#line 360
protected: inline virtual _InIt do_get(typename __cilk_maybe_box<num_get, _InIt >::type , typename __cilk_maybe_box<num_get, _InIt >::type , typename __cilk_maybe_box<num_get, ios_base & >::type , typename __cilk_maybe_box<num_get, ios_base::iostate & >::type , typename __cilk_maybe_box<num_get, _Bool & >::type ) const; 
#line 397
inline virtual _InIt do_get(typename __cilk_maybe_box<num_get, _InIt >::type , typename __cilk_maybe_box<num_get, _InIt >::type , typename __cilk_maybe_box<num_get, ios_base & >::type , typename __cilk_maybe_box<num_get, ios_base::iostate & >::type , typename __cilk_maybe_box<num_get, unsigned short & >::type ) const; 
#line 420
inline virtual _InIt do_get(typename __cilk_maybe_box<num_get, _InIt >::type , typename __cilk_maybe_box<num_get, _InIt >::type , typename __cilk_maybe_box<num_get, ios_base & >::type , typename __cilk_maybe_box<num_get, ios_base::iostate & >::type , typename __cilk_maybe_box<num_get, unsigned & >::type ) const; 
#line 442
inline virtual _InIt do_get(typename __cilk_maybe_box<num_get, _InIt >::type , typename __cilk_maybe_box<num_get, _InIt >::type , typename __cilk_maybe_box<num_get, ios_base & >::type , typename __cilk_maybe_box<num_get, ios_base::iostate & >::type , typename __cilk_maybe_box<num_get, long & >::type ) const; 
#line 462
inline virtual _InIt do_get(typename __cilk_maybe_box<num_get, _InIt >::type , typename __cilk_maybe_box<num_get, _InIt >::type , typename __cilk_maybe_box<num_get, ios_base & >::type , typename __cilk_maybe_box<num_get, ios_base::iostate & >::type , typename __cilk_maybe_box<num_get, unsigned long & >::type ) const; 
#line 483
inline virtual _InIt do_get(typename __cilk_maybe_box<num_get, _InIt >::type , typename __cilk_maybe_box<num_get, _InIt >::type , typename __cilk_maybe_box<num_get, ios_base & >::type , typename __cilk_maybe_box<num_get, ios_base::iostate & >::type , typename __cilk_maybe_box<num_get, __int64 & >::type ) const; 
#line 503
inline virtual _InIt do_get(typename __cilk_maybe_box<num_get, _InIt >::type , typename __cilk_maybe_box<num_get, _InIt >::type , typename __cilk_maybe_box<num_get, ios_base & >::type , typename __cilk_maybe_box<num_get, ios_base::iostate & >::type , typename __cilk_maybe_box<num_get, unsigned __int64 & >::type ) const; 
#line 524
inline virtual _InIt do_get(typename __cilk_maybe_box<num_get, _InIt >::type , typename __cilk_maybe_box<num_get, _InIt >::type , typename __cilk_maybe_box<num_get, ios_base & >::type , typename __cilk_maybe_box<num_get, ios_base::iostate & >::type , typename __cilk_maybe_box<num_get, float & >::type ) const; 
#line 544
inline virtual _InIt do_get(typename __cilk_maybe_box<num_get, _InIt >::type , typename __cilk_maybe_box<num_get, _InIt >::type , typename __cilk_maybe_box<num_get, ios_base & >::type , typename __cilk_maybe_box<num_get, ios_base::iostate & >::type , typename __cilk_maybe_box<num_get, double & >::type ) const; 
#line 564
inline virtual _InIt do_get(typename __cilk_maybe_box<num_get, _InIt >::type , typename __cilk_maybe_box<num_get, _InIt >::type , typename __cilk_maybe_box<num_get, ios_base & >::type , typename __cilk_maybe_box<num_get, ios_base::iostate & >::type , typename __cilk_maybe_box<num_get, long double & >::type ) const; 
#line 584
inline virtual _InIt do_get(typename __cilk_maybe_box<num_get, _InIt >::type , typename __cilk_maybe_box<num_get, _InIt >::type , typename __cilk_maybe_box<num_get, ios_base & >::type , typename __cilk_maybe_box<num_get, ios_base::iostate & >::type , typename __cilk_maybe_box<num_get, void *& >::type ) const; 
#line 616
private: inline int _Getifld(char *, _InIt &, _InIt &, ios_base::fmtflags, const locale &) const; inline int  /* __cilk */ __thiscall __cilkfun__Getifld(__cilk_box<char * > , __cilk_box<_InIt & > , __cilk_box<_InIt & > , __cilk_box<int > , __cilk_box<const locale & > ) const; 
#line 703
inline int _Getffld(char *, _InIt &, _InIt &, const locale &) const; inline int  /* __cilk */ __thiscall __cilkfun__Getffld(__cilk_box<char * > , __cilk_box<_InIt & > , __cilk_box<_InIt & > , __cilk_box<const locale & > ) const; 
#line 844
inline int _Hexdig(const _Elem, const _Elem, const _Elem, const _Elem) const; inline int  /* __cilk */ __thiscall __cilkfun__Hexdig(__cilk_box<_Elem > , __cilk_box<_Elem > , __cilk_box<_Elem > , __cilk_box<_Elem > ) const; 
#line 857
inline int __cdecl _Getffldx(char *, _InIt &, _InIt &, ios_base &, int *) const; 
#line 1013
}; 
#line 1021
template<class _Elem, class 
_OutIt> 
class num_put : public locale::facet { friend struct __cilk_s;__CILK_METADATA(num_put, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



typedef numpunct< _Elem>  _Mypunct; 

typedef basic_string< _Elem, char_traits< _Elem> , allocator< _Elem> >  _Mystr; 

static inline size_t _Getcat(const locale::facet ** = 0, const locale * = 0); static inline size_t  /* __cilk */ __cdecl __cilkfun__Getcat(__cilk_box<const locale::facet ** >  = (__cilk_box<const locale::facet ** >(0)), __cilk_box<const locale * >  = (__cilk_box<const locale * >(0))); 
#line 1040
static locale::id id; 


protected: inline virtual ~num_put(); 




inline void _Init(const _Locinfo &); inline void  /* __cilk */ __thiscall __cilkfun__Init(__cilk_box<const _Locinfo & > ); 




_Locinfo::_Cvtvec _Cvt; 


public: inline explicit num_put(typename __cilk_maybe_box<num_put, unsigned >::type  = (__cilk_maybe_box<num_put, size_t >::type (0))); 
#line 1064
inline num_put(const _Locinfo &, size_t = (0)); inline  /* __cilk */ __thiscall num_put(__cilk_box<const _Locinfo & > , __cilk_box<unsigned >  = (__cilk_box<unsigned >(0))); 
#line 1070
typedef _Elem char_type; 
typedef _OutIt iter_type; 

inline _OutIt put(_OutIt, ios_base &, _Elem, _Bool) const; inline _OutIt  /* __cilk */ __thiscall __cilkfun_put(__cilk_box<_OutIt > , __cilk_box<ios_base & > , __cilk_box<_Elem > , __cilk_box<bool > ) const; 
#line 1079
inline _OutIt put(_OutIt, ios_base &, _Elem, long) const; inline _OutIt  /* __cilk */ __thiscall __cilkfun_put(__cilk_box<_OutIt > , __cilk_box<ios_base & > , __cilk_box<_Elem > , __cilk_box<long > ) const; 
#line 1085
inline _OutIt put(_OutIt, ios_base &, _Elem, unsigned long) const; inline _OutIt  /* __cilk */ __thiscall __cilkfun_put(__cilk_box<_OutIt > , __cilk_box<ios_base & > , __cilk_box<_Elem > , __cilk_box<unsigned long > ) const; 
#line 1092
inline _OutIt put(_OutIt, ios_base &, _Elem, __int64) const; inline _OutIt  /* __cilk */ __thiscall __cilkfun_put(__cilk_box<_OutIt > , __cilk_box<ios_base & > , __cilk_box<_Elem > , __cilk_box<__int64 > ) const; 
#line 1098
inline _OutIt put(_OutIt, ios_base &, _Elem, unsigned __int64) const; inline _OutIt  /* __cilk */ __thiscall __cilkfun_put(__cilk_box<_OutIt > , __cilk_box<ios_base & > , __cilk_box<_Elem > , __cilk_box<unsigned __int64 > ) const; 
#line 1105
inline _OutIt put(_OutIt, ios_base &, _Elem, double) const; inline _OutIt  /* __cilk */ __thiscall __cilkfun_put(__cilk_box<_OutIt > , __cilk_box<ios_base & > , __cilk_box<_Elem > , __cilk_box<double > ) const; 
#line 1111
inline _OutIt put(_OutIt, ios_base &, _Elem, long double) const; inline _OutIt  /* __cilk */ __thiscall __cilkfun_put(__cilk_box<_OutIt > , __cilk_box<ios_base & > , __cilk_box<_Elem > , __cilk_box<long double > ) const; 
#line 1117
inline _OutIt put(_OutIt, ios_base &, _Elem, const void *) const; inline _OutIt  /* __cilk */ __thiscall __cilkfun_put(__cilk_box<_OutIt > , __cilk_box<ios_base & > , __cilk_box<_Elem > , __cilk_box<const void * > ) const; 
#line 1124
protected: inline virtual _OutIt do_put(typename __cilk_maybe_box<num_put, _OutIt >::type , typename __cilk_maybe_box<num_put, ios_base & >::type , typename __cilk_maybe_box<num_put, _Elem >::type , typename __cilk_maybe_box<num_put, bool >::type ) const; 
#line 1154
inline virtual _OutIt do_put(typename __cilk_maybe_box<num_put, _OutIt >::type , typename __cilk_maybe_box<num_put, ios_base & >::type , typename __cilk_maybe_box<num_put, _Elem >::type , typename __cilk_maybe_box<num_put, long >::type ) const; 
#line 1164
inline virtual _OutIt do_put(typename __cilk_maybe_box<num_put, _OutIt >::type , typename __cilk_maybe_box<num_put, ios_base & >::type , typename __cilk_maybe_box<num_put, _Elem >::type , typename __cilk_maybe_box<num_put, unsigned long >::type ) const; 
#line 1175
inline virtual _OutIt do_put(typename __cilk_maybe_box<num_put, _OutIt >::type , typename __cilk_maybe_box<num_put, ios_base & >::type , typename __cilk_maybe_box<num_put, _Elem >::type , typename __cilk_maybe_box<num_put, __int64 >::type ) const; 
#line 1185
inline virtual _OutIt do_put(typename __cilk_maybe_box<num_put, _OutIt >::type , typename __cilk_maybe_box<num_put, ios_base & >::type , typename __cilk_maybe_box<num_put, _Elem >::type , typename __cilk_maybe_box<num_put, unsigned __int64 >::type ) const; 
#line 1196
inline virtual _OutIt do_put(typename __cilk_maybe_box<num_put, _OutIt >::type , typename __cilk_maybe_box<num_put, ios_base & >::type , typename __cilk_maybe_box<num_put, _Elem >::type , typename __cilk_maybe_box<num_put, double >::type ) const; 
#line 1238
inline virtual _OutIt do_put(typename __cilk_maybe_box<num_put, _OutIt >::type , typename __cilk_maybe_box<num_put, ios_base & >::type , typename __cilk_maybe_box<num_put, _Elem >::type , typename __cilk_maybe_box<num_put, long double >::type ) const; 
#line 1279
inline virtual _OutIt do_put(typename __cilk_maybe_box<num_put, _OutIt >::type , typename __cilk_maybe_box<num_put, ios_base & >::type , typename __cilk_maybe_box<num_put, _Elem >::type , typename __cilk_maybe_box<num_put, const void * >::type ) const; 
#line 1289
private: inline char *_Ffmt(char *, char, ios_base::fmtflags) const; inline char * /* __cilk */ __thiscall __cilkfun__Ffmt(__cilk_box<char * > , __cilk_box<char > , __cilk_box<int > ) const; 
#line 1312
inline _OutIt _Fput(_OutIt, ios_base &, _Elem, const char *, size_t, size_t, size_t, size_t) const; inline _OutIt  /* __cilk */ __thiscall __cilkfun__Fput(__cilk_box<_OutIt > , __cilk_box<ios_base & > , __cilk_box<_Elem > , __cilk_box<const char * > , __cilk_box<unsigned > , __cilk_box<unsigned > , __cilk_box<unsigned > , __cilk_box<unsigned > ) const; 
#line 1432
inline char *_Ifmt(char *, const char *, ios_base::fmtflags) const; inline char * /* __cilk */ __thiscall __cilkfun__Ifmt(__cilk_box<char * > , __cilk_box<const char * > , __cilk_box<int > ) const; 
#line 1459
inline _OutIt _Iput(_OutIt, ios_base &, _Elem, char *, size_t) const; inline _OutIt  /* __cilk */ __thiscall __cilkfun__Iput(__cilk_box<_OutIt > , __cilk_box<ios_base & > , __cilk_box<_Elem > , __cilk_box<char * > , __cilk_box<unsigned > ) const; 
#line 1510
inline _OutIt _Put(_OutIt, const _Elem *, size_t) const; inline _OutIt  /* __cilk */ __thiscall __cilkfun__Put(__cilk_box<_OutIt > , __cilk_box<const _Elem * > , __cilk_box<unsigned > ) const; 
#line 1518
inline _OutIt _Putc(_OutIt, const char *, size_t) const; inline _OutIt  /* __cilk */ __thiscall __cilkfun__Putc(__cilk_box<_OutIt > , __cilk_box<const char * > , __cilk_box<unsigned > ) const; 
#line 1526
inline _OutIt _Putgrouped(_OutIt, const char *, size_t, _Elem) const; inline _OutIt  /* __cilk */ __thiscall __cilkfun__Putgrouped(__cilk_box<_OutIt > , __cilk_box<const char * > , __cilk_box<unsigned > , __cilk_box<_Elem > ) const; 
#line 1545
inline _OutIt _Rep(_OutIt, _Elem, size_t) const; inline _OutIt  /* __cilk */ __thiscall __cilkfun__Rep(__cilk_box<_OutIt > , __cilk_box<_Elem > , __cilk_box<unsigned > ) const; 
#line 1552
}; 
#line 1561
template class __declspec( dllimport ) numpunct< char> ;
template class __declspec( dllimport ) num_get< char, istreambuf_iterator< char, char_traits< char> > > ;

template class __declspec( dllimport ) num_put< char, ostreambuf_iterator< char, char_traits< char> > > ;


template class __declspec( dllimport ) numpunct< __wchar_t> ;
template class __declspec( dllimport ) num_get< __wchar_t, istreambuf_iterator< __wchar_t, char_traits< __wchar_t> > > ;

template class __declspec( dllimport ) num_put< __wchar_t, ostreambuf_iterator< __wchar_t, char_traits< __wchar_t> > > ;
#line 1577
#pragma warning(pop)
}


#pragma warning(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ios"
#pragma warning(push,3)
#line 1582 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocnum"
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ios"
#pragma pack ( push, 8 )



namespace std { 


template<class _Elem, class 
_Traits> 
class basic_ios : public ios_base { friend struct __cilk_s;__CILK_METADATA(basic_ios, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



typedef std::basic_ios< _Elem, _Traits>  _Myt; 
typedef basic_ostream< _Elem, _Traits>  _Myos; 
typedef basic_streambuf< _Elem, _Traits>  _Mysb; 
typedef ctype< _Elem>  _Ctype; 
typedef _Elem char_type; 
typedef _Traits traits_type; 
typedef typename _Traits::int_type int_type; 
typedef typename _Traits::pos_type pos_type; 
typedef typename _Traits::off_type off_type; 

inline explicit basic_ios(_Mysb *); inline explicit  /* __cilk */ __thiscall basic_ios(__cilk_box<_Mysb * > ); 




inline virtual ~basic_ios(); 



inline void clear(iostate = ((_Iostate)0), bool = false); inline void  /* __cilk */ __thiscall __cilkfun_clear(__cilk_box<int >  = (__cilk_box<int >((_Iostate)0)), __cilk_box<bool >  = (__cilk_box<bool >(false))); 
#line 47
inline void clear(io_state); inline void  /* __cilk */ __thiscall __cilkfun_clear(__cilk_box<unsigned > ); 




inline void setstate(iostate, bool = false); inline void  /* __cilk */ __thiscall __cilkfun_setstate(__cilk_box<int > , __cilk_box<bool >  = (__cilk_box<bool >(false))); 
#line 58
inline void setstate(io_state); inline void  /* __cilk */ __thiscall __cilkfun_setstate(__cilk_box<unsigned > ); 




inline _Myt &copyfmt(const _Myt &); inline _Myt & /* __cilk */ __thiscall __cilkfun_copyfmt(__cilk_box<const _Myt & > ); 
#line 71
inline _Myos *tie() const; inline _Myos * /* __cilk */ __thiscall __cilkfun_tie() const; 




inline _Myos *tie(_Myos *); inline _Myos * /* __cilk */ __thiscall __cilkfun_tie(__cilk_box<_Myos * > ); 
#line 83
inline _Mysb *rdbuf() const; inline _Mysb * /* __cilk */ __thiscall __cilkfun_rdbuf() const; 




inline _Mysb *rdbuf(_Mysb *); inline _Mysb * /* __cilk */ __thiscall __cilkfun_rdbuf(__cilk_box<_Mysb * > ); 
#line 96
inline locale imbue(const locale &); inline locale  /* __cilk */ __thiscall __cilkfun_imbue(__cilk_box<const locale & > ); 
#line 104
inline _Elem fill() const; inline _Elem  /* __cilk */ __thiscall __cilkfun_fill() const; 




inline _Elem fill(_Elem); inline _Elem  /* __cilk */ __thiscall __cilkfun_fill(__cilk_box<_Elem > ); 
#line 116
inline char narrow(_Elem, char = '\000') const; inline char  /* __cilk */ __thiscall __cilkfun_narrow(__cilk_box<_Elem > , __cilk_box<char >  = (__cilk_box<char >('\000'))) const; 
#line 122
inline _Elem widen(char) const; inline _Elem  /* __cilk */ __thiscall __cilkfun_widen(__cilk_box<char > ) const; 
#line 129
protected: inline void init(_Mysb * = (0), bool = false); inline void  /* __cilk */ __thiscall __cilkfun_init(__cilk_box<_Mysb * >  = (__cilk_box<_Mysb * >(0)), __cilk_box<bool >  = (__cilk_box<bool >(false))); 
#line 146
inline basic_ios(); 




private: basic_ios(const _Myt &); 
_Myt &operator=(const _Myt &); 

_Mysb *_Mystrbuf; 
_Myos *_Tiestr; 
_Elem _Fillch; 
}; 



template class __declspec( dllimport ) basic_ios< char, char_traits< char> > ;

template class __declspec( dllimport ) basic_ios< __wchar_t, char_traits< __wchar_t> > ;
#line 171
inline ios_base &boolalpha(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)16384); 
return _Iosbase; 
} 

inline ios_base &dec(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)512, (_Iosb< int> ::_Fmtflags)3584); 
return _Iosbase; 
} 

inline ios_base &fixed(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)8192, (_Iosb< int> ::_Fmtflags)12288); 
return _Iosbase; 
} 

inline ios_base &hex(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)2048, (_Iosb< int> ::_Fmtflags)3584); 
return _Iosbase; 
} 

namespace tr1 { 
inline ios_base &hexfloat(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)12288, (_Iosb< int> ::_Fmtflags)12288); 
return _Iosbase; 
} 
}
using tr1::hexfloat;

inline ios_base &internal(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)256, (_Iosb< int> ::_Fmtflags)448); 
return _Iosbase; 
} 

inline ios_base &left(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)64, (_Iosb< int> ::_Fmtflags)448); 
return _Iosbase; 
} 

inline ios_base &noboolalpha(ios_base &_Iosbase) 
{ 
_Iosbase.unsetf((_Iosb< int> ::_Fmtflags)16384); 
return _Iosbase; 
} 

inline ios_base &noshowbase(ios_base &_Iosbase) 
{ 
_Iosbase.unsetf((_Iosb< int> ::_Fmtflags)8); 
return _Iosbase; 
} 

inline ios_base &noshowpoint(ios_base &_Iosbase) 
{ 
_Iosbase.unsetf((_Iosb< int> ::_Fmtflags)16); 
return _Iosbase; 
} 

inline ios_base &noshowpos(ios_base &_Iosbase) 
{ 
_Iosbase.unsetf((_Iosb< int> ::_Fmtflags)32); 
return _Iosbase; 
} 

inline ios_base &noskipws(ios_base &_Iosbase) 
{ 
_Iosbase.unsetf((_Iosb< int> ::_Fmtflags)1); 
return _Iosbase; 
} 

inline ios_base &nounitbuf(ios_base &_Iosbase) 
{ 
_Iosbase.unsetf((_Iosb< int> ::_Fmtflags)2); 
return _Iosbase; 
} 

inline ios_base &nouppercase(ios_base &_Iosbase) 
{ 
_Iosbase.unsetf((_Iosb< int> ::_Fmtflags)4); 
return _Iosbase; 
} 

inline ios_base &oct(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)1024, (_Iosb< int> ::_Fmtflags)3584); 
return _Iosbase; 
} 

inline ios_base &right(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)128, (_Iosb< int> ::_Fmtflags)448); 
return _Iosbase; 
} 

inline ios_base &scientific(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)4096, (_Iosb< int> ::_Fmtflags)12288); 
return _Iosbase; 
} 

inline ios_base &showbase(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)8); 
return _Iosbase; 
} 

inline ios_base &showpoint(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)16); 
return _Iosbase; 
} 

inline ios_base &showpos(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)32); 
return _Iosbase; 
} 

inline ios_base &skipws(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)1); 
return _Iosbase; 
} 

inline ios_base &unitbuf(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)2); 
return _Iosbase; 
} 

inline ios_base &uppercase(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)4); 
return _Iosbase; 
} 
}


#pragma warning(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ostream"
#pragma warning(push,3)
#pragma warning(disable: 4390)
#line 315 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ios"
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ostream"
#pragma pack ( push, 8 )




namespace std { 
#line 38
template<class _Elem, class 
_Traits> 
class basic_ostream : virtual public basic_ios< _Elem, _Traits>  { friend struct __cilk_s;__CILK_METADATA(basic_ostream, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



typedef std::basic_ostream< _Elem, _Traits>  _Myt; 
typedef basic_ios< _Elem, _Traits>  _Myios; 
typedef basic_streambuf< _Elem, _Traits>  _Mysb; 
typedef ostreambuf_iterator< _Elem, _Traits>  _Iter; 
typedef num_put< _Elem, ostreambuf_iterator< _Elem, _Traits> >  _Nput; 

inline explicit basic_ostream(basic_streambuf< _Elem, _Traits>  *, bool = false); inline explicit  /* __cilk */ __thiscall basic_ostream(__cilk_box<basic_streambuf< _Elem, _Traits>  * > , __cilk_box<bool >  = (__cilk_box<bool >(false))); 
#line 56
inline basic_ostream(_Uninitialized, bool = true); inline  /* __cilk */ __thiscall basic_ostream(__cilk_box<_Uninitialized > , __cilk_box<bool >  = (__cilk_box<bool >(true))); 
#line 62
inline virtual ~basic_ostream(); 



typedef typename _Traits::int_type int_type; 
typedef typename _Traits::pos_type pos_type; 
typedef typename _Traits::off_type off_type; 

class _Sentry_base { friend struct __cilk_s;__CILK_METADATA(_Sentry_base, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


inline _Sentry_base(_Myt &); inline  /* __cilk */ __thiscall _Sentry_base(__cilk_box<_Myt & > ); 
#line 80
inline ~_Sentry_base(); 
#line 86
_Myt &_Myostr; 
}; 

class sentry : public _Sentry_base { friend struct __cilk_s;__CILK_METADATA(sentry, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



inline explicit sentry(_Myt &); inline explicit  /* __cilk */ __thiscall sentry(__cilk_box<_Myt & > ); 
#line 101
inline ~sentry(); 
#line 114
inline operator bool() const; 
#line 120
private: sentry(const sentry &); 
sentry &operator=(const sentry &); 

bool _Ok; 
}; 

inline bool opfx(); inline bool  /* __cilk */ __thiscall __cilkfun_opfx(); 
#line 133
inline void osfx(); inline void  /* __cilk */ __thiscall __cilkfun_osfx(); 




inline void _Osfx(); inline void  /* __cilk */ __thiscall __cilkfun__Osfx(); 
#line 170
inline _Myt &operator<<(_Myt &(__cdecl *)(_Myt &)); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_left(__cilk_box<_Myt &(__cdecl *)(_Myt &) > ); 
#line 176
inline _Myt &operator<<(_Myios &(__cdecl *)(_Myios &)); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_left(__cilk_box<_Myios &(__cdecl *)(_Myios &) > ); 
#line 183
inline _Myt &operator<<(ios_base &(__cdecl *)(ios_base &)); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_left(__cilk_box<ios_base &(__cdecl *)(ios_base &) > ); 
#line 190
inline _Myt &operator<<(_Bool); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_left(__cilk_box<bool > ); 
#line 210
inline _Myt &operator<<(short); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_left(__cilk_box<short > ); 
#line 243
inline _Myt &operator<<(unsigned short); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_left(__cilk_box<unsigned short > ); 
#line 263
inline _Myt &operator<<(int __w64); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_left(__cilk_box<int __w64 > ); 
#line 288
inline _Myt &operator<<(unsigned __w64); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_left(__cilk_box<unsigned __w64 > ); 
#line 308
inline _Myt &operator<<(long); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_left(__cilk_box<long > ); 
#line 328
inline _Myt &operator<<(unsigned long __w64); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_left(__cilk_box<unsigned long __w64 > ); 
#line 349
inline _Myt &operator<<(__int64); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_left(__cilk_box<__int64 > ); 
#line 369
inline _Myt &operator<<(unsigned __int64); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_left(__cilk_box<unsigned __int64 > ); 
#line 390
inline _Myt &operator<<(float); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_left(__cilk_box<float > ); 
#line 410
inline _Myt &operator<<(double); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_left(__cilk_box<double > ); 
#line 430
inline _Myt &operator<<(long double); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_left(__cilk_box<long double > ); 
#line 450
inline _Myt &operator<<(const void *); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_left(__cilk_box<const void * > ); 
#line 470
inline _Myt &operator<<(_Mysb *); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_left(__cilk_box<_Mysb * > ); 
#line 507
inline _Myt &put(_Elem); inline _Myt & /* __cilk */ __thiscall __cilkfun_put(__cilk_box<_Elem > ); 
#line 527
inline _Myt &write(const _Elem *, streamsize); inline _Myt & /* __cilk */ __thiscall __cilkfun_write(__cilk_box<const _Elem * > , __cilk_box<int > ); 
#line 549
inline _Myt &flush(); inline _Myt & /* __cilk */ __thiscall __cilkfun_flush(); 
#line 558
inline _Myt &seekp(pos_type); inline _Myt & /* __cilk */ __thiscall __cilkfun_seekp(__cilk_box<typename _Traits::pos_type > ); 
#line 567
inline _Myt &seekp(off_type, ios_base::seekdir); inline _Myt & /* __cilk */ __thiscall __cilkfun_seekp(__cilk_box<typename _Traits::off_type > , __cilk_box<int > ); 
#line 576
inline pos_type tellp(); inline pos_type  /* __cilk */ __thiscall __cilkfun_tellp(); 
#line 584
}; 
#line 642
template class __declspec( dllimport ) basic_ostream< char, char_traits< char> > ;
template class __declspec( dllimport ) basic_ostream< __wchar_t, char_traits< __wchar_t> > ;
#line 651
template<class _Elem, class 
_Traits> inline basic_ostream< _Elem, _Traits>  &
operator<<(basic_ostream< _Elem, _Traits>  &, const char *); 
#line 651
template<class _Elem, class 
_Traits> inline basic_ostream< _Elem, _Traits>  & /* __cilk */ __cdecl 
__cilk_op_shift_left(__cilk_box<basic_ostream< _Elem, _Traits>  & > , __cilk_box<const char * > ); 
#line 698
template<class _Elem, class 
_Traits> inline basic_ostream< _Elem, _Traits>  &
operator<<(basic_ostream< _Elem, _Traits>  &, char); 
#line 698
template<class _Elem, class 
_Traits> inline basic_ostream< _Elem, _Traits>  & /* __cilk */ __cdecl 
__cilk_op_shift_left(__cilk_box<basic_ostream< _Elem, _Traits>  & > , __cilk_box<char > ); 
#line 737
template<class _Traits> inline basic_ostream< char, _Traits>  &
operator<<(basic_ostream< char, _Traits>  &, const char *); 
#line 737
template<class _Traits> inline basic_ostream< char, _Traits>  & /* __cilk */ __cdecl 
__cilk_op_shift_left(__cilk_box<basic_ostream< char, _Traits>  & > , __cilk_box<const char * > ); 
#line 784
template<class _Traits> inline basic_ostream< char, _Traits>  &
operator<<(basic_ostream< char, _Traits>  &, char); 
#line 784
template<class _Traits> inline basic_ostream< char, _Traits>  & /* __cilk */ __cdecl 
__cilk_op_shift_left(__cilk_box<basic_ostream< char, _Traits>  & > , __cilk_box<char > ); 
#line 823
template<class _Elem, class 
_Traits> inline basic_ostream< _Elem, _Traits>  &
operator<<(basic_ostream< _Elem, _Traits>  &, const _Elem *); 
#line 823
template<class _Elem, class 
_Traits> inline basic_ostream< _Elem, _Traits>  & /* __cilk */ __cdecl 
__cilk_op_shift_left(__cilk_box<basic_ostream< _Elem, _Traits>  & > , __cilk_box<const _Elem * > ); 
#line 869
template<class _Elem, class 
_Traits> inline basic_ostream< _Elem, _Traits>  &
operator<<(basic_ostream< _Elem, _Traits>  &, _Elem); 
#line 869
template<class _Elem, class 
_Traits> inline basic_ostream< _Elem, _Traits>  & /* __cilk */ __cdecl 
__cilk_op_shift_left(__cilk_box<basic_ostream< _Elem, _Traits>  & > , __cilk_box<_Elem > ); 
#line 908
template<class _Traits> inline basic_ostream< char, _Traits>  &
operator<<(basic_ostream< char, _Traits>  &, const signed char *); 
#line 908
template<class _Traits> inline basic_ostream< char, _Traits>  & /* __cilk */ __cdecl 
__cilk_op_shift_left(__cilk_box<basic_ostream< char, _Traits>  & > , __cilk_box<const signed char * > ); 
#line 915
template<class _Traits> inline basic_ostream< char, _Traits>  &
operator<<(basic_ostream< char, _Traits>  &, signed char); 
#line 915
template<class _Traits> inline basic_ostream< char, _Traits>  & /* __cilk */ __cdecl 
__cilk_op_shift_left(__cilk_box<basic_ostream< char, _Traits>  & > , __cilk_box<signed char > ); 
#line 922
template<class _Traits> inline basic_ostream< char, _Traits>  &
operator<<(basic_ostream< char, _Traits>  &, const unsigned char *); 
#line 922
template<class _Traits> inline basic_ostream< char, _Traits>  & /* __cilk */ __cdecl 
__cilk_op_shift_left(__cilk_box<basic_ostream< char, _Traits>  & > , __cilk_box<const unsigned char * > ); 
#line 929
template<class _Traits> inline basic_ostream< char, _Traits>  &
operator<<(basic_ostream< char, _Traits>  &, unsigned char); 
#line 929
template<class _Traits> inline basic_ostream< char, _Traits>  & /* __cilk */ __cdecl 
__cilk_op_shift_left(__cilk_box<basic_ostream< char, _Traits>  & > , __cilk_box<unsigned char > ); 
#line 937
template<class _Elem, class 
_Traits> inline basic_ostream< _Elem, _Traits>  &

endl(basic_ostream< _Elem, _Traits>  &); 
#line 937
template<class _Elem, class 
_Traits> inline basic_ostream< _Elem, _Traits>  & /* __cilk */ __cdecl 

__cilkfun_endl(__cilk_box<basic_ostream< _Elem, _Traits>  & > ); 
#line 947
template<class _Elem, class 
_Traits> inline basic_ostream< _Elem, _Traits>  &

ends(basic_ostream< _Elem, _Traits>  &); 
#line 947
template<class _Elem, class 
_Traits> inline basic_ostream< _Elem, _Traits>  & /* __cilk */ __cdecl 

__cilkfun_ends(__cilk_box<basic_ostream< _Elem, _Traits>  & > ); 
#line 956
template<class _Elem, class 
_Traits> inline basic_ostream< _Elem, _Traits>  &

flush(basic_ostream< _Elem, _Traits>  &); 
#line 956
template<class _Elem, class 
_Traits> inline basic_ostream< _Elem, _Traits>  & /* __cilk */ __cdecl 

__cilkfun_flush(__cilk_box<basic_ostream< _Elem, _Traits>  & > ); 
#line 966
inline __declspec( dllimport noinline ) basic_ostream< char, char_traits< char> >  &endl(basic_ostream< char, char_traits< char> >  &_Ostr) 
{ 
_Ostr.put('\n'); 
_Ostr.flush(); 
return _Ostr; 
} 


inline __declspec( dllimport noinline ) basic_ostream< __wchar_t, char_traits< __wchar_t> >  &endl(basic_ostream< __wchar_t, char_traits< __wchar_t> >  &
_Ostr) 
{ 
_Ostr.put('\n'); 
_Ostr.flush(); 
return _Ostr; 
} 



inline __declspec( dllimport noinline ) basic_ostream< char, char_traits< char> >  &ends(basic_ostream< char, char_traits< char> >  &_Ostr) 
{ 
_Ostr.put('\000'); 
return _Ostr; 
} 


inline __declspec( dllimport noinline ) basic_ostream< __wchar_t, char_traits< __wchar_t> >  &ends(basic_ostream< __wchar_t, char_traits< __wchar_t> >  &
_Ostr) 
{ 
_Ostr.put('\000'); 
return _Ostr; 
} 



inline __declspec( dllimport noinline ) basic_ostream< char, char_traits< char> >  &flush(basic_ostream< char, char_traits< char> >  &_Ostr) 
{ 
_Ostr.flush(); 
return _Ostr; 
} 


inline __declspec( dllimport noinline ) basic_ostream< __wchar_t, char_traits< __wchar_t> >  &flush(basic_ostream< __wchar_t, char_traits< __wchar_t> >  &
_Ostr) 
{ 
_Ostr.flush(); 
return _Ostr; 
} 
#line 1019
}


#pragma warning(default: 4390)
#pragma warning(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\istream"
#pragma warning(push,3)
#line 1024 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ostream"
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\istream"
#pragma pack ( push, 8 )



namespace std { 


template<class _Elem, class 
_Traits> 
class basic_istream : virtual public basic_ios< _Elem, _Traits>  { friend struct __cilk_s;__CILK_METADATA(basic_istream, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



typedef std::basic_istream< _Elem, _Traits>  _Myt; 
typedef basic_ios< _Elem, _Traits>  _Myios; 
typedef basic_streambuf< _Elem, _Traits>  _Mysb; 
typedef istreambuf_iterator< _Elem, _Traits>  _Iter; 
typedef ctype< _Elem>  _Ctype; 
typedef num_get< _Elem, istreambuf_iterator< _Elem, _Traits> >  _Nget; 


inline explicit basic_istream(_Mysb *, bool = false); inline explicit  /* __cilk */ __thiscall basic_istream(__cilk_box<_Mysb * > , __cilk_box<bool >  = (__cilk_box<bool >(false))); 
#line 36
inline basic_istream(_Uninitialized); inline  /* __cilk */ __thiscall basic_istream(__cilk_box<_Uninitialized > ); 




inline virtual ~basic_istream(); 



typedef typename _Traits::int_type int_type; 
typedef typename _Traits::pos_type pos_type; 
typedef typename _Traits::off_type off_type; 


class _Sentry_base { friend struct __cilk_s;__CILK_METADATA(_Sentry_base, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


inline _Sentry_base(_Myt &); inline  /* __cilk */ __thiscall _Sentry_base(__cilk_box<_Myt & > ); 
#line 60
inline ~_Sentry_base(); 
#line 66
_Myt &_Myistr; 
}; 

class sentry : public _Sentry_base { friend struct __cilk_s;__CILK_METADATA(sentry, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



inline explicit sentry(_Myt &, bool = false); inline explicit  /* __cilk */ __thiscall sentry(__cilk_box<_Myt & > , __cilk_box<bool >  = (__cilk_box<bool >(false))); 
#line 79
inline operator bool() const; 
#line 85
private: sentry(const sentry &); 
sentry &operator=(const sentry &); 

bool _Ok; 
}; 

inline bool _Ipfx(bool = false); inline bool  /* __cilk */ __thiscall __cilkfun__Ipfx(__cilk_box<bool >  = (__cilk_box<bool >(false))); 
#line 124
inline bool ipfx(bool = false); inline bool  /* __cilk */ __thiscall __cilkfun_ipfx(__cilk_box<bool >  = (__cilk_box<bool >(false))); 




inline void isfx(); inline void  /* __cilk */ __thiscall __cilkfun_isfx(); 
#line 155
inline _Myt &operator>>(_Myt &(__cdecl *)(_Myt &)); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_right(__cilk_box<_Myt &(__cdecl *)(_Myt &) > ); 
#line 161
inline _Myt &operator>>(_Myios &(__cdecl *)(_Myios &)); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_right(__cilk_box<_Myios &(__cdecl *)(_Myios &) > ); 
#line 168
inline _Myt &operator>>(ios_base &(__cdecl *)(ios_base &)); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_right(__cilk_box<ios_base &(__cdecl *)(ios_base &) > ); 
#line 175
inline _Myt &operator>>(_Bool &); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_right(__cilk_box<_Bool & > ); 
#line 194
inline _Myt &operator>>(short &); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_right(__cilk_box<short & > ); 
#line 228
inline _Myt &operator>>(unsigned short &); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_right(__cilk_box<unsigned short & > ); 
#line 247
inline _Myt &operator>>(int &); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_right(__cilk_box<int & > ); 
#line 273
inline _Myt &operator>>(unsigned &); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_right(__cilk_box<unsigned & > ); 
#line 291
inline _Myt &operator>>(long &); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_right(__cilk_box<long & > ); 
#line 309
inline _Myt &operator>>(unsigned long __w64 &); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_right(__cilk_box<unsigned long __w64 & > ); 
#line 329
inline _Myt &operator>>(__int64 &); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_right(__cilk_box<__int64 & > ); 
#line 348
inline _Myt &operator>>(unsigned __int64 &); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_right(__cilk_box<unsigned __int64 & > ); 
#line 367
inline _Myt &operator>>(float &); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_right(__cilk_box<float & > ); 
#line 386
inline _Myt &operator>>(double &); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_right(__cilk_box<double & > ); 
#line 404
inline _Myt &operator>>(long double &); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_right(__cilk_box<long double & > ); 
#line 422
inline _Myt &operator>>(void *&); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_right(__cilk_box<void *& > ); 
#line 441
inline _Myt &operator>>(_Mysb *); inline _Myt & /* __cilk */ __thiscall __cilk_op_shift_right(__cilk_box<_Mysb * > ); 
#line 476
inline int_type get(); inline int_type  /* __cilk */ __thiscall __cilkfun_get(); 
#line 501
inline _Myt &get(_Elem *, streamsize); inline _Myt & /* __cilk */ __thiscall __cilkfun_get(__cilk_box<_Elem * > , __cilk_box<int > ); 




inline _Myt &get(_Elem *, streamsize, _Elem); inline _Myt & /* __cilk */ __thiscall __cilkfun_get(__cilk_box<_Elem * > , __cilk_box<int > , __cilk_box<_Elem > ); 
#line 541
inline _Myt &get(_Elem &); inline _Myt & /* __cilk */ __thiscall __cilkfun_get(__cilk_box<_Elem & > ); 
#line 549
inline _Myt &get(_Mysb &); inline _Myt & /* __cilk */ __thiscall __cilkfun_get(__cilk_box<_Mysb & > ); 




inline _Myt &get(_Mysb &, _Elem); inline _Myt & /* __cilk */ __thiscall __cilkfun_get(__cilk_box<_Mysb & > , __cilk_box<_Elem > ); 
#line 593
inline _Myt &getline(_Elem *, streamsize); inline _Myt & /* __cilk */ __thiscall __cilkfun_getline(__cilk_box<_Elem * > , __cilk_box<int > ); 




inline _Myt &getline(_Elem *, streamsize, _Elem); inline _Myt & /* __cilk */ __thiscall __cilkfun_getline(__cilk_box<_Elem * > , __cilk_box<int > , __cilk_box<_Elem > ); 
#line 643
inline _Myt &ignore(streamsize = (1), int_type = (_Traits::eof())); inline _Myt & /* __cilk */ __thiscall __cilkfun_ignore(__cilk_box<int >  = (__cilk_box<int >(1)), __cilk_box<typename _Traits::int_type >  = (__cilk_box<typename _Traits::int_type >(_Traits::eof()))); 
#line 678
inline _Myt &_Read_s(_Elem *, size_t, streamsize); inline _Myt & /* __cilk */ __thiscall __cilkfun__Read_s(__cilk_box<_Elem * > , __cilk_box<unsigned > , __cilk_box<int > ); 
#line 699
inline _Myt &read(_Elem *, streamsize); inline _Myt & /* __cilk */ __thiscall __cilkfun_read(__cilk_box<_Elem * > , __cilk_box<int > ); 




inline streamsize _Readsome_s(_Elem *, size_t, streamsize); inline streamsize  /* __cilk */ __thiscall __cilkfun__Readsome_s(__cilk_box<_Elem * > , __cilk_box<unsigned > , __cilk_box<int > ); 
#line 724
inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) streamsize readsome(_Elem *, streamsize); inline __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) streamsize  /* __cilk */ __thiscall __cilkfun_readsome(__cilk_box<_Elem * > , __cilk_box<int > ); 




inline int_type peek(); inline int_type  /* __cilk */ __thiscall __cilkfun_peek(); 
#line 751
inline _Myt &putback(_Elem); inline _Myt & /* __cilk */ __thiscall __cilkfun_putback(__cilk_box<_Elem > ); 
#line 770
inline _Myt &unget(); inline _Myt & /* __cilk */ __thiscall __cilkfun_unget(); 
#line 789
inline streamsize gcount() const; inline streamsize  /* __cilk */ __thiscall __cilkfun_gcount() const; 




inline int sync(); inline int  /* __cilk */ __thiscall __cilkfun_sync(); 
#line 813
inline _Myt &seekg(pos_type); inline _Myt & /* __cilk */ __thiscall __cilkfun_seekg(__cilk_box<typename _Traits::pos_type > ); 
#line 824
inline _Myt &seekg(off_type, ios_base::seekdir); inline _Myt & /* __cilk */ __thiscall __cilkfun_seekg(__cilk_box<typename _Traits::off_type > , __cilk_box<int > ); 
#line 835
inline pos_type tellg(); inline pos_type  /* __cilk */ __thiscall __cilkfun_tellg(); 
#line 845
private: streamsize _Chcount; 
}; 
#line 890
template class __declspec( dllimport ) basic_istream< char, char_traits< char> > ;
template class __declspec( dllimport ) basic_istream< __wchar_t, char_traits< __wchar_t> > ;
#line 898
template<class _Elem, class 
_Traits> 
class basic_iostream : public basic_istream< _Elem, _Traits> , public basic_ostream< _Elem, _Traits>  { friend struct __cilk_s;__CILK_METADATA(basic_iostream, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;




typedef _Elem char_type; 
typedef _Traits traits_type; 
typedef typename _Traits::int_type int_type; 
typedef typename _Traits::pos_type pos_type; 
typedef typename _Traits::off_type off_type; 

inline explicit basic_iostream(basic_streambuf< _Elem, _Traits>  *); inline explicit  /* __cilk */ __thiscall basic_iostream(__cilk_box<basic_streambuf< _Elem, _Traits>  * > ); 
#line 917
inline virtual ~basic_iostream(); 


}; 



template class __declspec( dllimport ) basic_iostream< char, char_traits< char> > ;
template class __declspec( dllimport ) basic_iostream< __wchar_t, char_traits< __wchar_t> > ;
#line 932
template<class _Elem, class 
_Traits> inline basic_istream< _Elem, _Traits>  &
operator>>(basic_istream< _Elem, _Traits>  &, _Elem *); 
#line 932
template<class _Elem, class 
_Traits> inline basic_istream< _Elem, _Traits>  & /* __cilk */ __cdecl 
__cilk_op_shift_right(__cilk_box<basic_istream< _Elem, _Traits>  & > , __cilk_box<_Elem * > ); 
#line 973
template<class _Elem, class 
_Traits> inline basic_istream< _Elem, _Traits>  &
operator>>(basic_istream< _Elem, _Traits>  &, _Elem &); 
#line 973
template<class _Elem, class 
_Traits> inline basic_istream< _Elem, _Traits>  & /* __cilk */ __cdecl 
__cilk_op_shift_right(__cilk_box<basic_istream< _Elem, _Traits>  & > , __cilk_box<_Elem & > ); 
#line 999
template<class _Traits> inline basic_istream< char, _Traits>  &
operator>>(basic_istream< char, _Traits>  &, signed char *); 
#line 999
template<class _Traits> inline basic_istream< char, _Traits>  & /* __cilk */ __cdecl 
__cilk_op_shift_right(__cilk_box<basic_istream< char, _Traits>  & > , __cilk_box<signed char * > ); 
#line 1006
template<class _Traits> inline basic_istream< char, _Traits>  &
operator>>(basic_istream< char, _Traits>  &, signed char &); 
#line 1006
template<class _Traits> inline basic_istream< char, _Traits>  & /* __cilk */ __cdecl 
__cilk_op_shift_right(__cilk_box<basic_istream< char, _Traits>  & > , __cilk_box<signed char & > ); 
#line 1013
template<class _Traits> inline basic_istream< char, _Traits>  &
operator>>(basic_istream< char, _Traits>  &, unsigned char *); 
#line 1013
template<class _Traits> inline basic_istream< char, _Traits>  & /* __cilk */ __cdecl 
__cilk_op_shift_right(__cilk_box<basic_istream< char, _Traits>  & > , __cilk_box<unsigned char * > ); 
#line 1020
template<class _Traits> inline basic_istream< char, _Traits>  &
operator>>(basic_istream< char, _Traits>  &, unsigned char &); 
#line 1020
template<class _Traits> inline basic_istream< char, _Traits>  & /* __cilk */ __cdecl 
__cilk_op_shift_right(__cilk_box<basic_istream< char, _Traits>  & > , __cilk_box<unsigned char & > ); 
#line 1030
template<class _Elem, class 
_Traits> inline basic_istream< _Elem, _Traits>  &

ws(basic_istream< _Elem, _Traits>  &); 
#line 1030
template<class _Elem, class 
_Traits> inline basic_istream< _Elem, _Traits>  & /* __cilk */ __cdecl 

__cilkfun_ws(__cilk_box<basic_istream< _Elem, _Traits>  & > ); 
#line 1067
inline __declspec( dllimport noinline ) basic_istream< char, char_traits< char> >  &ws(basic_istream< char, char_traits< char> >  &_Istr) 
{ 
typedef char _Elem; 
typedef char_traits< char>  _Traits; 

if (!_Istr.eof()) 
{ 
auto ios_base::iostate _State = ((_Iosb< int> ::_Iostate)0); 
auto const basic_istream< char, char_traits< char> > ::sentry _Ok(_Istr, true);  __CILK_BEGIN_INSTANTIATE_METADATA basic_istream< char, char_traits< char> > ::sentry __CILK_END_INSTANTIATE_METADATA

if (_Ok) 
{ 
auto const ctype< char>  &_Ctype_fac = use_facet< ctype< char> > (_Istr.getloc()); 


try { 
for (char_traits< char> ::int_type _Meta = (*_Istr.rdbuf()).sgetc(); ; _Meta = (*_Istr.rdbuf()).snextc()) { 

if (_Traits::eq_int_type(_Traits::eof(), _Meta)) 
{ 
_State |= ((_Iosb< int> ::_Iostate)1); 
break; 
} else { 
if (!_Ctype_fac.is(ctype< char> ::space, _Traits::to_char_type(_Meta))) { 

break; }  }  }  
} catch (...) { _Istr.setstate((_Iosb< int> ::_Iostate)4, true); }  
}  

_Istr.setstate(_State); 
}  
return _Istr; 
} 
#line 483 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocale"
template<> inline __declspec( noinline ) const ctype< __wchar_t>  &__cdecl use_facet< ctype< __wchar_t> > (const locale &); 
#line 1102 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\istream"
inline __declspec( dllimport noinline ) basic_istream< __wchar_t, char_traits< __wchar_t> >  &ws(basic_istream< __wchar_t, char_traits< __wchar_t> >  &_Istr) 
{ 
typedef __wchar_t _Elem; 
typedef char_traits< __wchar_t>  _Traits; 

if (!_Istr.eof()) 
{ 
auto ios_base::iostate _State = ((_Iosb< int> ::_Iostate)0); 
auto const basic_istream< __wchar_t, char_traits< __wchar_t> > ::sentry _Ok(_Istr, true);  __CILK_BEGIN_INSTANTIATE_METADATA basic_istream< __wchar_t, char_traits< __wchar_t> > ::sentry __CILK_END_INSTANTIATE_METADATA

if (_Ok) 
{ 
auto const ctype< __wchar_t>  &_Ctype_fac = use_facet< ctype< __wchar_t> > (_Istr.getloc()); 


try { 
for (char_traits< __wchar_t> ::int_type _Meta = (*_Istr.rdbuf()).sgetc(); ; _Meta = (*_Istr.rdbuf()).snextc()) { 

if (_Traits::eq_int_type(_Traits::eof(), _Meta)) 
{ 
_State |= ((_Iosb< int> ::_Iostate)1); 
break; 
} else { 
if (!_Ctype_fac.is(ctype< __wchar_t> ::space, _Traits::to_char_type(_Meta))) { 

break; }  }  }  
} catch (...) { _Istr.setstate((_Iosb< int> ::_Iostate)4, true); }  
}  

_Istr.setstate(_State); 
}  
return _Istr; 
} 
#line 1159
}


#pragma warning(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\iostream"
#pragma warning(push,3)
#line 1163 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\istream"
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\iostream"
#pragma pack ( push, 8 )


namespace std { 



extern __declspec( dllimport ) istream *_Ptr_cin; 
extern __declspec( dllimport ) ostream *_Ptr_cout; 
extern __declspec( dllimport ) ostream *_Ptr_cerr; 
extern __declspec( dllimport ) ostream *_Ptr_clog; 




class __declspec( dllimport ) _Winit { friend struct __cilk_s;

public: __thiscall _Winit(); 
__thiscall ~_Winit(); 

private: static int _Init_cnt; 
}; 




extern __declspec( dllimport ) wistream *_Ptr_wcin; 
extern __declspec( dllimport ) wostream *_Ptr_wcout; 
extern __declspec( dllimport ) wostream *_Ptr_wcerr; 
extern __declspec( dllimport ) wostream *_Ptr_wclog; 
#line 52
extern __declspec( dllimport ) istream cin; 
extern __declspec( dllimport ) ostream cout; 
extern __declspec( dllimport ) ostream cerr; 
extern __declspec( dllimport ) ostream clog; 

extern __declspec( dllimport ) wistream wcin; 
extern __declspec( dllimport ) wostream wcout; 
extern __declspec( dllimport ) wostream wcerr; 
extern __declspec( dllimport ) wostream wclog; 

}

#pragma warning(pop)
#pragma pack ( pop )
#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"
#pragma pack ( push, 8 )
#line 93
extern "C" { typedef long clock_t; }
#line 142
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _get_daylight instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int *__cdecl __daylight(); } 



extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _get_dstbias instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) long *__cdecl __dstbias(); } 



extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _get_timezone instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) long *__cdecl __timezone(); } 



extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _get_tzname instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char **__cdecl __tzname(); } 


extern "C" { extern __declspec( dllimport ) errno_t __cdecl _get_daylight(int *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _get_dstbias(long *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _get_timezone(long *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _get_tzname(size_t *, char *, size_t, int); } 



extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using asctime_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl asctime(const tm *); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl asctime_s(char *, size_t, const tm *); } 

template<size_t _Size> inline errno_t __cdecl asctime_s(char (&)[_Size], const tm *); 

extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _ctime32_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl _ctime32(const __time32_t *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _ctime32_s(char *, size_t, const __time32_t *); } 
template<size_t _Size> inline errno_t __cdecl _ctime32_s(char (&)[_Size], const __time32_t *); 

extern "C" { extern __declspec( dllimport ) clock_t __cdecl clock(); } 
extern "C" { extern __declspec( dllimport ) double __cdecl _difftime32(__time32_t, __time32_t); } 

extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _gmtime32_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) tm *__cdecl _gmtime32(const __time32_t *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _gmtime32_s(tm *, const __time32_t *); } 

extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _localtime32_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) tm *__cdecl _localtime32(const __time32_t *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _localtime32_s(tm *, const __time32_t *); } 

extern "C" { extern __declspec( dllimport ) size_t __cdecl strftime(char *, size_t, const char *, const tm *); } 
extern "C" { extern __declspec( dllimport ) size_t __cdecl _strftime_l(char *, size_t, const char *, const tm *, _locale_t); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl _strdate_s(char *, size_t); } 
template<size_t _Size> inline errno_t __cdecl _strdate_s(char (&)[_Size]); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _strdate_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl _strdate(char *); } 

extern "C" { extern __declspec( dllimport ) errno_t __cdecl _strtime_s(char *, size_t); } 
template<size_t _Size> inline errno_t __cdecl _strtime_s(char (&)[_Size]); 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _strtime_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl _strtime(char *); } 

extern "C" { extern __declspec( dllimport ) __time32_t __cdecl _time32(__time32_t *); } 
extern "C" { extern __declspec( dllimport ) __time32_t __cdecl _mktime32(tm *); } 
extern "C" { extern __declspec( dllimport ) __time32_t __cdecl _mkgmtime32(tm *); } 




extern "C" { extern __declspec( dllimport ) void __cdecl _tzset(); } 


extern "C" { extern __declspec( dllimport ) double __cdecl _difftime64(__time64_t, __time64_t); } 
extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _ctime64_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl _ctime64(const __time64_t *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _ctime64_s(char *, size_t, const __time64_t *); } 
template<size_t _Size> inline errno_t __cdecl _ctime64_s(char (&)[_Size], const __time64_t *); 

extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _gmtime64_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) tm *__cdecl _gmtime64(const __time64_t *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _gmtime64_s(tm *, const __time64_t *); } 

extern "C" { extern __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _localtime64_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) tm *__cdecl _localtime64(const __time64_t *); } 
extern "C" { extern __declspec( dllimport ) errno_t __cdecl _localtime64_s(tm *, const __time64_t *); } 

extern "C" { extern __declspec( dllimport ) __time64_t __cdecl _mktime64(tm *); } 
extern "C" { extern __declspec( dllimport ) __time64_t __cdecl _mkgmtime64(tm *); } 
extern "C" { extern __declspec( dllimport ) __time64_t __cdecl _time64(__time64_t *); } 


extern "C" { extern __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using GetLocalTime instead. See online help for details.")) unsigned __cdecl _getsystime(tm *); } 
extern "C" { extern __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using SetLocalTime instead. See online help for details.")) unsigned __cdecl _setsystime(tm *, unsigned); } 
#line 84 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.inl"
extern "C" { static __declspec( noinline ) __inline double __cdecl difftime(time_t _Time1, time_t _Time2) 
{ 
return _difftime64(_Time1, _Time2); 
} } 
extern "C" { static __declspec( noinline ) __inline __declspec(deprecated("This function or variable may be unsafe. Consider using ctime_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *__cdecl ctime(const time_t *_Time) 
{ 
#pragma warning( push )
#pragma warning( disable : 4996 )
return _ctime64(_Time); 
#pragma warning( pop )
} } 

extern "C" { static __declspec( noinline ) __inline errno_t __cdecl ctime_s(char *_Buffer, size_t _SizeInBytes, const time_t *_Time) 
{ 
return _ctime64_s(_Buffer, _SizeInBytes, _Time); 
} } 

extern "C" { static __declspec( noinline ) __inline __declspec(deprecated("This function or variable may be unsafe. Consider using gmtime_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) tm *__cdecl gmtime(const time_t *_Time) 
{ 
#pragma warning( push )
#pragma warning( disable : 4996 )
return _gmtime64(_Time); 
#pragma warning( pop )
} } 

extern "C" { static __declspec( noinline ) __inline errno_t __cdecl gmtime_s(tm *_Tm, const time_t *_Time) 
{ 
return _gmtime64_s(_Tm, _Time); 
} } 

extern "C" { static __declspec( noinline ) __inline __declspec(deprecated("This function or variable may be unsafe. Consider using localtime_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) tm *__cdecl localtime(const time_t *_Time) 
{ 
#pragma warning( push )
#pragma warning( disable : 4996 )
return _localtime64(_Time); 
#pragma warning( pop )
} } 
extern "C" { static __declspec( noinline ) __inline errno_t __cdecl localtime_s(tm *_Tm, const time_t *_Time) 
{ 
return _localtime64_s(_Tm, _Time); 
} } 
extern "C" { static __declspec( noinline ) __inline time_t __cdecl mktime(tm *_Tm) 
{ 
return _mktime64(_Tm); 
} } 
extern "C" { static __declspec( noinline ) __inline time_t __cdecl _mkgmtime(tm *_Tm) 
{ 
return _mkgmtime64(_Tm); 
} } 
extern "C" { static __declspec( noinline ) __inline time_t __cdecl time(time_t *_Time) 
{ 
return _time64(_Time); 
} } 
#line 279 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"
extern "C" __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _get_daylight instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int daylight; 
extern "C" __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _get_timezone instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) long timezone; 
extern "C" __declspec( dllimport ) __declspec(deprecated("This function or variable may be unsafe. Consider using _get_tzname instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char *tzname[2]; 


extern "C" { extern __declspec( dllimport ) __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _tzset. See online help for details.")) void __cdecl tzset(); } 
#line 294
#pragma pack ( pop )
#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ctime"
namespace std { 
using ::clock_t;
using ::time_t;
using ::asctime;using ::clock;using ::ctime;
using ::difftime;using ::gmtime;using ::localtime;
using ::mktime;using ::strftime;using ::time;
}
#pragma warning ( pop )
#line 77 "C:\\Program Files (x86)\\Intel\\Cilk\\include\\cilk.h"
#pragma comment ( lib, "cilk_1_1-x86" )
#line 90
namespace cilk { 
#line 101
typedef int ( /* default __cilk */ __cdecl *pcilkfn)(__cilk_box<void * > ); 
typedef int ( /* default __cilk */ __cdecl *pcilkfn_int)(__cilk_box<void * > ); 
typedef void ( /* default __cilk */ __cdecl *pcilkfn_void)(__cilk_box<void * > ); 

class rts_context; 
class context_base; 
class context; 


extern int __cdecl current_worker_id(); 
#line 117
extern unsigned __cdecl current_worker_count(); 

template<class T> class monoid_base; 
template<class T> class legacy_monoid_adapter; 
template<class Monoid> class reducer; 
template<class OldMonoid> class hyperobject; 

}
#line 130
namespace cilk { 


class context_base { friend struct __cilk_s;


rts_context *ctx; 


context_base(const context_base &); 
context_base &operator=(const context_base &); 


protected: context_base(bool); 
~context_base(); 
void run_internal(void *, void *); 
#line 154
public: unsigned set_worker_count(unsigned); 



unsigned get_worker_count(); 
}; 


class context : public context_base { friend struct __cilk_s;__CILK_METADATA(context, __CILK_VBASE_DETECT)



context(const context &); 
context &operator=(const context &); 


public: context(bool = false); 
~context(); 




int run(pcilkfn_int, void *); 
void run(pcilkfn_void, void *); 
}; 
#line 184
inline context *create_context(bool force_serial = false) 
{ 
return new context(force_serial); 
} 

inline void destroy_context(context *ctx) 
{ 
delete ctx; 
} 


}




extern "C" { extern void __cdecl __cilkscreen_enable_instrumentation() throw(); } 
extern "C" { extern void __cdecl __cilkscreen_disable_instrumentation() throw(); } 
extern "C" { extern void __cdecl __cilkscreen_enable_checking() throw(); } 
extern "C" { extern void __cdecl __cilkscreen_disable_checking() throw(); } 

extern "C" { extern bool __cilkrts_parallelism(bool) throw(); } 
#pragma warning ( push )
#pragma warning ( disable: 4355 )
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\assert.h"
extern "C" { extern __declspec( dllimport ) void __cdecl _wassert(const __wchar_t *, const __wchar_t *, unsigned); } 
#pragma warning ( pop )
#line 32 "C:\\Program Files (x86)\\Intel\\Cilk\\include\\cilki/hyperobject.h"
namespace cilk { 
#line 109
template<class T> 
class monoid_base { friend struct __cilk_s;__CILK_METADATA(monoid_base, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


typedef T value_type; 
inline void identity(T *) const; inline void  /* __cilk */ __thiscall __cilkfun_identity(__cilk_box<T * > ) const; 
inline void destroy(T *) const; inline void  /* __cilk */ __thiscall __cilkfun_destroy(__cilk_box<T * > ) const; 
inline void *allocate(size_t) const; inline void * /* __cilk */ __thiscall __cilkfun_allocate(__cilk_box<unsigned > ) const; 
inline void deallocate(void *) const; inline void  /* __cilk */ __thiscall __cilkfun_deallocate(__cilk_box<void * > ) const; 
}; 


struct __declspec( dllimport ) hyperobject_base { friend struct __cilk_s;__CILK_METADATA(hyperobject_base, __CILK_VBASE_DETECT)


protected: void *initialObjPtr_; 

inline hyperobject_base(); 


void init(void *); 
#line 136
void forget() const throw(); 
#line 144
void *lookup() const throw(); 

virtual ~hyperobject_base(); 
#line 152
public: virtual void *createRep() const = 0; 


virtual void destroyRep(void *) const = 0; 


virtual void reduceRep(void *, void *) const = 0; 
}; 
#line 126
inline hyperobject_base::hyperobject_base() { } 
#line 161
template<class Monoid> 
class reducer : private hyperobject_base { friend struct __cilk_s;__CILK_METADATA(reducer, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;
typedef hyperobject_base base; 
typedef typename Monoid::value_type value_type; 

private: const Monoid monoid_; 

void *initialThis_; 

virtual void *createRep() const; 
virtual void reduceRep(typename __cilk_maybe_box<reducer, void * >::type , typename __cilk_maybe_box<reducer, void * >::type ) const; 
virtual void destroyRep(typename __cilk_maybe_box<reducer, void * >::type ) const; 


reducer(const cilk::reducer< Monoid>  &); 
cilk::reducer< Monoid>  &operator=(const cilk::reducer< Monoid>  &); 


public: inline reducer(); 
#line 191
template<class A> inline explicit 
reducer(A &); 
#line 191
template<class A> inline explicit  /* __cilk */ __thiscall 
reducer(__cilk_box<A & > ); 
#line 201
template<class A> inline explicit 
reducer(const A &); 
#line 201
template<class A> inline explicit  /* __cilk */ __thiscall 
reducer(__cilk_box<const A & > ); 
#line 211
template<class A, class B> inline 
reducer(const A &, const B &); 
#line 211
template<class A, class B> inline  /* __cilk */ __thiscall 
reducer(__cilk_box<const A & > , __cilk_box<const B & > ); 
#line 221
template<class A, class B, class C> inline 
reducer(const A &, const B &, const C &); 
#line 221
template<class A, class B, class C> inline  /* __cilk */ __thiscall 
reducer(__cilk_box<const A & > , __cilk_box<const B & > , __cilk_box<const C & > ); 
#line 231
template<class A, class B, class C, class D> inline 
reducer(const A &, const B &, const C &, const D &); 
#line 231
template<class A, class B, class C, class D> inline  /* __cilk */ __thiscall 
reducer(__cilk_box<const A & > , __cilk_box<const B & > , __cilk_box<const C & > , __cilk_box<const D & > ); 
#line 241
template<class A, class B, class C, class D, class E> inline 
reducer(const A &, const B &, const C &, const D &, const E &); 
#line 241
template<class A, class B, class C, class D, class E> inline  /* __cilk */ __thiscall 
reducer(__cilk_box<const A & > , __cilk_box<const B & > , __cilk_box<const C & > , __cilk_box<const D & > , __cilk_box<const E & > ); 
#line 256
inline explicit reducer(Monoid &); inline explicit  /* __cilk */ __thiscall reducer(__cilk_box<Monoid & > ); 
#line 265
inline explicit reducer(const Monoid &); inline explicit  /* __cilk */ __thiscall reducer(__cilk_box<const Monoid & > ); 
#line 278
template<class A> inline 
reducer(const Monoid &, A &); 
#line 278
template<class A> inline  /* __cilk */ __thiscall 
reducer(__cilk_box<const Monoid & > , __cilk_box<A & > ); 
#line 288
template<class A> inline 
reducer(const Monoid &, const A &); 
#line 288
template<class A> inline  /* __cilk */ __thiscall 
reducer(__cilk_box<const Monoid & > , __cilk_box<const A & > ); 
#line 298
template<class A, class B> inline 
reducer(const Monoid &, const A &, const B &); 
#line 298
template<class A, class B> inline  /* __cilk */ __thiscall 
reducer(__cilk_box<const Monoid & > , __cilk_box<const A & > , __cilk_box<const B & > ); 
#line 308
template<class A, class B, class C> inline 
reducer(const Monoid &, const A &, const B &, const C &); 
#line 308
template<class A, class B, class C> inline  /* __cilk */ __thiscall 
reducer(__cilk_box<const Monoid & > , __cilk_box<const A & > , __cilk_box<const B & > , __cilk_box<const C & > ); 
#line 318
template<class A, class B, class C, class D> inline 
reducer(const Monoid &, const A &, const B &, const C &, const D &); 
#line 318
template<class A, class B, class C, class D> inline  /* __cilk */ __thiscall 
reducer(__cilk_box<const Monoid & > , __cilk_box<const A & > , __cilk_box<const B & > , __cilk_box<const C & > , __cilk_box<const D & > ); 
#line 329
template<class A, class B, class C, class D, class E> inline 
reducer(const Monoid &, const A &, const B &, const C &, const D &, const E &); 
#line 329
template<class A, class B, class C, class D, class E> inline  /* __cilk */ __thiscall 
reducer(__cilk_box<const Monoid & > , __cilk_box<const A & > , __cilk_box<const B & > , __cilk_box<const C & > , __cilk_box<const D & > , __cilk_box<const E & > ); 
#line 340
virtual ~reducer(); 


inline value_type &view() throw(); inline value_type & /* __cilk */ __thiscall __cilkfun_view() throw(); 




inline const value_type &view() const throw(); inline const value_type & /* __cilk */ __thiscall __cilkfun_view() const throw(); 




inline value_type &operator()() throw(); 
inline const value_type &operator()() const throw(); 

inline const Monoid &monoid() const; inline const Monoid & /* __cilk */ __thiscall __cilkfun_monoid() const; 
}; 
#line 402
template<class T> 
class legacy_monoid_adapter : public monoid_base< T>  { friend struct __cilk_s;__CILK_METADATA(legacy_monoid_adapter, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;


static inline void reduce(T *, T *); static inline void  /* __cilk */ __cdecl __cilkfun_reduce(__cilk_box<T * > , __cilk_box<T * > ); 
}; 

template<class OldMonoid> 
class hyperobject : public reducer< legacy_monoid_adapter< OldMonoid> >  { friend struct __cilk_s;__CILK_METADATA(hyperobject, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

typedef reducer< legacy_monoid_adapter< OldMonoid> >  base; 


inline hyperobject(); 

template<class A> inline explicit 
hyperobject(A &); 
#line 417
template<class A> inline explicit  /* __cilk */ __thiscall 
hyperobject(__cilk_box<A & > ); 


template<class A> inline explicit 
hyperobject(const A &); 
#line 421
template<class A> inline explicit  /* __cilk */ __thiscall 
hyperobject(__cilk_box<const A & > ); 


template<class A, class B> inline 
hyperobject(const A &, const B &); 
#line 425
template<class A, class B> inline  /* __cilk */ __thiscall 
hyperobject(__cilk_box<const A & > , __cilk_box<const B & > ); 


template<class A, class B, class C> inline 
hyperobject(const A &, const B &, const C &); 
#line 429
template<class A, class B, class C> inline  /* __cilk */ __thiscall 
hyperobject(__cilk_box<const A & > , __cilk_box<const B & > , __cilk_box<const C & > ); 


template<class A, class B, class C, class D> inline 
hyperobject(const A &, const B &, const C &, const D &); 
#line 433
template<class A, class B, class C, class D> inline  /* __cilk */ __thiscall 
hyperobject(__cilk_box<const A & > , __cilk_box<const B & > , __cilk_box<const C & > , __cilk_box<const D & > ); 


template<class A, class B, class C, class D, class E> inline 
hyperobject(const A &, const B &, const C &, const D &, const E &); 
#line 437
template<class A, class B, class C, class D, class E> inline  /* __cilk */ __thiscall 
hyperobject(__cilk_box<const A & > , __cilk_box<const B & > , __cilk_box<const C & > , __cilk_box<const D & > , __cilk_box<const E & > ); 

}; 

}
#line 24 "C:\\Program Files (x86)\\Intel\\Cilk\\include\\cilki/cilkrun.h"
namespace cilk { 




template<class T> class __runret { friend struct __cilk_s;__CILK_METADATA(__runret, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

private: bool is_initialized_; 
public: union { 
char value_[sizeof(T)]; 
void *align1; 
double align2; 
}; 


typedef T type; 
enum { ISVOID}; 

inline __runret(); 
inline ~__runret(); 
inline void init(const T &); inline void  /* __cilk */ __thiscall __cilkfun_init(__cilk_box<const T & > ); 
inline const T &value() const; inline const T & /* __cilk */ __thiscall __cilkfun_value() const; 
}; 

template<class T> class __runret< T &>  { friend struct __cilk_s;__CILK_METADATA(__runret, __CILK_VBASE_DETECT)public:  void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;

private: T *ptr_; 


public: typedef T &type; 
enum { ISVOID}; 

inline __runret(); 
inline void init(T &); inline void  /* __cilk */ __thiscall __cilkfun_init(__cilk_box<T & > ); 
inline T &value() const; inline T & /* __cilk */ __thiscall __cilkfun_value() const; 
}; 

template<> struct __runret< void>  { friend struct __cilk_s;__CILK_METADATA(__runret, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;
typedef int type; 
enum { ISVOID = 1}; 

inline void init(int); 
inline int value() const; 
}; 
#line 65
inline void __runret< void> ::init(int __T20447980) { } 
inline int __runret< void> ::value() const { return 0; } 



template<class T> struct __runarg { friend struct __cilk_s;__CILK_METADATA(__runarg, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;



typedef const T &arg_t; 
static inline void *pack(arg_t); static inline void * /* __cilk */ __cdecl __cilkfun_pack(__cilk_box<const T & > ); 
static inline const T &unpack(void *); static inline const T & /* __cilk */ __cdecl __cilkfun_unpack(__cilk_box<void * > ); 
}; 

template<class T> struct __runarg< T &>  { friend struct __cilk_s;__CILK_METADATA(__runarg, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;
typedef T &arg_t; 
static inline void *pack(arg_t); static inline void * /* __cilk */ __cdecl __cilkfun_pack(__cilk_box<T & > ); 
static inline T &unpack(void *); static inline T & /* __cilk */ __cdecl __cilkfun_unpack(__cilk_box<void * > ); 
}; 

template<class T> struct __runarg< T []>  { friend struct __cilk_s;__CILK_METADATA(__runarg, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;
typedef T *arg_t; 
static inline void *pack(arg_t); static inline void * /* __cilk */ __cdecl __cilkfun_pack(__cilk_box<T * > ); 
static inline T *unpack(void *); static inline T * /* __cilk */ __cdecl __cilkfun_unpack(__cilk_box<void * > ); 
}; 

template<class T, unsigned S> struct __runarg< T [S]>  { friend struct __cilk_s;__CILK_METADATA(__runarg, __CILK_VBASE_DETECT) void /* __cilk */ __thiscall __cilk_virtual_dtor() const ;
typedef T *arg_t; 
typedef T array_t[S]; 
static inline void *pack(arg_t); static inline void * /* __cilk */ __cdecl __cilkfun_pack(__cilk_box<T * > ); 
static inline array_t &unpack(void *); static inline array_t & /* __cilk */ __cdecl __cilkfun_unpack(__cilk_box<void * > ); 
}; 
#line 107
template<class R> extern int  /* default __cilk */ __cdecl 

__dispatch_run(__cilk_box<void * > ); 
#line 129
template<class R, class 
A_1> extern int  /* default __cilk */ __cdecl 

__dispatch_run(__cilk_box<void * > ); 
#line 156
template<class R, class 
A_1, class 
A_2> extern int  /* default __cilk */ __cdecl 

__dispatch_run(__cilk_box<void * > ); 
#line 188
template<class R, class 
A_1, class 
A_2, class 
A_3> extern int  /* default __cilk */ __cdecl 

__dispatch_run(__cilk_box<void * > ); 
#line 225
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4> extern int  /* default __cilk */ __cdecl 

__dispatch_run(__cilk_box<void * > ); 
#line 267
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5> extern int  /* default __cilk */ __cdecl 

__dispatch_run(__cilk_box<void * > ); 
#line 314
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6> extern int  /* default __cilk */ __cdecl 

__dispatch_run(__cilk_box<void * > ); 
#line 366
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7> extern int  /* default __cilk */ __cdecl 

__dispatch_run(__cilk_box<void * > ); 
#line 423
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8> extern int  /* default __cilk */ __cdecl 

__dispatch_run(__cilk_box<void * > ); 
#line 485
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8, class 
A_9> extern int  /* default __cilk */ __cdecl 

__dispatch_run(__cilk_box<void * > ); 
#line 552
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8, class 
A_9, class 
A_10> extern int  /* default __cilk */ __cdecl 

__dispatch_run(__cilk_box<void * > ); 
#line 624
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8, class 
A_9, class 
A_10, class 
A_11> extern int  /* default __cilk */ __cdecl 

__dispatch_run(__cilk_box<void * > ); 
#line 701
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8, class 
A_9, class 
A_10, class 
A_11, class 
A_12> extern int  /* default __cilk */ __cdecl 

__dispatch_run(__cilk_box<void * > ); 
#line 783
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8, class 
A_9, class 
A_10, class 
A_11, class 
A_12, class 
A_13> extern int  /* default __cilk */ __cdecl 

__dispatch_run(__cilk_box<void * > ); 
#line 870
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8, class 
A_9, class 
A_10, class 
A_11, class 
A_12, class 
A_13, class 
A_14> extern int  /* default __cilk */ __cdecl 

__dispatch_run(__cilk_box<void * > ); 
#line 962
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8, class 
A_9, class 
A_10, class 
A_11, class 
A_12, class 
A_13, class 
A_14, class 
A_15> extern int  /* default __cilk */ __cdecl 

__dispatch_run(__cilk_box<void * > ); 
#line 1064
template<class R> extern typename __runret< R> ::type 

run(R ( /* __cilk */ __cdecl *)(void)); 
#line 1064
template<class R> extern typename __runret< R> ::type  /* __cilk */ __cdecl 

__cilkfun_run(__cilk_box<R ( /* __cilk */ __cdecl *)(void) > ); 
#line 1086
template<class R, class 
A_1> extern typename __runret< R> ::type 

run(R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > ), typename __runarg< A_1> ::arg_t); 
#line 1086
template<class R, class 
A_1> extern typename __runret< R> ::type  /* __cilk */ __cdecl 

__cilkfun_run(__cilk_box<R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > ) > , __cilk_box<typename __runarg< A_1> ::arg_t > ); 
#line 1113
template<class R, class 
A_1, class 
A_2> extern typename __runret< R> ::type 

run(R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > ), typename __runarg< A_1> ::arg_t, typename __runarg< A_2> ::arg_t); 
#line 1113
template<class R, class 
A_1, class 
A_2> extern typename __runret< R> ::type  /* __cilk */ __cdecl 

__cilkfun_run(__cilk_box<R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > ) > , __cilk_box<typename __runarg< A_1> ::arg_t > , __cilk_box<typename __runarg< A_2> ::arg_t > ); 
#line 1145
template<class R, class 
A_1, class 
A_2, class 
A_3> extern typename __runret< R> ::type 

run(R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > ), typename __runarg< A_1> ::arg_t, typename __runarg< A_2> ::arg_t, typename __runarg< A_3> ::arg_t); 
#line 1145
template<class R, class 
A_1, class 
A_2, class 
A_3> extern typename __runret< R> ::type  /* __cilk */ __cdecl 

__cilkfun_run(__cilk_box<R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > ) > , __cilk_box<typename __runarg< A_1> ::arg_t > , __cilk_box<typename __runarg< A_2> ::arg_t > , __cilk_box<typename __runarg< A_3> ::arg_t > ); 
#line 1182
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4> extern typename __runret< R> ::type 

run(R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > ), typename __runarg< A_1> ::arg_t, typename __runarg< A_2> ::arg_t, typename __runarg< A_3> ::arg_t, typename __runarg< A_4> ::arg_t); 
#line 1182
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4> extern typename __runret< R> ::type  /* __cilk */ __cdecl 

__cilkfun_run(__cilk_box<R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > ) > , __cilk_box<typename __runarg< A_1> ::arg_t > , __cilk_box<typename __runarg< A_2> ::arg_t > , __cilk_box<typename __runarg< A_3> ::arg_t > , __cilk_box<typename __runarg< A_4> ::arg_t > ); 
#line 1224
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5> extern typename __runret< R> ::type 

run(R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > , __cilk_box<A_5 > ), typename __runarg< A_1> ::arg_t, typename __runarg< A_2> ::arg_t, typename __runarg< A_3> ::arg_t, typename __runarg< A_4> ::arg_t, typename __runarg< A_5> ::arg_t); 
#line 1224
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5> extern typename __runret< R> ::type  /* __cilk */ __cdecl 

__cilkfun_run(__cilk_box<R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > , __cilk_box<A_5 > ) > , __cilk_box<typename __runarg< A_1> ::arg_t > , __cilk_box<typename __runarg< A_2> ::arg_t > , __cilk_box<typename __runarg< A_3> ::arg_t > , __cilk_box<typename __runarg< A_4> ::arg_t > , __cilk_box<typename __runarg< A_5> ::arg_t > ); 
#line 1271
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6> extern typename __runret< R> ::type 

run(R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > , __cilk_box<A_5 > , __cilk_box<A_6 > ), typename __runarg< A_1> ::arg_t, typename __runarg< A_2> ::arg_t, typename __runarg< A_3> ::arg_t, typename __runarg< A_4> ::arg_t, typename __runarg< A_5> ::arg_t, typename __runarg< A_6> ::arg_t); 
#line 1271
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6> extern typename __runret< R> ::type  /* __cilk */ __cdecl 

__cilkfun_run(__cilk_box<R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > , __cilk_box<A_5 > , __cilk_box<A_6 > ) > , __cilk_box<typename __runarg< A_1> ::arg_t > , __cilk_box<typename __runarg< A_2> ::arg_t > , __cilk_box<typename __runarg< A_3> ::arg_t > , __cilk_box<typename __runarg< A_4> ::arg_t > , __cilk_box<typename __runarg< A_5> ::arg_t > , __cilk_box<typename __runarg< A_6> ::arg_t > ); 
#line 1323
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7> extern typename __runret< R> ::type 

run(R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > , __cilk_box<A_5 > , __cilk_box<A_6 > , __cilk_box<A_7 > ), typename __runarg< A_1> ::arg_t, typename __runarg< A_2> ::arg_t, typename __runarg< A_3> ::arg_t, typename __runarg< A_4> ::arg_t, typename __runarg< A_5> ::arg_t, typename __runarg< A_6> ::arg_t, typename __runarg< A_7> ::arg_t); 
#line 1323
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7> extern typename __runret< R> ::type  /* __cilk */ __cdecl 

__cilkfun_run(__cilk_box<R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > , __cilk_box<A_5 > , __cilk_box<A_6 > , __cilk_box<A_7 > ) > , __cilk_box<typename __runarg< A_1> ::arg_t > , __cilk_box<typename __runarg< A_2> ::arg_t > , __cilk_box<typename __runarg< A_3> ::arg_t > , __cilk_box<typename __runarg< A_4> ::arg_t > , __cilk_box<typename __runarg< A_5> ::arg_t > , __cilk_box<typename __runarg< A_6> ::arg_t > , __cilk_box<typename __runarg< A_7> ::arg_t > ); 
#line 1380
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8> extern typename __runret< R> ::type 

run(R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > , __cilk_box<A_5 > , __cilk_box<A_6 > , __cilk_box<A_7 > , __cilk_box<A_8 > ), typename __runarg< A_1> ::arg_t, typename __runarg< A_2> ::arg_t, typename __runarg< A_3> ::arg_t, typename __runarg< A_4> ::arg_t, typename __runarg< A_5> ::arg_t, typename __runarg< A_6> ::arg_t, typename __runarg< A_7> ::arg_t, typename __runarg< A_8> ::arg_t); 
#line 1380
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8> extern typename __runret< R> ::type  /* __cilk */ __cdecl 

__cilkfun_run(__cilk_box<R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > , __cilk_box<A_5 > , __cilk_box<A_6 > , __cilk_box<A_7 > , __cilk_box<A_8 > ) > , __cilk_box<typename __runarg< A_1> ::arg_t > , __cilk_box<typename __runarg< A_2> ::arg_t > , __cilk_box<typename __runarg< A_3> ::arg_t > , __cilk_box<typename __runarg< A_4> ::arg_t > , __cilk_box<typename __runarg< A_5> ::arg_t > , __cilk_box<typename __runarg< A_6> ::arg_t > , __cilk_box<typename __runarg< A_7> ::arg_t > , __cilk_box<typename __runarg< A_8> ::arg_t > ); 
#line 1442
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8, class 
A_9> extern typename __runret< R> ::type 

run(R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > , __cilk_box<A_5 > , __cilk_box<A_6 > , __cilk_box<A_7 > , __cilk_box<A_8 > , __cilk_box<A_9 > ), typename __runarg< A_1> ::arg_t, typename __runarg< A_2> ::arg_t, typename __runarg< A_3> ::arg_t, typename __runarg< A_4> ::arg_t, typename __runarg< A_5> ::arg_t, typename __runarg< A_6> ::arg_t, typename __runarg< A_7> ::arg_t, typename __runarg< A_8> ::arg_t, typename __runarg< A_9> ::arg_t); 
#line 1442
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8, class 
A_9> extern typename __runret< R> ::type  /* __cilk */ __cdecl 

__cilkfun_run(__cilk_box<R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > , __cilk_box<A_5 > , __cilk_box<A_6 > , __cilk_box<A_7 > , __cilk_box<A_8 > , __cilk_box<A_9 > ) > , __cilk_box<typename __runarg< A_1> ::arg_t > , __cilk_box<typename __runarg< A_2> ::arg_t > , __cilk_box<typename __runarg< A_3> ::arg_t > , __cilk_box<typename __runarg< A_4> ::arg_t > , __cilk_box<typename __runarg< A_5> ::arg_t > , __cilk_box<typename __runarg< A_6> ::arg_t > , __cilk_box<typename __runarg< A_7> ::arg_t > , __cilk_box<typename __runarg< A_8> ::arg_t > , __cilk_box<typename __runarg< A_9> ::arg_t > ); 
#line 1509
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8, class 
A_9, class 
A_10> extern typename __runret< R> ::type 

run(R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > , __cilk_box<A_5 > , __cilk_box<A_6 > , __cilk_box<A_7 > , __cilk_box<A_8 > , __cilk_box<A_9 > , __cilk_box<A_10 > ), typename __runarg< A_1> ::arg_t, typename __runarg< A_2> ::arg_t, typename __runarg< A_3> ::arg_t, typename __runarg< A_4> ::arg_t, typename __runarg< A_5> ::arg_t, typename __runarg< A_6> ::arg_t, typename __runarg< A_7> ::arg_t, typename __runarg< A_8> ::arg_t, typename __runarg< A_9> ::arg_t, typename __runarg< A_10> ::arg_t); 
#line 1509
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8, class 
A_9, class 
A_10> extern typename __runret< R> ::type  /* __cilk */ __cdecl 

__cilkfun_run(__cilk_box<R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > , __cilk_box<A_5 > , __cilk_box<A_6 > , __cilk_box<A_7 > , __cilk_box<A_8 > , __cilk_box<A_9 > , __cilk_box<A_10 > ) > , __cilk_box<typename __runarg< A_1> ::arg_t > , __cilk_box<typename __runarg< A_2> ::arg_t > , __cilk_box<typename __runarg< A_3> ::arg_t > , __cilk_box<typename __runarg< A_4> ::arg_t > , __cilk_box<typename __runarg< A_5> ::arg_t > , __cilk_box<typename __runarg< A_6> ::arg_t > , __cilk_box<typename __runarg< A_7> ::arg_t > , __cilk_box<typename __runarg< A_8> ::arg_t > , __cilk_box<typename __runarg< A_9> ::arg_t > , __cilk_box<typename __runarg< A_10> ::arg_t > ); 
#line 1581
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8, class 
A_9, class 
A_10, class 
A_11> extern typename __runret< R> ::type 

run(R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > , __cilk_box<A_5 > , __cilk_box<A_6 > , __cilk_box<A_7 > , __cilk_box<A_8 > , __cilk_box<A_9 > , __cilk_box<A_10 > , __cilk_box<A_11 > ), typename __runarg< A_1> ::arg_t, typename __runarg< A_2> ::arg_t, typename __runarg< A_3> ::arg_t, typename __runarg< A_4> ::arg_t, typename __runarg< A_5> ::arg_t, typename __runarg< A_6> ::arg_t, typename __runarg< A_7> ::arg_t, typename __runarg< A_8> ::arg_t, typename __runarg< A_9> ::arg_t, typename __runarg< A_10> ::arg_t, typename __runarg< A_11> ::arg_t); 
#line 1581
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8, class 
A_9, class 
A_10, class 
A_11> extern typename __runret< R> ::type  /* __cilk */ __cdecl 

__cilkfun_run(__cilk_box<R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > , __cilk_box<A_5 > , __cilk_box<A_6 > , __cilk_box<A_7 > , __cilk_box<A_8 > , __cilk_box<A_9 > , __cilk_box<A_10 > , __cilk_box<A_11 > ) > , __cilk_box<typename __runarg< A_1> ::arg_t > , __cilk_box<typename __runarg< A_2> ::arg_t > , __cilk_box<typename __runarg< A_3> ::arg_t > , __cilk_box<typename __runarg< A_4> ::arg_t > , __cilk_box<typename __runarg< A_5> ::arg_t > , __cilk_box<typename __runarg< A_6> ::arg_t > , __cilk_box<typename __runarg< A_7> ::arg_t > , __cilk_box<typename __runarg< A_8> ::arg_t > , __cilk_box<typename __runarg< A_9> ::arg_t > , __cilk_box<typename __runarg< A_10> ::arg_t > , __cilk_box<typename __runarg< A_11> ::arg_t > ); 
#line 1658
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8, class 
A_9, class 
A_10, class 
A_11, class 
A_12> extern typename __runret< R> ::type 

run(R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > , __cilk_box<A_5 > , __cilk_box<A_6 > , __cilk_box<A_7 > , __cilk_box<A_8 > , __cilk_box<A_9 > , __cilk_box<A_10 > , __cilk_box<A_11 > , __cilk_box<A_12 > ), typename __runarg< A_1> ::arg_t, typename __runarg< A_2> ::arg_t, typename __runarg< A_3> ::arg_t, typename __runarg< A_4> ::arg_t, typename __runarg< A_5> ::arg_t, typename __runarg< A_6> ::arg_t, typename __runarg< A_7> ::arg_t, typename __runarg< A_8> ::arg_t, typename __runarg< A_9> ::arg_t, typename __runarg< A_10> ::arg_t, typename __runarg< A_11> ::arg_t, typename __runarg< A_12> ::arg_t); 
#line 1658
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8, class 
A_9, class 
A_10, class 
A_11, class 
A_12> extern typename __runret< R> ::type  /* __cilk */ __cdecl 

__cilkfun_run(__cilk_box<R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > , __cilk_box<A_5 > , __cilk_box<A_6 > , __cilk_box<A_7 > , __cilk_box<A_8 > , __cilk_box<A_9 > , __cilk_box<A_10 > , __cilk_box<A_11 > , __cilk_box<A_12 > ) > , __cilk_box<typename __runarg< A_1> ::arg_t > , __cilk_box<typename __runarg< A_2> ::arg_t > , __cilk_box<typename __runarg< A_3> ::arg_t > , __cilk_box<typename __runarg< A_4> ::arg_t > , __cilk_box<typename __runarg< A_5> ::arg_t > , __cilk_box<typename __runarg< A_6> ::arg_t > , __cilk_box<typename __runarg< A_7> ::arg_t > , __cilk_box<typename __runarg< A_8> ::arg_t > , __cilk_box<typename __runarg< A_9> ::arg_t > , __cilk_box<typename __runarg< A_10> ::arg_t > , __cilk_box<typename __runarg< A_11> ::arg_t > , __cilk_box<typename __runarg< A_12> ::arg_t > ); 
#line 1740
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8, class 
A_9, class 
A_10, class 
A_11, class 
A_12, class 
A_13> extern typename __runret< R> ::type 

run(R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > , __cilk_box<A_5 > , __cilk_box<A_6 > , __cilk_box<A_7 > , __cilk_box<A_8 > , __cilk_box<A_9 > , __cilk_box<A_10 > , __cilk_box<A_11 > , __cilk_box<A_12 > , __cilk_box<A_13 > ), typename __runarg< A_1> ::arg_t, typename __runarg< A_2> ::arg_t, typename __runarg< A_3> ::arg_t, typename __runarg< A_4> ::arg_t, typename __runarg< A_5> ::arg_t, typename __runarg< A_6> ::arg_t, typename __runarg< A_7> ::arg_t, typename __runarg< A_8> ::arg_t, typename __runarg< A_9> ::arg_t, typename __runarg< A_10> ::arg_t, typename __runarg< A_11> ::arg_t, typename __runarg< A_12> ::arg_t, typename __runarg< A_13> ::arg_t); 
#line 1740
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8, class 
A_9, class 
A_10, class 
A_11, class 
A_12, class 
A_13> extern typename __runret< R> ::type  /* __cilk */ __cdecl 

__cilkfun_run(__cilk_box<R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > , __cilk_box<A_5 > , __cilk_box<A_6 > , __cilk_box<A_7 > , __cilk_box<A_8 > , __cilk_box<A_9 > , __cilk_box<A_10 > , __cilk_box<A_11 > , __cilk_box<A_12 > , __cilk_box<A_13 > ) > , __cilk_box<typename __runarg< A_1> ::arg_t > , __cilk_box<typename __runarg< A_2> ::arg_t > , __cilk_box<typename __runarg< A_3> ::arg_t > , __cilk_box<typename __runarg< A_4> ::arg_t > , __cilk_box<typename __runarg< A_5> ::arg_t > , __cilk_box<typename __runarg< A_6> ::arg_t > , __cilk_box<typename __runarg< A_7> ::arg_t > , __cilk_box<typename __runarg< A_8> ::arg_t > , __cilk_box<typename __runarg< A_9> ::arg_t > , __cilk_box<typename __runarg< A_10> ::arg_t > , __cilk_box<typename __runarg< A_11> ::arg_t > , __cilk_box<typename __runarg< A_12> ::arg_t > , __cilk_box<typename __runarg< A_13> ::arg_t > ); 
#line 1827
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8, class 
A_9, class 
A_10, class 
A_11, class 
A_12, class 
A_13, class 
A_14> extern typename __runret< R> ::type 

run(R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > , __cilk_box<A_5 > , __cilk_box<A_6 > , __cilk_box<A_7 > , __cilk_box<A_8 > , __cilk_box<A_9 > , __cilk_box<A_10 > , __cilk_box<A_11 > , __cilk_box<A_12 > , __cilk_box<A_13 > , __cilk_box<A_14 > ), typename __runarg< A_1> ::arg_t, typename __runarg< A_2> ::arg_t, typename __runarg< A_3> ::arg_t, typename __runarg< A_4> ::arg_t, typename __runarg< A_5> ::arg_t, typename __runarg< A_6> ::arg_t, typename __runarg< A_7> ::arg_t, typename __runarg< A_8> ::arg_t, typename __runarg< A_9> ::arg_t, typename __runarg< A_10> ::arg_t, typename __runarg< A_11> ::arg_t, typename __runarg< A_12> ::arg_t, typename __runarg< A_13> ::arg_t, typename __runarg< A_14> ::arg_t); 
#line 1827
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8, class 
A_9, class 
A_10, class 
A_11, class 
A_12, class 
A_13, class 
A_14> extern typename __runret< R> ::type  /* __cilk */ __cdecl 

__cilkfun_run(__cilk_box<R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > , __cilk_box<A_5 > , __cilk_box<A_6 > , __cilk_box<A_7 > , __cilk_box<A_8 > , __cilk_box<A_9 > , __cilk_box<A_10 > , __cilk_box<A_11 > , __cilk_box<A_12 > , __cilk_box<A_13 > , __cilk_box<A_14 > ) > , __cilk_box<typename __runarg< A_1> ::arg_t > , __cilk_box<typename __runarg< A_2> ::arg_t > , __cilk_box<typename __runarg< A_3> ::arg_t > , __cilk_box<typename __runarg< A_4> ::arg_t > , __cilk_box<typename __runarg< A_5> ::arg_t > , __cilk_box<typename __runarg< A_6> ::arg_t > , __cilk_box<typename __runarg< A_7> ::arg_t > , __cilk_box<typename __runarg< A_8> ::arg_t > , __cilk_box<typename __runarg< A_9> ::arg_t > , __cilk_box<typename __runarg< A_10> ::arg_t > , __cilk_box<typename __runarg< A_11> ::arg_t > , __cilk_box<typename __runarg< A_12> ::arg_t > , __cilk_box<typename __runarg< A_13> ::arg_t > , __cilk_box<typename __runarg< A_14> ::arg_t > ); 
#line 1919
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8, class 
A_9, class 
A_10, class 
A_11, class 
A_12, class 
A_13, class 
A_14, class 
A_15> extern typename __runret< R> ::type 

run(R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > , __cilk_box<A_5 > , __cilk_box<A_6 > , __cilk_box<A_7 > , __cilk_box<A_8 > , __cilk_box<A_9 > , __cilk_box<A_10 > , __cilk_box<A_11 > , __cilk_box<A_12 > , __cilk_box<A_13 > , __cilk_box<A_14 > , __cilk_box<A_15 > ), typename __runarg< A_1> ::arg_t, typename __runarg< A_2> ::arg_t, typename __runarg< A_3> ::arg_t, typename __runarg< A_4> ::arg_t, typename __runarg< A_5> ::arg_t, typename __runarg< A_6> ::arg_t, typename __runarg< A_7> ::arg_t, typename __runarg< A_8> ::arg_t, typename __runarg< A_9> ::arg_t, typename __runarg< A_10> ::arg_t, typename __runarg< A_11> ::arg_t, typename __runarg< A_12> ::arg_t, typename __runarg< A_13> ::arg_t, typename __runarg< A_14> ::arg_t, typename __runarg< A_15> ::arg_t); 
#line 1919
template<class R, class 
A_1, class 
A_2, class 
A_3, class 
A_4, class 
A_5, class 
A_6, class 
A_7, class 
A_8, class 
A_9, class 
A_10, class 
A_11, class 
A_12, class 
A_13, class 
A_14, class 
A_15> extern typename __runret< R> ::type  /* __cilk */ __cdecl 

__cilkfun_run(__cilk_box<R ( /* __cilk */ __cdecl *)(__cilk_box<A_1 > , __cilk_box<A_2 > , __cilk_box<A_3 > , __cilk_box<A_4 > , __cilk_box<A_5 > , __cilk_box<A_6 > , __cilk_box<A_7 > , __cilk_box<A_8 > , __cilk_box<A_9 > , __cilk_box<A_10 > , __cilk_box<A_11 > , __cilk_box<A_12 > , __cilk_box<A_13 > , __cilk_box<A_14 > , __cilk_box<A_15 > ) > , __cilk_box<typename __runarg< A_1> ::arg_t > , __cilk_box<typename __runarg< A_2> ::arg_t > , __cilk_box<typename __runarg< A_3> ::arg_t > , __cilk_box<typename __runarg< A_4> ::arg_t > , __cilk_box<typename __runarg< A_5> ::arg_t > , __cilk_box<typename __runarg< A_6> ::arg_t > , __cilk_box<typename __runarg< A_7> ::arg_t > , __cilk_box<typename __runarg< A_8> ::arg_t > , __cilk_box<typename __runarg< A_9> ::arg_t > , __cilk_box<typename __runarg< A_10> ::arg_t > , __cilk_box<typename __runarg< A_11> ::arg_t > , __cilk_box<typename __runarg< A_12> ::arg_t > , __cilk_box<typename __runarg< A_13> ::arg_t > , __cilk_box<typename __runarg< A_14> ::arg_t > , __cilk_box<typename __runarg< A_15> ::arg_t > ); 
#line 2019
}
#line 237 "C:\\Program Files (x86)\\Intel\\Cilk\\include\\cilk.h"
extern void __fastcall __cilkscreen_clean(void *, void *); 
extern void __fastcall __cilkscreen_acquire_lock(void *); 
extern void __fastcall __cilkscreen_release_lock(void *); 
#line 252
extern "C" { extern void __cdecl __cilkometer_enable_lockpick(); } 
extern "C" { extern void __cdecl __cilkometer_disable_lockpick(); } 
extern "C" { extern void __cdecl __cilkometer_label_lock(void *, char *); } 
extern "C" { extern void __cdecl __cilkometer_ignore_lock(void *); } 
extern "C" { extern void __cdecl __cilkometer_solo_lock(void *); } 
#line 1552
extern "C" { struct __cilkrts_workspan_data { friend struct __cilk_s;

unsigned ms; 



unsigned __int64 success; 
unsigned __int64 work; 
unsigned __int64 span; 
unsigned __int64 burdened_span; 
unsigned __int64 spawns; 
unsigned __int64 syncs; 
unsigned __int64 strands; 
unsigned __int64 atomic_instructions; 
unsigned __int64 frame_count; 
}; }



namespace cilk { 
typedef __cilkrts_workspan_data workspan_data; 
}
#line 1579
extern "C" { extern void __cilkview_workspan_connected(int *); } 



extern "C" { extern void __cilkview_get_workspan_data(unsigned __int64 *, int); } 


extern "C" { extern void __cilkview_workspan_suspend(); } 
extern "C" { extern void __cilkview_workspan_resume(); } 
#line 24 "C:\\Program Files (x86)\\Intel\\Cilk\\include\\cilkview.h"
#pragma comment ( lib, "cilkutil-x86" )
#line 32
namespace cilk { 

extern unsigned get_milliseconds(); 
#line 40
extern "C" { extern void __cilkview_dump(const char *, const workspan_data *, bool, int); } 
#line 48
class cilkview { friend struct __cilk_s;__CILK_METADATA(cilkview, __CILK_VBASE_DETECT)

public: inline cilkview(); 




inline ~cilkview(); 




inline void start(); 
#line 72
inline void stop(); 
#line 97
inline void dump(const char *, bool = true); 
#line 107
inline void reset(); 
#line 114
inline const workspan_data *accumulated_workspan_data() const; 
#line 122
inline unsigned __int64 accumulated_milliseconds(); 



private: workspan_data start_; workspan_data total_; 


int connected_; 


bool started_; 
}; 
#line 50
inline cilkview::cilkview() : connected_(0), started_(false) { 
__cilkview_workspan_connected(&(this->connected_)); 
std::memset((void *)(&(this->total_)), 0, sizeof(workspan_data)); 
((this->start_).ms) = (0); 
} 
inline cilkview::~cilkview() { } 




inline void cilkview::start() { 
(this->started_) = true; 
((this->start_).ms) = get_milliseconds(); 
__cilkview_get_workspan_data(&((this->start_).success), 9); 
} 
#line 72
inline void cilkview::stop() { 
auto workspan_data end; 
__cilkview_get_workspan_data(&(end.success), 9); 
(end.ms) = get_milliseconds(); 
if (this->connected_ != 0) { 
((this->total_).work) += end.work - (this->start_).work; 
((this->total_).span) += end.span - (this->start_).span; 
((this->total_).burdened_span) += end.span - (this->start_).span; 
((this->total_).spawns) += end.spawns - (this->start_).spawns; 
((this->total_).syncs) += end.syncs - (this->start_).syncs; 
((this->total_).strands) += end.strands - (this->start_).strands; 
((this->total_).atomic_instructions) += end.atomic_instructions - (this->start_).atomic_instructions; 

((this->total_).frame_count) += end.frame_count - (this->start_).frame_count; 
}  
((this->total_).ms) += end.ms - (this->start_).ms; 
(this->started_) = false; 
} 
#line 97
inline void cilkview::dump(const char *label, bool must_reset) { 
__cilkview_workspan_suspend(); 
__cilkview_dump(label, &(this->total_), (this->connected_ == 0) ? false : true, cilk::current_worker_count()); 

if (must_reset) { this->reset(); }  
__cilkview_workspan_resume(); 
} 



inline void cilkview::reset() { 
std::memset((void *)(&(this->total_)), 0, sizeof(workspan_data)); 
} 




inline const workspan_data *cilkview::accumulated_workspan_data() const { 
return &(this->total_); 
} 
#line 122
inline unsigned __int64 cilkview::accumulated_milliseconds() { return (this->total_).ms; } 
#line 136
}
#line 9 ".\\Main.cilk"
using namespace std;

int count = 0; 

double  /* default __cilk */ __cdecl getValue1(__cilk_box<double > x__cilkarg, __cilk_box<double > y__cilkarg) { double x = x__cilkarg.unbox();double y = y__cilkarg.unbox();
return ((x + y) + (3)) / (((x + y) + x * y) + (4)); 
} 

double  /* default __cilk */ __cdecl getValue2(__cilk_box<double > x__cilkarg, __cilk_box<double > y__cilkarg) { double x = x__cilkarg.unbox();double y = y__cilkarg.unbox();
return ((x + (2) * y) + (5)) / (((x + y) + x * y) + (5)); 
} 
#pragma warning ( push )
#pragma warning ( disable: 4355 )
#line 738 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ostream"
namespace std { template<> inline __declspec( noinline ) basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  &, const char *); } 
#pragma warning ( pop )
#line 21 ".\\Main.cilk"
__declspec( noinline ) void  /* default __cilk */ __cdecl display(__cilk_box<double ** > mat__cilkarg, __cilk_box<int > size__cilkarg) { double **mat = mat__cilkarg.unbox();int size = size__cilkarg.unbox();
for (int i = 0; i < size; ++i) { 
(cout << (("["))); 
for (int j = 0; j < size; ++j) { 
((cout << ((mat[i])[j])) << ((", "))); 
}  
((cout << (("]"))) << ((std::endl))); 
}  
} 

double ** /* default __cilk */ __cdecl createNew(__cilk_box<int > size__cilkarg, __cilk_box<int > type__cilkarg) { int size = size__cilkarg.unbox();int type = type__cilkarg.unbox();
auto double **mat = (new double *[size]); 

for (int i = 0; i < size; ++i) { 
(mat[i]) = (new double [size]); 

for (int j = 0; j < size; ++j) { 
if (type == 1) { 
((mat[i])[j]) = getValue1((__cilk_box<double >(i)), (__cilk_box<double >(j))); } else { 
if (type == 2) { 
((mat[i])[j]) = getValue2((__cilk_box<double >(i)), (__cilk_box<double >(j))); } else { 

((mat[i])[j]) = (0.0); }  }  
}  
}  

return mat; 
} 

double ** /* default __cilk */ __cdecl getTranspose(__cilk_box<double ** > mat__cilkarg, __cilk_box<int > size__cilkarg) { double **mat = mat__cilkarg.unbox();int size = size__cilkarg.unbox();
auto double **mat1 = createNew((__cilk_box<int >(size)), (__cilk_box<int >(3))); 

for (int i = 0; i < size; ++i) { 
for (int j = 0; j < size; ++j) { 
((mat1[i])[j]) = (mat[j])[i]; }  }  

return mat1; 
} 
#line 64
__declspec( noinline ) void  /* default __cilk */ __cdecl doParallelRecursiveMutliplicationRec(__cilk_box<double ** > mat1__cilkarg, __cilk_box<int > rowLeft1__cilkarg, __cilk_box<int > rowRight1__cilkarg, __cilk_box<int > colTop1__cilkarg, __cilk_box<int > colBottom1__cilkarg, __cilk_box<double ** > mat2__cilkarg, __cilk_box<int > rowLeft2__cilkarg, __cilk_box<int > rowRight2__cilkarg, __cilk_box<int > colTop2__cilkarg, __cilk_box<int > colBottom2__cilkarg, __cilk_box<double ** > mat3__cilkarg, __cilk_box<int > rowLeft3__cilkarg, __cilk_box<int > rowRight3__cilkarg, __cilk_box<int > colTop3__cilkarg, __cilk_box<int > colBottom3__cilkarg) 


{ __CILK_FUNCTION_PROLOGUE;__cilk_ignore_lvalue(mat1__cilkarg); double **mat1 = mat1__cilkarg.unbox();__cilk_ignore_lvalue(rowLeft1__cilkarg); int rowLeft1 = rowLeft1__cilkarg.unbox();__cilk_ignore_lvalue(rowRight1__cilkarg); int rowRight1 = rowRight1__cilkarg.unbox();__cilk_ignore_lvalue(colTop1__cilkarg); int colTop1 = colTop1__cilkarg.unbox();__cilk_ignore_lvalue(colBottom1__cilkarg); int colBottom1 = colBottom1__cilkarg.unbox();__cilk_ignore_lvalue(mat2__cilkarg); double **mat2 = mat2__cilkarg.unbox();__cilk_ignore_lvalue(rowLeft2__cilkarg); int rowLeft2 = rowLeft2__cilkarg.unbox();__cilk_ignore_lvalue(rowRight2__cilkarg); int rowRight2 = rowRight2__cilkarg.unbox();__cilk_ignore_lvalue(colTop2__cilkarg); int colTop2 = colTop2__cilkarg.unbox();__cilk_ignore_lvalue(colBottom2__cilkarg); int colBottom2 = colBottom2__cilkarg.unbox();__cilk_ignore_lvalue(mat3__cilkarg); double **mat3 = mat3__cilkarg.unbox();__cilk_ignore_lvalue(rowLeft3__cilkarg); int rowLeft3 = rowLeft3__cilkarg.unbox();__cilk_ignore_lvalue(rowRight3__cilkarg); int rowRight3 = rowRight3__cilkarg.unbox();__cilk_ignore_lvalue(colTop3__cilkarg); int colTop3 = colTop3__cilkarg.unbox();__cilk_ignore_lvalue(colBottom3__cilkarg); int colBottom3 = colBottom3__cilkarg.unbox();
auto int block_size = ((rowRight1 - rowLeft1) + 1); 

if (block_size == 16) { 
for (int i = 0; i < 16; ++i) { 
for (int j = 0; j < 16; ++j) { 
for (int k = 0; k < 16; ++k) { 
((mat3[i + rowLeft3])[j + colTop3]) += (mat1[i + rowLeft1])[k + colTop1] + (mat2[k + rowLeft2])[j + colTop2]; 
}  
}  
}  

((mat3[rowLeft3])[colTop3]) += (mat1[rowLeft1])[colTop1] * (mat2[colTop2])[rowLeft2]; 
return; 
}  

__cilk_spawn_v((void ( /* default __cilk */ __cdecl *)(__cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > ))&::doParallelRecursiveMutliplicationRec)((__cilk_box<double ** >(mat1)), (__cilk_box<int >(rowLeft1)), (__cilk_box<int >(rowLeft1 + ((rowRight1 - rowLeft1) - 1) / 2)), (__cilk_box<int >(colTop1)), (__cilk_box<int >(colTop1 + ((colBottom1 - colTop1) - 1) / 2)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(rowLeft2)), (__cilk_box<int >(rowLeft2 + ((rowRight2 - rowLeft2) - 1) / 2)), (__cilk_box<int >(colTop2)), (__cilk_box<int >(colTop2 + ((colBottom2 - colTop2) - 1) / 2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(rowLeft3)), (__cilk_box<int >(rowLeft3 + ((rowRight3 - rowLeft3) - 1) / 2)), (__cilk_box<int >(colTop3)), (__cilk_box<int >(colTop2 + ((colBottom3 - colTop3) - 1) / 2))); __cilk_end_spawn<0>();
 




__cilk_spawn_v((void ( /* default __cilk */ __cdecl *)(__cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > ))&::doParallelRecursiveMutliplicationRec)((__cilk_box<double ** >(mat1)), (__cilk_box<int >(rowLeft1)), (__cilk_box<int >(rowLeft1 + ((rowRight1 - rowLeft1) - 1) / 2)), (__cilk_box<int >(colTop1)), (__cilk_box<int >(colTop1 + ((colBottom1 - colTop1) - 1) / 2)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(rowLeft2)), (__cilk_box<int >(rowLeft2 + ((rowRight2 - rowLeft2) - 1) / 2)), (__cilk_box<int >(colTop2 + ((colBottom2 - colTop2) + 1) / 2)), (__cilk_box<int >(colBottom2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(rowLeft3)), (__cilk_box<int >(rowLeft3 + ((rowRight3 - rowLeft3) - 1) / 2)), (__cilk_box<int >(colTop3 + ((colBottom3 - colTop3) + 1) / 2)), (__cilk_box<int >(colBottom3))); __cilk_end_spawn<1>();
 
#line 96
__cilk_spawn_v((void ( /* default __cilk */ __cdecl *)(__cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > ))&::doParallelRecursiveMutliplicationRec)((__cilk_box<double ** >(mat1)), (__cilk_box<int >(rowLeft1 + ((rowRight1 - rowLeft1) + 1) / 2)), (__cilk_box<int >(rowRight1)), (__cilk_box<int >(colTop1)), (__cilk_box<int >(colTop1 + ((colBottom1 - colTop1) - 1) / 2)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(rowLeft2)), (__cilk_box<int >(rowLeft2 + ((rowRight2 - rowLeft2) - 1) / 2)), (__cilk_box<int >(colTop2)), (__cilk_box<int >(colTop2 + ((colBottom2 - colTop2) - 1) / 2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(rowLeft3 + ((rowRight3 - rowLeft3) + 1) / 2)), (__cilk_box<int >(rowRight3)), (__cilk_box<int >(colTop3)), (__cilk_box<int >(colTop3 + ((colBottom3 - colTop3) - 1) / 2))); __cilk_end_spawn<2>();
 
#line 103
__cilk_spawn_v((void ( /* default __cilk */ __cdecl *)(__cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > ))&::doParallelRecursiveMutliplicationRec)((__cilk_box<double ** >(mat1)), (__cilk_box<int >(rowLeft1 + ((rowRight1 - rowLeft1) + 1) / 2)), (__cilk_box<int >(rowRight1)), (__cilk_box<int >(colTop1)), (__cilk_box<int >(colTop1 + ((colBottom1 - colTop1) - 1) / 2)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(rowLeft2)), (__cilk_box<int >(rowLeft2 + ((rowRight2 - rowLeft2) - 1) / 2)), (__cilk_box<int >(colTop2 + ((colBottom2 - colTop2) + 1) / 2)), (__cilk_box<int >(colBottom2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(rowLeft3 + ((rowRight3 - rowLeft3) + 1) / 2)), (__cilk_box<int >(rowRight1)), (__cilk_box<int >(colTop3 + ((colBottom3 - colTop3) + 1) / 2)), (__cilk_box<int >(colBottom3))); __cilk_end_spawn<3>();
 
#line 110
__cilk_s::sync(); 

__cilk_spawn_v((void ( /* default __cilk */ __cdecl *)(__cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > ))&::doParallelRecursiveMutliplicationRec)((__cilk_box<double ** >(mat1)), (__cilk_box<int >(rowLeft1)), (__cilk_box<int >(rowLeft1 + ((rowRight1 - rowLeft1) - 1) / 2)), (__cilk_box<int >(colTop1 + ((colBottom1 - colTop1) + 1) / 2)), (__cilk_box<int >(colBottom1)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(rowLeft2 + ((rowRight2 - rowLeft2) + 1) / 2)), (__cilk_box<int >(rowRight2)), (__cilk_box<int >(colTop2)), (__cilk_box<int >(colTop2 + ((colBottom2 - colTop2) - 1) / 2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(rowLeft3)), (__cilk_box<int >(rowLeft3 + ((rowRight3 - rowLeft3) - 1) / 2)), (__cilk_box<int >(colTop3)), (__cilk_box<int >(colTop3 + ((colBottom3 - colTop3) - 1) / 2))); __cilk_end_spawn<4>();
 




__cilk_spawn_v((void ( /* default __cilk */ __cdecl *)(__cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > ))&::doParallelRecursiveMutliplicationRec)((__cilk_box<double ** >(mat1)), (__cilk_box<int >(rowLeft1)), (__cilk_box<int >(rowLeft1 + ((rowRight1 - rowLeft1) - 1) / 2)), (__cilk_box<int >(colTop1 + ((colBottom1 - colTop1) + 1) / 2)), (__cilk_box<int >(colBottom1)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(rowLeft2 + ((rowRight2 - rowLeft2) + 1) / 2)), (__cilk_box<int >(rowRight2)), (__cilk_box<int >(colTop2 + ((colBottom2 - colTop2) + 1) / 2)), (__cilk_box<int >(colBottom2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(rowLeft3)), (__cilk_box<int >(rowLeft3 + ((rowRight3 - rowLeft3) - 1) / 2)), (__cilk_box<int >(colTop3 + ((colBottom3 - colTop3) + 1) / 2)), (__cilk_box<int >(colBottom3))); __cilk_end_spawn<5>();
 
#line 125
__cilk_spawn_v((void ( /* default __cilk */ __cdecl *)(__cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > ))&::doParallelRecursiveMutliplicationRec)((__cilk_box<double ** >(mat1)), (__cilk_box<int >(rowLeft1 + ((rowRight1 - rowLeft1) + 1) / 2)), (__cilk_box<int >(rowRight1)), (__cilk_box<int >(colTop1 + ((colBottom1 - colTop1) + 1) / 2)), (__cilk_box<int >(colBottom1)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(rowLeft2 + ((rowRight2 - rowLeft2) + 1) / 2)), (__cilk_box<int >(rowRight2)), (__cilk_box<int >(colTop2)), (__cilk_box<int >(colTop2 + ((colBottom2 - colTop2) - 1) / 2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(rowLeft3 + ((rowRight3 - rowLeft3) + 1) / 2)), (__cilk_box<int >(rowRight3)), (__cilk_box<int >(colTop3)), (__cilk_box<int >(colTop3 + ((colBottom3 - colTop3) - 1) / 2))); __cilk_end_spawn<6>();
 
#line 132
__cilk_spawn_v((void ( /* default __cilk */ __cdecl *)(__cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > ))&::doParallelRecursiveMutliplicationRec)((__cilk_box<double ** >(mat1)), (__cilk_box<int >(rowLeft1 + ((rowRight1 - rowLeft1) + 1) / 2)), (__cilk_box<int >(rowRight1)), (__cilk_box<int >(colTop1 + ((colBottom1 - colTop1) + 1) / 2)), (__cilk_box<int >(colBottom1)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(rowLeft2 + ((rowRight2 - rowLeft2) + 1) / 2)), (__cilk_box<int >(rowRight2)), (__cilk_box<int >(colTop2 + ((colBottom2 - colTop2) + 1) / 2)), (__cilk_box<int >(colBottom2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(rowLeft3 + ((rowRight3 - rowLeft3) + 1) / 2)), (__cilk_box<int >(rowRight3)), (__cilk_box<int >(colTop3 + ((colBottom3 - colTop3) + 1) / 2)), (__cilk_box<int >(colBottom3))); __cilk_end_spawn<7>();
 
#line 139
} 


__declspec( noinline ) void  /* default __cilk */ __cdecl doParallelRecursiveMultiplication(__cilk_box<int > s__cilkarg) { __CILK_FUNCTION_PROLOGUE;__cilk_ignore_lvalue(s__cilkarg); int s = s__cilkarg.unbox();
auto int size = s; 
auto double **mat1 = createNew((__cilk_box<int >(size)), (__cilk_box<int >(1))); 
auto double **mat2 = getTranspose((__cilk_box<double ** >(createNew((__cilk_box<int >(size)), (__cilk_box<int >(2))))), (__cilk_box<int >(size))); 
auto double **mat3 = createNew((__cilk_box<int >(size)), (__cilk_box<int >(3))); 

auto cilk::cilkview cv; 

cv.start(); 

__cilk_spawn_v((void ( /* default __cilk */ __cdecl *)(__cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > ))&::doParallelRecursiveMutliplicationRec)((__cilk_box<double ** >(mat1)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2))); __cilk_end_spawn<8>();
 



__cilk_spawn_v((void ( /* default __cilk */ __cdecl *)(__cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > ))&::doParallelRecursiveMutliplicationRec)((__cilk_box<double ** >(mat1)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1))); __cilk_end_spawn<9>();
 



__cilk_spawn_v((void ( /* default __cilk */ __cdecl *)(__cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > ))&::doParallelRecursiveMutliplicationRec)((__cilk_box<double ** >(mat1)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2))); __cilk_end_spawn<10>();
 



__cilk_spawn_v((void ( /* default __cilk */ __cdecl *)(__cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > ))&::doParallelRecursiveMutliplicationRec)((__cilk_box<double ** >(mat1)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1))); __cilk_end_spawn<11>();
 
#line 174
__cilk_s::sync(); 

__cilk_spawn_v((void ( /* default __cilk */ __cdecl *)(__cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > ))&::doParallelRecursiveMutliplicationRec)((__cilk_box<double ** >(mat1)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2))); __cilk_end_spawn<12>();
 



__cilk_spawn_v((void ( /* default __cilk */ __cdecl *)(__cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > ))&::doParallelRecursiveMutliplicationRec)((__cilk_box<double ** >(mat1)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1))); __cilk_end_spawn<13>();
 



__cilk_spawn_v((void ( /* default __cilk */ __cdecl *)(__cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > ))&::doParallelRecursiveMutliplicationRec)((__cilk_box<double ** >(mat1)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2))); __cilk_end_spawn<14>();
 



__cilk_spawn_v((void ( /* default __cilk */ __cdecl *)(__cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<double ** > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > , __cilk_box<int > ))&::doParallelRecursiveMutliplicationRec)((__cilk_box<double ** >(mat1)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1))); __cilk_end_spawn<15>();
 




cv.stop(); 
cv.dump("parallel_block"); 
} 



void  /* default __cilk */ __cdecl doSimpleMultiplication(__cilk_box<int > size__cilkarg) { int size = size__cilkarg.unbox();

auto double **mat1 = createNew((__cilk_box<int >(size)), (__cilk_box<int >(1))); 
auto double **mat2 = getTranspose((__cilk_box<double ** >(createNew((__cilk_box<int >(size)), (__cilk_box<int >(2))))), (__cilk_box<int >(size))); 
auto double **mat3 = createNew((__cilk_box<int >(size)), (__cilk_box<int >(3))); 

for (int i = 0; i < size; ++i) { 
for (int j = 0; j < size; ++j) { 
for (int k = 0; k < size; ++k) { 
((mat3[i])[j]) += (mat1[i])[k] * (mat2[j])[k]; 
}  
}  
}  
} 


__declspec( noinline ) void  /* default __cilk */ __cdecl doOuterLoopParaellMultiplication(__cilk_box<int > size__cilkarg) { __CILK_FUNCTION_PROLOGUE;__cilk_ignore_lvalue(size__cilkarg); int size = size__cilkarg.unbox();
auto double **mat1 = createNew((__cilk_box<int >(size)), (__cilk_box<int >(1))); 
auto double **mat2 = getTranspose((__cilk_box<double ** >(createNew((__cilk_box<int >(size)), (__cilk_box<int >(2))))), (__cilk_box<int >(size))); 
auto double **mat3 = createNew((__cilk_box<int >(size)), (__cilk_box<int >(3))); 
auto cilk::cilkview cv; 

cv.start(); 
{
#line 226
int i = 0; 
class __cilk_k16: __cilk_s::for_loop_closure {
__CILK_METADATA(__cilk_k16, __CILK_NO_VBASE)
double **&mat2;
double **&mat1;
double **&mat3;
int &size;
const int &__T21504240;
public:
__cilk_k16(double **&mat2
        , double **&mat1
        , double **&mat3
        , int &size
        , const int &__T21504240
)
#line 226
  : mat2(mat2),mat1(mat1),mat3(mat3),size(size),__T21504240(__T21504240){}
typedef unsigned long __cilk_for_counter;
void operator()(__cilk_box<unsigned long > __T21504564__cilkarg,__cilk_box<__cilk_for_counter> __cilk_for_end__cilkarg)
#line 226
{ __CILK_FUNCTION_PROLOGUE;__cilk_ignore_lvalue(__T21504564__cilkarg); unsigned long __T21504564 = __T21504564__cilkarg.unbox();__cilk_ignore_lvalue(__cilk_for_end__cilkarg); __cilk_for_counter __cilk_for_end = __cilk_for_end__cilkarg.unbox(); double **&mat2= this->mat2;double **&mat1= this->mat1;double **&mat3= this->mat3;int &size= this->size;const int &__T21504240= this->__T21504240;
#line 226
for ( ; __T21504564 != __cilk_for_end; ++__T21504564) {int i((__T21504240 + __T21504564));
#line 226
{ 
for (int k = 0; k < size; ++k) { 
for (int j = 0; j < size; ++j) { 
((mat3[i])[j]) += (mat1[i])[k] * (mat2[j])[k]; 
}  
}  
} 
} // end for
} // end operator()()
}; // end closure struct
#line 226
const int &__T21504332 = (size);
#line 226
if (i < __T21504332) {
#line 226
__cilk_k16 __cilk_v16(mat2,mat1,mat3,size,i);
#line 226
__cilk_s::for_loop(__cilk_box<__cilk_s::for_loop_closure *>(&__cilk_v16),__cilk_box<unsigned long >(__T21504332 - i),__cilk_box<unsigned long >(0));
} // end if
}
 



cv.stop(); 
cv.dump("parallel_outer"); 
} 


__declspec( noinline ) void  /* default __cilk */ __cdecl doInnerLoopParaellMultiplication(__cilk_box<int > size__cilkarg) { __CILK_FUNCTION_PROLOGUE;__cilk_ignore_lvalue(size__cilkarg); int size = size__cilkarg.unbox();
auto double **mat1 = createNew((__cilk_box<int >(size)), (__cilk_box<int >(1))); 
auto double **mat2 = getTranspose((__cilk_box<double ** >(createNew((__cilk_box<int >(size)), (__cilk_box<int >(2))))), (__cilk_box<int >(size))); 
auto double **mat3 = createNew((__cilk_box<int >(size)), (__cilk_box<int >(3))); 

auto cilk::cilkview cv; 

cv.start(); 
for (int i = 0; i < size; ++i) { 
for (int k = 0; k < size; ++k) { 
{
#line 248
int j = 0; 
class __cilk_k17: __cilk_s::for_loop_closure {
__CILK_METADATA(__cilk_k17, __CILK_NO_VBASE)
double **&mat2;
int &k;
double **&mat1;
int &i;
double **&mat3;
int &size;
const int &__T21512848;
public:
__cilk_k17(double **&mat2
        , int &k
        , double **&mat1
        , int &i
        , double **&mat3
        , int &size
        , const int &__T21512848
)
#line 248
  : mat2(mat2),k(k),mat1(mat1),i(i),mat3(mat3),size(size),__T21512848(__T21512848){}
typedef unsigned long __cilk_for_counter;
void operator()(__cilk_box<unsigned long > __T21513172__cilkarg,__cilk_box<__cilk_for_counter> __cilk_for_end__cilkarg)
#line 248
{ __CILK_FUNCTION_PROLOGUE;__cilk_ignore_lvalue(__T21513172__cilkarg); unsigned long __T21513172 = __T21513172__cilkarg.unbox();__cilk_ignore_lvalue(__cilk_for_end__cilkarg); __cilk_for_counter __cilk_for_end = __cilk_for_end__cilkarg.unbox(); double **&mat2= this->mat2;int &k= this->k;double **&mat1= this->mat1;int &i= this->i;double **&mat3= this->mat3;int &size= this->size;const int &__T21512848= this->__T21512848;
#line 248
for ( ; __T21513172 != __cilk_for_end; ++__T21513172) {int j((__T21512848 + __T21513172));
#line 248
{ 
((mat3[i])[j]) += (mat1[i])[k] * (mat2[j])[k]; 
} 
} // end for
} // end operator()()
}; // end closure struct
#line 248
const int &__T21512940 = (size);
#line 248
if (j < __T21512940) {
#line 248
__cilk_k17 __cilk_v17(mat2,k,mat1,i,mat3,size,j);
#line 248
__cilk_s::for_loop(__cilk_box<__cilk_s::for_loop_closure *>(&__cilk_v17),__cilk_box<unsigned long >(__T21512940 - j),__cilk_box<unsigned long >(0));
} // end if
}
 }  
}  
cv.stop(); 
cv.dump("parallel_inner"); 
} 



__declspec( noinline ) void  /* default __cilk */ __cdecl doBothLoopParaellMultiplication(__cilk_box<int > size__cilkarg) { __CILK_FUNCTION_PROLOGUE;__cilk_ignore_lvalue(size__cilkarg); int size = size__cilkarg.unbox();
auto double **mat1 = createNew((__cilk_box<int >(size)), (__cilk_box<int >(1))); 
auto double **mat2 = getTranspose((__cilk_box<double ** >(createNew((__cilk_box<int >(size)), (__cilk_box<int >(2))))), (__cilk_box<int >(size))); 
auto double **mat3 = createNew((__cilk_box<int >(size)), (__cilk_box<int >(3))); 

auto cilk::cilkview cv; 

cv.start(); 
{
#line 267
int i = 0; 
class __cilk_k18: __cilk_s::for_loop_closure {
__CILK_METADATA(__cilk_k18, __CILK_NO_VBASE)
double **&mat2;
double **&mat1;
double **&mat3;
int &size;
const int &__T21517624;
public:
__cilk_k18(double **&mat2
        , double **&mat1
        , double **&mat3
        , int &size
        , const int &__T21517624
)
#line 267
  : mat2(mat2),mat1(mat1),mat3(mat3),size(size),__T21517624(__T21517624){}
typedef unsigned long __cilk_for_counter;
void operator()(__cilk_box<unsigned long > __T21517948__cilkarg,__cilk_box<__cilk_for_counter> __cilk_for_end__cilkarg)
#line 267
{ __CILK_FUNCTION_PROLOGUE;__cilk_ignore_lvalue(__T21517948__cilkarg); unsigned long __T21517948 = __T21517948__cilkarg.unbox();__cilk_ignore_lvalue(__cilk_for_end__cilkarg); __cilk_for_counter __cilk_for_end = __cilk_for_end__cilkarg.unbox(); double **&mat2= this->mat2;double **&mat1= this->mat1;double **&mat3= this->mat3;int &size= this->size;const int &__T21517624= this->__T21517624;
#line 267
for ( ; __T21517948 != __cilk_for_end; ++__T21517948) {int i((__T21517624 + __T21517948));
#line 267
{ 
for (int k = 0; k < size; ++k) { 
{
#line 269
int j = 0; 
class __cilk_k19: __cilk_s::for_loop_closure {
__CILK_METADATA(__cilk_k19, __CILK_NO_VBASE)
double **&mat2;
int &k;
double **&mat1;
int &i;
double **&mat3;
int &size;
const int &__T21520148;
public:
__cilk_k19(double **&mat2
        , int &k
        , double **&mat1
        , int &i
        , double **&mat3
        , int &size
        , const int &__T21520148
)
#line 269
  : mat2(mat2),k(k),mat1(mat1),i(i),mat3(mat3),size(size),__T21520148(__T21520148){}
typedef unsigned long __cilk_for_counter;
void operator()(__cilk_box<unsigned long > __T21520472__cilkarg,__cilk_box<__cilk_for_counter> __cilk_for_end__cilkarg)
#line 269
{ __CILK_FUNCTION_PROLOGUE;__cilk_ignore_lvalue(__T21520472__cilkarg); unsigned long __T21520472 = __T21520472__cilkarg.unbox();__cilk_ignore_lvalue(__cilk_for_end__cilkarg); __cilk_for_counter __cilk_for_end = __cilk_for_end__cilkarg.unbox(); double **&mat2= this->mat2;int &k= this->k;double **&mat1= this->mat1;int &i= this->i;double **&mat3= this->mat3;int &size= this->size;const int &__T21520148= this->__T21520148;
#line 269
for ( ; __T21520472 != __cilk_for_end; ++__T21520472) {int j((__T21520148 + __T21520472));
#line 269
{ 
((mat3[i])[j]) += (mat1[i])[k] * (mat2[j])[k]; 
} 
} // end for
} // end operator()()
}; // end closure struct
#line 269
const int &__T21520240 = (size);
#line 269
if (j < __T21520240) {
#line 269
__cilk_k19 __cilk_v19(mat2,k,mat1,i,mat3,size,j);
#line 269
__cilk_s::for_loop(__cilk_box<__cilk_s::for_loop_closure *>(&__cilk_v19),__cilk_box<unsigned long >(__T21520240 - j),__cilk_box<unsigned long >(0));
} // end if
}
 }  
} 
} // end for
} // end operator()()
}; // end closure struct
#line 267
const int &__T21517716 = (size);
#line 267
if (i < __T21517716) {
#line 267
__cilk_k18 __cilk_v18(mat2,mat1,mat3,size,i);
#line 267
__cilk_s::for_loop(__cilk_box<__cilk_s::for_loop_closure *>(&__cilk_v18),__cilk_box<unsigned long >(__T21517716 - i),__cilk_box<unsigned long >(0));
} // end if
}
 



cv.stop(); 
cv.dump("parallel_inner_outer.csw"); 
} 



void  /* default __cilk */ __cdecl doRecursiveMutliplicationRec(__cilk_box<double ** > mat1__cilkarg, __cilk_box<int > rowLeft1__cilkarg, __cilk_box<int > rowRight1__cilkarg, __cilk_box<int > colTop1__cilkarg, __cilk_box<int > colBottom1__cilkarg, __cilk_box<double ** > mat2__cilkarg, __cilk_box<int > rowLeft2__cilkarg, __cilk_box<int > rowRight2__cilkarg, __cilk_box<int > colTop2__cilkarg, __cilk_box<int > colBottom2__cilkarg, __cilk_box<double ** > mat3__cilkarg, __cilk_box<int > rowLeft3__cilkarg, __cilk_box<int > rowRight3__cilkarg, __cilk_box<int > colTop3__cilkarg, __cilk_box<int > colBottom3__cilkarg) 


{ double **mat1 = mat1__cilkarg.unbox();int rowLeft1 = rowLeft1__cilkarg.unbox();int rowRight1 = rowRight1__cilkarg.unbox();int colTop1 = colTop1__cilkarg.unbox();int colBottom1 = colBottom1__cilkarg.unbox();double **mat2 = mat2__cilkarg.unbox();int rowLeft2 = rowLeft2__cilkarg.unbox();int rowRight2 = rowRight2__cilkarg.unbox();int colTop2 = colTop2__cilkarg.unbox();int colBottom2 = colBottom2__cilkarg.unbox();double **mat3 = mat3__cilkarg.unbox();int rowLeft3 = rowLeft3__cilkarg.unbox();int rowRight3 = rowRight3__cilkarg.unbox();int colTop3 = colTop3__cilkarg.unbox();int colBottom3 = colBottom3__cilkarg.unbox();
auto int block_size = ((rowRight1 - rowLeft1) + 1); 

if (block_size == 16) { 
for (int i = 0; i < 16; ++i) { 
for (int j = 0; j < 16; ++j) { 
for (int k = 0; k < 16; ++k) { 
((mat3[i + rowLeft3])[j + colTop3]) += (mat1[i + rowLeft1])[k + colTop1] + (mat2[k + rowLeft2])[j + colTop2]; 
}  
}  
}  

((mat3[rowLeft3])[colTop3]) += (mat1[rowLeft1])[colTop1] * (mat2[colTop2])[rowLeft2]; 
return; 
}  

doRecursiveMutliplicationRec((__cilk_box<double ** >(mat1)), (__cilk_box<int >(rowLeft1)), (__cilk_box<int >(rowLeft1 + ((rowRight1 - rowLeft1) - 1) / 2)), (__cilk_box<int >(colTop1)), (__cilk_box<int >(colTop1 + ((colBottom1 - colTop1) - 1) / 2)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(rowLeft2)), (__cilk_box<int >(rowLeft2 + ((rowRight2 - rowLeft2) - 1) / 2)), (__cilk_box<int >(colTop2)), (__cilk_box<int >(colTop2 + ((colBottom2 - colTop2) - 1) / 2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(rowLeft3)), (__cilk_box<int >(rowLeft3 + ((rowRight3 - rowLeft3) - 1) / 2)), (__cilk_box<int >(colTop3)), (__cilk_box<int >(colTop2 + ((colBottom3 - colTop3) - 1) / 2))); 
#line 305
doRecursiveMutliplicationRec((__cilk_box<double ** >(mat1)), (__cilk_box<int >(rowLeft1)), (__cilk_box<int >(rowLeft1 + ((rowRight1 - rowLeft1) - 1) / 2)), (__cilk_box<int >(colTop1)), (__cilk_box<int >(colTop1 + ((colBottom1 - colTop1) - 1) / 2)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(rowLeft2)), (__cilk_box<int >(rowLeft2 + ((rowRight2 - rowLeft2) - 1) / 2)), (__cilk_box<int >(colTop2 + ((colBottom2 - colTop2) + 1) / 2)), (__cilk_box<int >(colBottom2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(rowLeft3)), (__cilk_box<int >(rowLeft3 + ((rowRight3 - rowLeft3) - 1) / 2)), (__cilk_box<int >(colTop3 + ((colBottom3 - colTop3) + 1) / 2)), (__cilk_box<int >(colBottom3))); 
#line 312
doRecursiveMutliplicationRec((__cilk_box<double ** >(mat1)), (__cilk_box<int >(rowLeft1 + ((rowRight1 - rowLeft1) + 1) / 2)), (__cilk_box<int >(rowRight1)), (__cilk_box<int >(colTop1)), (__cilk_box<int >(colTop1 + ((colBottom1 - colTop1) - 1) / 2)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(rowLeft2)), (__cilk_box<int >(rowLeft2 + ((rowRight2 - rowLeft2) - 1) / 2)), (__cilk_box<int >(colTop2)), (__cilk_box<int >(colTop2 + ((colBottom2 - colTop2) - 1) / 2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(rowLeft3 + ((rowRight3 - rowLeft3) + 1) / 2)), (__cilk_box<int >(rowRight3)), (__cilk_box<int >(colTop3)), (__cilk_box<int >(colTop3 + ((colBottom3 - colTop3) - 1) / 2))); 
#line 319
doRecursiveMutliplicationRec((__cilk_box<double ** >(mat1)), (__cilk_box<int >(rowLeft1 + ((rowRight1 - rowLeft1) + 1) / 2)), (__cilk_box<int >(rowRight1)), (__cilk_box<int >(colTop1)), (__cilk_box<int >(colTop1 + ((colBottom1 - colTop1) - 1) / 2)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(rowLeft2)), (__cilk_box<int >(rowLeft2 + ((rowRight2 - rowLeft2) - 1) / 2)), (__cilk_box<int >(colTop2 + ((colBottom2 - colTop2) + 1) / 2)), (__cilk_box<int >(colBottom2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(rowLeft3 + ((rowRight3 - rowLeft3) + 1) / 2)), (__cilk_box<int >(rowRight1)), (__cilk_box<int >(colTop3 + ((colBottom3 - colTop3) + 1) / 2)), (__cilk_box<int >(colBottom3))); 
#line 326
doRecursiveMutliplicationRec((__cilk_box<double ** >(mat1)), (__cilk_box<int >(rowLeft1)), (__cilk_box<int >(rowLeft1 + ((rowRight1 - rowLeft1) - 1) / 2)), (__cilk_box<int >(colTop1 + ((colBottom1 - colTop1) + 1) / 2)), (__cilk_box<int >(colBottom1)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(rowLeft2 + ((rowRight2 - rowLeft2) + 1) / 2)), (__cilk_box<int >(rowRight2)), (__cilk_box<int >(colTop2)), (__cilk_box<int >(colTop2 + ((colBottom2 - colTop2) - 1) / 2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(rowLeft3)), (__cilk_box<int >(rowLeft3 + ((rowRight3 - rowLeft3) - 1) / 2)), (__cilk_box<int >(colTop3)), (__cilk_box<int >(colTop3 + ((colBottom3 - colTop3) - 1) / 2))); 
#line 332
doRecursiveMutliplicationRec((__cilk_box<double ** >(mat1)), (__cilk_box<int >(rowLeft1)), (__cilk_box<int >(rowLeft1 + ((rowRight1 - rowLeft1) - 1) / 2)), (__cilk_box<int >(colTop1 + ((colBottom1 - colTop1) + 1) / 2)), (__cilk_box<int >(colBottom1)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(rowLeft2 + ((rowRight2 - rowLeft2) + 1) / 2)), (__cilk_box<int >(rowRight2)), (__cilk_box<int >(colTop2 + ((colBottom2 - colTop2) + 1) / 2)), (__cilk_box<int >(colBottom2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(rowLeft3)), (__cilk_box<int >(rowLeft3 + ((rowRight3 - rowLeft3) - 1) / 2)), (__cilk_box<int >(colTop3 + ((colBottom3 - colTop3) + 1) / 2)), (__cilk_box<int >(colBottom3))); 
#line 339
doRecursiveMutliplicationRec((__cilk_box<double ** >(mat1)), (__cilk_box<int >(rowLeft1 + ((rowRight1 - rowLeft1) + 1) / 2)), (__cilk_box<int >(rowRight1)), (__cilk_box<int >(colTop1 + ((colBottom1 - colTop1) + 1) / 2)), (__cilk_box<int >(colBottom1)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(rowLeft2 + ((rowRight2 - rowLeft2) + 1) / 2)), (__cilk_box<int >(rowRight2)), (__cilk_box<int >(colTop2)), (__cilk_box<int >(colTop2 + ((colBottom2 - colTop2) - 1) / 2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(rowLeft3 + ((rowRight3 - rowLeft3) + 1) / 2)), (__cilk_box<int >(rowRight3)), (__cilk_box<int >(colTop3)), (__cilk_box<int >(colTop3 + ((colBottom3 - colTop3) - 1) / 2))); 
#line 346
doRecursiveMutliplicationRec((__cilk_box<double ** >(mat1)), (__cilk_box<int >(rowLeft1 + ((rowRight1 - rowLeft1) + 1) / 2)), (__cilk_box<int >(rowRight1)), (__cilk_box<int >(colTop1 + ((colBottom1 - colTop1) + 1) / 2)), (__cilk_box<int >(colBottom1)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(rowLeft2 + ((rowRight2 - rowLeft2) + 1) / 2)), (__cilk_box<int >(rowRight2)), (__cilk_box<int >(colTop2 + ((colBottom2 - colTop2) + 1) / 2)), (__cilk_box<int >(colBottom2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(rowLeft3 + ((rowRight3 - rowLeft3) + 1) / 2)), (__cilk_box<int >(rowRight3)), (__cilk_box<int >(colTop3 + ((colBottom3 - colTop3) + 1) / 2)), (__cilk_box<int >(colBottom3))); 
#line 353
} 


void  /* default __cilk */ __cdecl doRecursiveMultiplication(__cilk_box<int > size__cilkarg) { int size = size__cilkarg.unbox();
auto double **mat1 = createNew((__cilk_box<int >(size)), (__cilk_box<int >(1))); 
auto double **mat2 = createNew((__cilk_box<int >(size)), (__cilk_box<int >(2))); 
auto double **mat3 = createNew((__cilk_box<int >(size)), (__cilk_box<int >(3))); 


doRecursiveMutliplicationRec((__cilk_box<double ** >(mat1)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2))); 




doRecursiveMutliplicationRec((__cilk_box<double ** >(mat1)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1))); 




doRecursiveMutliplicationRec((__cilk_box<double ** >(mat1)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2))); 




doRecursiveMutliplicationRec((__cilk_box<double ** >(mat1)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1))); 
#line 385
doRecursiveMutliplicationRec((__cilk_box<double ** >(mat1)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2))); 




doRecursiveMutliplicationRec((__cilk_box<double ** >(mat1)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1))); 



doRecursiveMutliplicationRec((__cilk_box<double ** >(mat1)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >(0)), (__cilk_box<int >((size - 1) / 2))); 




doRecursiveMutliplicationRec((__cilk_box<double ** >(mat1)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<double ** >(mat2)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<double ** >(mat3)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1)), (__cilk_box<int >((size + 1) / 2)), (__cilk_box<int >(size - 1))); 




} 


__declspec( noinline ) int  /* __cilk */ __cdecl cilk_main() { __CILK_FUNCTION_PROLOGUE;
auto int s; auto int doIter; 
(cout << (("Enter size: "))); 
(cin >> s); 
(cout << ((" No of iterations \? "))); 
(cin >> doIter); 

if ((s <= 0) || (doIter <= 0)) { 
(cout << (("Input unexpected.. terminating.. "))); 
return; 
}  

(((cout << ((std::endl))) << (("*******************************************"))) << ((std::endl))); 
((cout << (("1. Simple Recursive Multiplication"))) << ((std::endl))); 
for (int i = 0; i < doIter; ++i) { 
auto clock_t begin = __cilk_call<20>((clock_t (__cdecl *)(void))&::clock)(); 
doRecursiveMultiplication((__cilk_box<int >(s))); 

auto clock_t end = __cilk_call<21>((clock_t (__cdecl *)(void))&::clock)(); 

((cout << ((double)(end - begin) / (1000))) << (("\t"))); 
}  
(cout << ((std::endl))); 

(((cout << ((std::endl))) << (("*******************************************"))) << ((std::endl))); 
((cout << (("2. Simple Multiplication"))) << ((std::endl))); 
for (int i = 0; i < doIter; ++i) { 
auto clock_t begin = __cilk_call<22>((clock_t (__cdecl *)(void))&::clock)(); 
doSimpleMultiplication((__cilk_box<int >(s))); 

auto clock_t end = __cilk_call<23>((clock_t (__cdecl *)(void))&::clock)(); 

((cout << ((double)(end - begin) / (1000))) << (("\t"))); 
}  
(cout << ((std::endl))); 

(((cout << ((std::endl))) << (("*******************************************"))) << ((std::endl))); 
((cout << (("3. Inner loop parallel Multiplication: "))) << ((std::endl))); 
for (int i = 0; i < doIter; ++i) { 
auto clock_t begin = __cilk_call<24>((clock_t (__cdecl *)(void))&::clock)(); 

doInnerLoopParaellMultiplication((__cilk_box<int >(s))); 

auto clock_t end = __cilk_call<25>((clock_t (__cdecl *)(void))&::clock)(); 
((cout << ((double)(end - begin) / (1000))) << (("\t"))); 
}  
(cout << ((std::endl))); 

(((cout << ((std::endl))) << (("*******************************************"))) << ((std::endl))); 
((cout << (("4. Outer loop parallel Multiplication: "))) << ((std::endl))); 
for (int i = 0; i < doIter; ++i) { 
auto clock_t begin = __cilk_call<26>((clock_t (__cdecl *)(void))&::clock)(); 

doOuterLoopParaellMultiplication((__cilk_box<int >(s))); 

auto clock_t end = __cilk_call<27>((clock_t (__cdecl *)(void))&::clock)(); 
((cout << ((double)(end - begin) / (1000))) << (("\t"))); 
}  
(cout << ((std::endl))); 

(((cout << ((std::endl))) << (("*******************************************"))) << ((std::endl))); 
((cout << (("5. Both loop parallel Multiplication: "))) << ((std::endl))); 
for (int i = 0; i < doIter; ++i) { 
auto clock_t begin = __cilk_call<28>((clock_t (__cdecl *)(void))&::clock)(); 

doBothLoopParaellMultiplication((__cilk_box<int >(s))); 

auto clock_t end = __cilk_call<29>((clock_t (__cdecl *)(void))&::clock)(); 
((cout << ((double)(end - begin) / (1000))) << (("\t"))); 
}  
(cout << ((std::endl))); 

(((cout << ((std::endl))) << (("*******************************************"))) << ((std::endl))); 
((cout << (("6. Parallel Recursive Multiplication"))) << ((std::endl))); 
for (int i = 0; i < doIter; ++i) { 
auto clock_t begin = __cilk_call<30>((clock_t (__cdecl *)(void))&::clock)(); 
doParallelRecursiveMultiplication((__cilk_box<int >(s))); 

auto clock_t end = __cilk_call<31>((clock_t (__cdecl *)(void))&::clock)(); 

((cout << ((double)(end - begin) / (1000))) << (("\t"))); 
}  
(cout << ((std::endl))); 
(((cout << ((std::endl))) << (("*******************************************"))) << ((std::endl))); 

((cout << (("End of Processing"))) << ((std::endl))); 

auto int x; (cin >> x); 
return 0; 
} 
#pragma warning ( push )
#pragma warning ( disable: 4355 )
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\utility"
namespace std { template<> inline void swap(_Aux_cont *&_Left, _Aux_cont *&_Right) 
{ 
if ((&_Left) != (&_Right)) 
{ 
auto _Aux_cont *_Tmp = (_Left); 

_Left = _Right; 
_Right = _Tmp; 
}  
} } 
#line 16
namespace std { template<> inline void swap(_Aux_cont &_Left, _Aux_cont &_Right) 
{ 
if ((&_Left) != (&_Right)) 
{ 
auto _Aux_cont _Tmp = (_Left); 

_Left = _Right; 
_Right = _Tmp; 
}  
} } 
#line 123 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xmemory"
namespace std { template<> inline allocator< char> ::allocator(const std::allocator< char>  &__T21758840) throw() 
{ 
} } 
#line 470 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xstring"
namespace std { template<> inline __declspec( noinline ) _String_val< char, allocator< char> > ::_String_val(_Alty _Al) : _Alval(_Al) 

{ 
} }  __CILK_BEGIN_INSTANTIATE_METADATA std::allocator< char>  __CILK_END_INSTANTIATE_METADATA
#line 119 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xmemory"
namespace std { template<> inline allocator< char> ::allocator() throw() 
{ 
} } 
#line 586 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\iosfwd"
namespace std { namespace _Traits_helper { template<> inline char_traits< char> ::char_type *copy_s< char_traits< char> > (char_traits< char> ::char_type *, size_t, const char_traits< char> ::char_type *, size_t); } } 
#line 574
namespace std { template<> inline _Char_traits_category< char_traits< char> > ::_Secure_char_traits _Char_traits_cat< char_traits< char> > () 
{ 
auto _Char_traits_category< char_traits< char> > ::_Secure_char_traits _Secure; 
return _Secure; 
} } 
#line 594
namespace std { namespace _Traits_helper { template<> inline char_traits< char> ::char_type *copy_s< char_traits< char> > (char_traits< char> ::char_type *_First1, size_t _Size, const char_traits< char> ::char_type *
_First2, size_t _Count, _Secure_char_traits_tag __T21825332) 
{ 
return char_traits< char> ::_Copy_s(_First1, _Size, _First2, _Count); 
} } } 
#line 586
namespace std { namespace _Traits_helper { template<> inline char_traits< char> ::char_type *copy_s< char_traits< char> > (char_traits< char> ::char_type *_First1, size_t _Size, const char_traits< char> ::char_type *
_First2, size_t _Count) 
{ 
return copy_s< char_traits< char> > (_First1, _Size, _First2, _Count, _Char_traits_cat< char_traits< char> > ()); 
} } } 
#line 138 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xmemory"
namespace std { template<> inline void allocator< char> ::deallocate(pointer _Ptr, size_type __T21760592) 
{ 
::operator delete(_Ptr); 
} } 
#line 2168 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xstring"
namespace std { template<> inline char *basic_string< char, char_traits< char> , allocator< char> > ::_Myptr() 
{ 
return ((_BUF_SIZE) <= this->_Myres) ? ((this->_Bx)._Ptr) : ((this->_Bx)._Buf); 
} } 
#line 2112
namespace std { template<> inline __declspec( noinline ) void basic_string< char, char_traits< char> , allocator< char> > ::_Eos(size_type _Newsize) 
{ 
char_traits< char> ::assign(this->_Myptr()[(this->_Mysize) = _Newsize], ((char)0)); 
} } 
#line 2146
namespace std { template<> inline __declspec( noinline ) void basic_string< char, char_traits< char> , allocator< char> > ::_Tidy(bool _Built, size_type 
_Newsize) 
{ 
if (!_Built) { 
; } else { 
if ((_BUF_SIZE) <= this->_Myres) 
{ 
auto char *_Ptr = ((this->_Bx)._Ptr); 
if ((0) < _Newsize) { 
_Traits_helper::copy_s< char_traits< char> > ((this->_Bx)._Buf, _BUF_SIZE, _Ptr, _Newsize); }  
(this->std::_String_val< char, allocator< char> > ::_Alval).deallocate(_Ptr, this->_Myres + (1)); 
}  }  
(this->_Myres) = ((_BUF_SIZE) - 1); 
this->_Eos(_Newsize); 
} } 
#line 563
namespace std { template<> inline __declspec( noinline ) basic_string< char, char_traits< char> , allocator< char> > ::basic_string() : std::_String_val< char, allocator< char> > () 

{ 
this->_Tidy(); 
} }  __CILK_BEGIN_INSTANTIATE_METADATA std::_String_val< char, std::allocator< char> >  __CILK_END_INSTANTIATE_METADATA
#line 2132
namespace std { template<> inline __declspec( noinline ) bool basic_string< char, char_traits< char> , allocator< char> > ::_Inside(const char *_Ptr) 
{ 
if (((_Ptr == (0)) || (_Ptr < this->_Myptr())) || (this->_Myptr() + this->_Mysize <= _Ptr)) { 
return false; } else { 

return true; }  
} } 
#line 613 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\iosfwd"
namespace std { namespace _Traits_helper { template<> inline char_traits< char> ::char_type *move_s< char_traits< char> > (char_traits< char> ::char_type *, size_t, const char_traits< char> ::char_type *, size_t); } } 
#line 621
namespace std { namespace _Traits_helper { template<> inline char_traits< char> ::char_type *move_s< char_traits< char> > (char_traits< char> ::char_type *_First1, size_t _Size, const char_traits< char> ::char_type *
_First2, size_t _Count, _Secure_char_traits_tag __T22021372) 
{ 
return char_traits< char> ::_Move_s(_First1, _Size, _First2, _Count); 
} } } 
#line 613
namespace std { namespace _Traits_helper { template<> inline char_traits< char> ::char_type *move_s< char_traits< char> > (char_traits< char> ::char_type *_First1, size_t _Size, const char_traits< char> ::char_type *
_First2, size_t _Count) 
{ 
return move_s< char_traits< char> > (_First1, _Size, _First2, _Count, _Char_traits_cat< char_traits< char> > ()); 
} } } 
#line 1260 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xstring"
namespace std { template<> inline __declspec( noinline ) basic_string< char, char_traits< char> , allocator< char> > ::_Myt &basic_string< char, char_traits< char> , allocator< char> > ::erase(size_type _Off, size_type 
_Count) 
{ 
if (this->_Mysize < _Off) { 
_String_base::_Xran(); }  
if (this->_Mysize - _Off < _Count) { 
_Count = this->_Mysize - _Off; }  
if ((0) < _Count) 
{ 
_Traits_helper::move_s< char_traits< char> > (this->_Myptr() + _Off, this->_Myres - _Off, (this->_Myptr() + _Off) + _Count, (this->_Mysize - _Off) - _Count); 

auto size_type _Newsize = (this->_Mysize - _Count); 
this->_Eos(_Newsize); 
}  
return *this; 
} } 
#line 163 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xmemory"
namespace std { template<> inline size_t allocator< char> ::max_size() const throw() 
{ 
auto size_t _Count = (((size_t)(-1)) / sizeof(char)); 
return ((0) < _Count) ? _Count : (1); 
} } 
#line 1669 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xstring"
namespace std { template<> inline __declspec( noinline ) basic_string< char, char_traits< char> , allocator< char> > ::size_type basic_string< char, char_traits< char> , allocator< char> > ::max_size() const 
{ 
auto size_type _Num = (this->std::_String_val< char, allocator< char> > ::_Alval).max_size(); 
return (_Num <= (1)) ? (1) : (_Num - (1)); 
} } 
#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xmemory"
namespace std { template<> inline __declspec( noinline ) allocator< char> ::value_type *_Allocate(size_t _Count, allocator< char> ::value_type *__T22086580) 
{ 
if (_Count <= (0)) { 
_Count = (0); } else { 
if (((size_t)(-1)) / _Count < sizeof(allocator< char> ::value_type)) { 
__cilk_s::throw0<bad_alloc >( ((bad_alloc)(0))); }  }  


return (allocator< char> ::value_type *)::operator new(_Count * sizeof(allocator< char> ::value_type)); 
} } 
#line 143
namespace std { template<> inline allocator< char> ::pointer allocator< char> ::allocate(size_type _Count) 
{ 
return _Allocate(_Count, (pointer)0); 
} } 
#line 2082 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xstring"
namespace std { template<> inline __declspec( noinline ) void basic_string< char, char_traits< char> , allocator< char> > ::_Copy(size_type _Newsize, size_type _Oldlen) 
{ 
auto size_type _Newres = (_Newsize | (_ALLOC_MASK)); 
if (this->max_size() < _Newres) { 
_Newres = _Newsize; } else { 
if ((_Newres / (3) < this->_Myres / (2)) && (this->_Myres <= this->max_size() - this->_Myres / (2))) { 

_Newres = this->_Myres + this->_Myres / (2); }  }  
auto char *_Ptr = (0); 

try { 
_Ptr = (this->std::_String_val< char, allocator< char> > ::_Alval).allocate(_Newres + (1)); 
} catch (...) { 
_Newres = _Newsize; 
try { 
_Ptr = (this->std::_String_val< char, allocator< char> > ::_Alval).allocate(_Newres + (1)); 
} catch (...) { 
this->_Tidy(true); 
__cilk_s::rethrow(); 
}  
}  

if ((0) < _Oldlen) { 
_Traits_helper::copy_s< char_traits< char> > (_Ptr, _Newres + (1), this->_Myptr(), _Oldlen); }  
this->_Tidy(true); 
((this->_Bx)._Ptr) = _Ptr; 
(this->_Myres) = _Newres; 
this->_Eos(_Oldlen); 
} } 
#line 2117
namespace std { template<> inline __declspec( noinline ) bool basic_string< char, char_traits< char> , allocator< char> > ::_Grow(size_type _Newsize, bool 
_Trim) 
{ 
if (this->max_size() < _Newsize) { 
_String_base::_Xlen(); }  
if (this->_Myres < _Newsize) { 
this->_Copy(_Newsize, this->_Mysize); } else { 
if (_Trim && (_Newsize < (_BUF_SIZE))) { 
this->_Tidy(true, (_Newsize < this->_Mysize) ? _Newsize : (this->_Mysize)); } else { 

if (_Newsize == (0)) { 
this->_Eos(0); }  }  }  
return (0) < _Newsize; 
} } 
#line 2173
namespace std { template<> inline const char *basic_string< char, char_traits< char> , allocator< char> > ::_Myptr() const 
{ 
return ((_BUF_SIZE) <= this->_Myres) ? ((this->_Bx)._Ptr) : ((this->_Bx)._Buf); 
} } 
#line 1044
namespace std { template<> inline __declspec( noinline ) basic_string< char, char_traits< char> , allocator< char> > ::_Myt &basic_string< char, char_traits< char> , allocator< char> > ::assign(const _Myt &_Right, size_type 
_Roff, size_type _Count) 
{ 
if (_Right.size() < _Roff) { 
_String_base::_Xran(); }  
auto size_type _Num = (_Right.size() - _Roff); 
if (_Count < _Num) { 
_Num = _Count; }  

if (this == (&_Right)) { 
this->erase((size_type)(_Roff + _Num)), this->erase(0, _Roff); } else { 
if (this->_Grow(_Num)) 
{ 
_Traits_helper::copy_s< char_traits< char> > (this->_Myptr(), this->_Myres, _Right._Myptr() + _Roff, _Num); 
this->_Eos(_Num); 
}  }  
return *this; 
} } 

namespace std { template<> inline __declspec( noinline ) basic_string< char, char_traits< char> , allocator< char> > ::_Myt &basic_string< char, char_traits< char> , allocator< char> > ::assign(const char *_Ptr, size_type _Count) 
{ 
#line 1071
if (this->_Inside(_Ptr)) { 
return this->assign(*this, _Ptr - this->_Myptr(), _Count); }  

if (this->_Grow(_Count)) 
{ 
_Traits_helper::copy_s< char_traits< char> > (this->_Myptr(), this->_Myres, _Ptr, _Count); 
this->_Eos(_Count); 
}  
return *this; 
} } 

namespace std { template<> inline __declspec( noinline ) basic_string< char, char_traits< char> , allocator< char> > ::_Myt &basic_string< char, char_traits< char> , allocator< char> > ::assign(const char *_Ptr) 
{ 
; 
return this->assign(_Ptr, char_traits< char> ::length(_Ptr)); 
} } 
#line 649
namespace std { template<> inline __declspec( noinline ) basic_string< char, char_traits< char> , allocator< char> > ::basic_string(const char *_Ptr) : std::_String_val< char, allocator< char> > () 

{ 
this->_Tidy(); 
this->assign(_Ptr); 
} } 
#line 476
namespace std { template<> inline __declspec( noinline ) _String_val< char, allocator< char> > ::_String_val(const std::_String_val< char, allocator< char> >  &_Right) : _Alval(_Right._Alval) 

{ 
#line 485
} } 
#line 719
namespace std { template<> inline __declspec( noinline ) basic_string< char, char_traits< char> , allocator< char> > ::basic_string(const _Myt &_Right) : std::_String_val< char, allocator< char> > (_Right) 

{ 
this->_Tidy(); 
this->assign(_Right, 0, npos); 
} } 
#line 904
namespace std { template<> inline __declspec( noinline ) basic_string< char, char_traits< char> , allocator< char> > ::~basic_string() 
{ 
this->_Tidy(true); 
} } 
#line 919
namespace std { template<> inline __declspec( noinline ) basic_string< char, char_traits< char> , allocator< char> > ::_Myt &basic_string< char, char_traits< char> , allocator< char> > ::operator=(const char *_Ptr) 
{ 
return this->assign(_Ptr); 
} } 
#line 1649
namespace std { template<> inline __declspec( noinline ) const char *basic_string< char, char_traits< char> , allocator< char> > ::c_str() const 
{ 
return this->_Myptr(); 
} } 
#line 1664
namespace std { template<> inline basic_string< char, char_traits< char> , allocator< char> > ::size_type basic_string< char, char_traits< char> , allocator< char> > ::size() const 
{ 
return this->_Mysize; 
} } 
#line 2036
namespace std { template<> inline __declspec( noinline ) int basic_string< char, char_traits< char> , allocator< char> > ::compare(size_type _Off, size_type 
_N0, const char *_Ptr, size_type _Count) const 
{ 
#line 2045
if (this->_Mysize < _Off) { 
_String_base::_Xran(); }  
if (this->_Mysize - _Off < _N0) { 
_N0 = this->_Mysize - _Off; }  

auto size_type _Ans = (char_traits< char> ::compare(this->_Myptr() + _Off, _Ptr, (_N0 < _Count) ? _N0 : _Count)); 

return (_Ans != (0)) ? ((int)_Ans) : ((_N0 < _Count) ? (-1) : ((_N0 == _Count) ? 0 : (+1))); 

} } 
#line 2002
namespace std { template<> inline __declspec( noinline ) int basic_string< char, char_traits< char> , allocator< char> > ::compare(const _Myt &_Right) const 
{ 
return this->compare(0, this->_Mysize, _Right._Myptr(), _Right.size()); 
} } 
#line 2024
namespace std { template<> inline __declspec( noinline ) int basic_string< char, char_traits< char> , allocator< char> > ::compare(const char *_Ptr) const 
{ 
; 
return this->compare(0, this->_Mysize, _Ptr, char_traits< char> ::length(_Ptr)); 
} } 
#line 466 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocale"
namespace std { template<> const locale::facet *_Facetptr< ctype< char> > ::_Psave = (0); } 
#line 483
namespace std { template<> inline __declspec( noinline ) const ctype< char> ::_Myt &__cdecl use_facet< ctype< char> > (const locale &_Loc) 


{ 
{ auto _Lockit _Lock(0); 
auto const locale::facet *_Psave = _Facetptr< ctype< char> > ::_Psave; 


auto size_t _Id = ctype< char> ::id; 
auto const locale::facet *_Pf = _Loc._Getfacet(_Id); 

if (_Pf != (0)) { 
; } else { 
if (_Psave != (0)) { 
_Pf = _Psave; } else { 
if (ctype< char> ::_Getcat(&_Psave, (&_Loc)) == ((size_t)(-1))) { 


__cilk_s::throw0<bad_cast >( bad_cast()); } else 
#line 508
{ 
_Pf = _Psave; 
_Facetptr< ctype< char> > ::_Psave = _Psave; 

auto locale::facet *_Pfmod = ((ctype< char> ::_Myt *)_Psave); 
_Pfmod->_Incref(); 
_Pfmod->_Register(); 
}  }  }  

return (const ctype< char> ::_Myt &)(*_Pf); 
} 
} } 
#line 244 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\streambuf"
namespace std { template<> inline streamsize basic_streambuf< char, char_traits< char> > ::_Gnavail() const 
{ 
return (*(this->_IGnext) != (0)) ? (*(this->_IGcount)) : 0; 
} } 
#line 188
namespace std { template<> inline char *basic_streambuf< char, char_traits< char> > ::gptr() const 
{ 
return *(this->_IGnext); 
} } 
#line 109
namespace std { template<> inline __declspec( noinline ) basic_streambuf< char, char_traits< char> > ::int_type basic_streambuf< char, char_traits< char> > ::sgetc() 
{ 
return (0 < this->_Gnavail()) ? char_traits< char> ::to_int_type(*this->gptr()) : this->underflow(); 

} } 
#line 238
namespace std { template<> inline char *basic_streambuf< char, char_traits< char> > ::_Gnpreinc() 
{ 
--(*(this->_IGcount)); 
return ++(*(this->_IGnext)); 
} } 
#line 232
namespace std { template<> inline char *basic_streambuf< char, char_traits< char> > ::_Gninc() 
{ 
--(*(this->_IGcount)); 
return (*(this->_IGnext))++; 
} } 
#line 103
namespace std { template<> inline __declspec( noinline ) basic_streambuf< char, char_traits< char> > ::int_type basic_streambuf< char, char_traits< char> > ::sbumpc() 
{ 
return (0 < this->_Gnavail()) ? char_traits< char> ::to_int_type(*this->_Gninc()) : this->uflow(); 

} } 
#line 129
namespace std { template<> inline __declspec( noinline ) basic_streambuf< char, char_traits< char> > ::int_type basic_streambuf< char, char_traits< char> > ::snextc() 
{ 
return (1 < this->_Gnavail()) ? char_traits< char> ::to_int_type(*this->_Gnpreinc()) : (char_traits< char> ::eq_int_type(char_traits< char> ::eof(), this->sbumpc()) ? char_traits< char> ::eof() : this->sgetc()); 



} } 
#line 244
namespace std { template<> inline streamsize basic_streambuf< __wchar_t, char_traits< __wchar_t> > ::_Gnavail() const 
{ 
return (*(this->_IGnext) != (0)) ? (*(this->_IGcount)) : 0; 
} } 
#line 188
namespace std { template<> inline __wchar_t *basic_streambuf< __wchar_t, char_traits< __wchar_t> > ::gptr() const 
{ 
return *(this->_IGnext); 
} } 
#line 109
namespace std { template<> inline __declspec( noinline ) basic_streambuf< __wchar_t, char_traits< __wchar_t> > ::int_type basic_streambuf< __wchar_t, char_traits< __wchar_t> > ::sgetc() 
{ 
return (0 < this->_Gnavail()) ? char_traits< __wchar_t> ::to_int_type(*this->gptr()) : this->underflow(); 

} } 
#line 238
namespace std { template<> inline __wchar_t *basic_streambuf< __wchar_t, char_traits< __wchar_t> > ::_Gnpreinc() 
{ 
--(*(this->_IGcount)); 
return ++(*(this->_IGnext)); 
} } 
#line 232
namespace std { template<> inline __wchar_t *basic_streambuf< __wchar_t, char_traits< __wchar_t> > ::_Gninc() 
{ 
--(*(this->_IGcount)); 
return (*(this->_IGnext))++; 
} } 
#line 103
namespace std { template<> inline __declspec( noinline ) basic_streambuf< __wchar_t, char_traits< __wchar_t> > ::int_type basic_streambuf< __wchar_t, char_traits< __wchar_t> > ::sbumpc() 
{ 
return (0 < this->_Gnavail()) ? char_traits< __wchar_t> ::to_int_type(*this->_Gninc()) : this->uflow(); 

} } 
#line 129
namespace std { template<> inline __declspec( noinline ) basic_streambuf< __wchar_t, char_traits< __wchar_t> > ::int_type basic_streambuf< __wchar_t, char_traits< __wchar_t> > ::snextc() 
{ 
return (1 < this->_Gnavail()) ? char_traits< __wchar_t> ::to_int_type(*this->_Gnpreinc()) : (char_traits< __wchar_t> ::eq_int_type(char_traits< __wchar_t> ::eof(), this->sbumpc()) ? char_traits< __wchar_t> ::eof() : this->sgetc()); 



} } 
#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ios"
namespace std { template<> inline void basic_ios< char, char_traits< char> > ::clear(iostate _State, bool _Reraise) 
{ 
this->ios_base::clear((iostate)((this->_Mystrbuf == (0)) ? (_State | ((int)((_Iostate)4))) : _State), _Reraise); 

} } 
#line 52
namespace std { template<> inline __declspec( noinline ) void basic_ios< char, char_traits< char> > ::setstate(iostate _State, bool _Reraise) 
{ 
if (_State != ((_Iostate)0)) { 
this->clear((iostate)((int)this->rdstate() | _State), _Reraise); }  
} } 
#line 83
namespace std { template<> inline basic_ios< char, char_traits< char> > ::_Mysb *basic_ios< char, char_traits< char> > ::rdbuf() const 
{ 
return this->_Mystrbuf; 
} } 
#line 41
namespace std { template<> inline void basic_ios< __wchar_t, char_traits< __wchar_t> > ::clear(iostate _State, bool _Reraise) 
{ 
this->ios_base::clear((iostate)((this->_Mystrbuf == (0)) ? (_State | ((int)((_Iostate)4))) : _State), _Reraise); 

} } 
#line 52
namespace std { template<> inline __declspec( noinline ) void basic_ios< __wchar_t, char_traits< __wchar_t> > ::setstate(iostate _State, bool _Reraise) 
{ 
if (_State != ((_Iostate)0)) { 
this->clear((iostate)((int)this->rdstate() | _State), _Reraise); }  
} } 
#line 83
namespace std { template<> inline basic_ios< __wchar_t, char_traits< __wchar_t> > ::_Mysb *basic_ios< __wchar_t, char_traits< __wchar_t> > ::rdbuf() const 
{ 
return this->_Mystrbuf; 
} } 
#line 170 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ostream"
namespace std { template<> inline __declspec( noinline ) basic_ostream< char, char_traits< char> > ::_Myt &basic_ostream< char, char_traits< char> > ::operator<<(_Myt &(__cdecl *_Pfn)(_Myt &)) 
{ 
; 
return _Pfn(*this); 
} } 
#line 171 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\streambuf"
namespace std { template<> inline __declspec( noinline ) void basic_streambuf< char, char_traits< char> > ::_Lock() 
{ 
(this->_Mylock)._Lock(); 
} } 
#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ostream"
namespace std { template<> inline __declspec( noinline ) basic_ostream< char, char_traits< char> > ::_Sentry_base::_Sentry_base(_Myt &_Ostr) : _Myostr(_Ostr) 

{ 
if ((this->_Myostr).rdbuf() != (0)) { 
(*(this->_Myostr).rdbuf())._Lock(); }  
} } 
#line 176 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\streambuf"
namespace std { template<> inline __declspec( noinline ) void basic_streambuf< char, char_traits< char> > ::_Unlock() 
{ 
(this->_Mylock)._Unlock(); 
} } 
#line 80 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ostream"
namespace std { template<> inline __declspec( noinline ) basic_ostream< char, char_traits< char> > ::_Sentry_base::~_Sentry_base() 
{ 
if ((this->_Myostr).rdbuf() != (0)) { 
(*(this->_Myostr).rdbuf())._Unlock(); }  
} } 
#line 71 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ios"
namespace std { template<> inline basic_ios< char, char_traits< char> > ::_Myos *basic_ios< char, char_traits< char> > ::tie() const 
{ 
return this->_Tiestr; 
} } 
#line 93 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ostream"
namespace std { template<> inline __declspec( noinline ) basic_ostream< char, char_traits< char> > ::sentry::sentry(_Myt &_Ostr) : _Sentry_base(_Ostr) 

{ 
if (_Ostr.good() && (_Ostr.tie() != (0))) { 
(*_Ostr.tie()).flush(); }  
(this->_Ok) = _Ostr.good(); 
} }  __CILK_BEGIN_INSTANTIATE_METADATA std::basic_ostream< char, std::char_traits< char> > ::_Sentry_base __CILK_END_INSTANTIATE_METADATA
#line 138
namespace std { template<> inline __declspec( noinline ) void basic_ostream< char, char_traits< char> > ::_Osfx() 
{ 
try { 
if (this->ios_base::flags() & ((_Fmtflags)2)) { 
this->flush(); }  
} catch (...) { 
}  
} } 
#line 101
namespace std { template<> inline __declspec( noinline ) basic_ostream< char, char_traits< char> > ::sentry::~sentry() 
{ 


if (!std::uncaught_exception()) { 
(this->_Myostr)._Osfx(); }  
} } 
#line 114
namespace std { template<> inline basic_ostream< char, char_traits< char> > ::sentry::operator bool() const 
{ 
return this->_Ok; 
} } 
#line 483 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocale"
namespace std { template<> inline __declspec( noinline ) const basic_ostream< char, char_traits< char> > ::_Nput &__cdecl use_facet< num_put< char, ostreambuf_iterator< char, char_traits< char> > > > (const locale &); } 
#line 466
namespace std { template<> const locale::facet *_Facetptr< num_put< char, ostreambuf_iterator< char, char_traits< char> > > > ::_Psave = (0); } 
#line 1048 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocnum"
namespace std { template<> inline void num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::_Init(const _Locinfo &_Lobj) 
{ 
(this->_Cvt) = _Lobj._Getcvt(); 
} } 
#line 1043
namespace std { template<> inline __declspec( noinline ) num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::~num_put() 
{ 
} } 
#line 483 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocale"
namespace std { template<> inline __declspec( noinline ) const num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::_Mypunct &__cdecl use_facet< numpunct< char> > (const locale &); } 
#line 466
namespace std { template<> const locale::facet *_Facetptr< numpunct< char> > ::_Psave = (0); } 
#line 622
namespace std { template<> inline char *__cdecl _Maklocstr(const char *_Ptr, char *__T22283212, const _Locinfo::_Cvtvec &__T22283324) 

{ 
auto size_t _Count = (::strlen(_Ptr) + (1)); 
auto char *_Ptrdest = (new char [_Count]); 

#pragma warning(push)
#pragma warning(disable: 6011)

for (char *_Ptrnext = _Ptrdest; (0) < _Count; ((--_Count), (++_Ptrnext)), (++_Ptr)) { 
(*_Ptrnext) = (char)((unsigned char)(*_Ptr)); }  
return _Ptrdest; 
#pragma warning(pop)
} } 
#line 189 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocnum"
namespace std { template<> inline void numpunct< char> ::_Tidy() 
{ 
delete [] ((void *)(this->_Grouping)); 
delete [] ((void *)(this->_Falsename)); 
delete [] ((void *)(this->_Truename)); 
} } 
#line 600 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocale"
namespace std { template<> inline char __cdecl _Maklocchr(char _Byte, char *__T22287652, const _Locinfo::_Cvtvec &__T22287764) 

{ 
return (char)((unsigned char)_Byte); 
} } 
#line 134 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocnum"
namespace std { template<> inline __declspec( noinline ) void numpunct< char> ::_Init(const _Locinfo &_Lobj, bool _Isdef) 
{ 
auto const lconv *_Ptr = _Lobj._Getlconv(); 

(this->_Grouping) = (0); 
(this->_Falsename) = (0); 
(this->_Truename) = (0); 

try { 
(this->_Grouping) = _Maklocstr(_Ptr->grouping, (char *)0, _Lobj._Getcvt()); 
(this->_Falsename) = _Maklocstr(_Lobj._Getfalse(), (char *)0, _Lobj._Getcvt()); 
(this->_Truename) = _Maklocstr(_Lobj._Gettrue(), (char *)0, _Lobj._Getcvt()); 
} catch (...) { 
this->_Tidy(); 
__cilk_s::rethrow(); 
}  

(this->_Dp) = _Maklocchr((_Ptr->decimal_point)[0], (char *)0, _Lobj._Getcvt()); 
(this->_Kseparator) = _Maklocchr((_Ptr->thousands_sep)[0], (char *)0, _Lobj._Getcvt()); 


if (_Isdef) 
{ 
(this->_Grouping) = _Maklocstr("", (char *)0, _Lobj._Getcvt()); 
(this->_Dp) = _Maklocchr('.', (char *)0, _Lobj._Getcvt()); 
(this->_Kseparator) = _Maklocchr(',', (char *)0, _Lobj._Getcvt()); 
}  
} } 
#line 120
namespace std { template<> inline __declspec( noinline ) numpunct< char> ::~numpunct() 
{ 
this->_Tidy(); 
} } 
#line 163
namespace std { template<> inline char numpunct< char> ::do_decimal_point() const 
{ 
return this->_Dp; 
} } 

namespace std { template<> inline char numpunct< char> ::do_thousands_sep() const 
{ 
return this->_Kseparator; 
} } 

namespace std { template<> inline __declspec( noinline ) string numpunct< char> ::do_grouping() const 
{ 
return ((string)(this->_Grouping)); 
} } 

namespace std { template<> inline __declspec( noinline ) numpunct< char> ::string_type numpunct< char> ::do_falsename() const 
{ 
return ((string_type)(this->_Falsename)); 
} } 

namespace std { template<> inline __declspec( noinline ) numpunct< char> ::string_type numpunct< char> ::do_truename() const 
{ 
return ((string_type)(this->_Truename)); 
} } 
#line 104
namespace std { template<> inline __declspec( noinline ) numpunct< char> ::numpunct(const _Locinfo &_Lobj, size_t _Refs, bool _Isdef) : locale::facet(_Refs) 

{ 
this->_Init(_Lobj, _Isdef); 
} } 

namespace std { template<> inline __declspec( noinline ) size_t numpunct< char> ::_Getcat(const locale::facet **_Ppf, const locale *
_Ploc) 
{ 
if ((_Ppf != (0)) && (*_Ppf == (0))) { 
(*_Ppf) = (new std::numpunct< char> (((_Locinfo)(_Ploc->name())), 0, true)); }  

return 4; 
} }  __CILK_BEGIN_INSTANTIATE_METADATA std::numpunct< char>  __CILK_END_INSTANTIATE_METADATA
#line 483 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocale"
namespace std { template<> inline __declspec( noinline ) const num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::_Mypunct &__cdecl use_facet< numpunct< char> > (const locale &_Loc) 


{ 
{ auto _Lockit _Lock(0); 
auto const locale::facet *_Psave = _Facetptr< numpunct< char> > ::_Psave; 


auto size_t _Id = numpunct< char> ::id; 
auto const locale::facet *_Pf = _Loc._Getfacet(_Id); 

if (_Pf != (0)) { 
; } else { 
if (_Psave != (0)) { 
_Pf = _Psave; } else { 
if (numpunct< char> ::_Getcat(&_Psave, (&_Loc)) == ((size_t)(-1))) { 


__cilk_s::throw0<bad_cast >( bad_cast()); } else 
#line 508
{ 
_Pf = _Psave; 
_Facetptr< numpunct< char> > ::_Psave = _Psave; 

auto locale::facet *_Pfmod = ((num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::_Mypunct *)_Psave); 
_Pfmod->_Incref(); 
_Pfmod->_Register(); 
}  }  }  

return (const num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::_Mypunct &)(*_Pf); 
} 
} } 
#line 88 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocnum"
namespace std { template<> inline __declspec( noinline ) numpunct< char> ::string_type numpunct< char> ::truename() const 
{ 
return this->do_truename(); 
} } 
#line 1039 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xstring"
namespace std { template<> inline __declspec( noinline ) basic_string< char, char_traits< char> , allocator< char> > ::_Myt &basic_string< char, char_traits< char> , allocator< char> > ::assign(const _Myt &_Right) 
{ 
return this->assign(_Right, 0, npos); 
} } 
#line 83 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocnum"
namespace std { template<> inline __declspec( noinline ) numpunct< char> ::string_type numpunct< char> ::falsename() const 
{ 
return this->do_falsename(); 
} } 
#line 605 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\streambuf"
namespace std { template<> inline ostreambuf_iterator< char, char_traits< char> > ::_Myt &ostreambuf_iterator< char, char_traits< char> > ::operator++() 
{ 
return *this; 
} } 
#line 600
namespace std { template<> inline ostreambuf_iterator< char, char_traits< char> > ::_Myt &ostreambuf_iterator< char, char_traits< char> > ::operator*() 
{ 
return *this; 
} } 
#line 275
namespace std { template<> inline streamsize basic_streambuf< char, char_traits< char> > ::_Pnavail() const 
{ 
return (*(this->_IPnext) != (0)) ? (*(this->_IPcount)) : 0; 
} } 
#line 269
namespace std { template<> inline char *basic_streambuf< char, char_traits< char> > ::_Pninc() 
{ 
--(*(this->_IPcount)); 
return (*(this->_IPnext))++; 
} } 
#line 159
namespace std { template<> inline __declspec( noinline ) basic_streambuf< char, char_traits< char> > ::int_type basic_streambuf< char, char_traits< char> > ::sputc(char _Ch) 
{ 
return (0 < this->_Pnavail()) ? char_traits< char> ::to_int_type((*this->_Pninc()) = _Ch) : this->overflow(char_traits< char> ::to_int_type(_Ch)); 


} } 
#line 591
namespace std { template<> inline __declspec( noinline ) ostreambuf_iterator< char, char_traits< char> > ::_Myt &ostreambuf_iterator< char, char_traits< char> > ::operator=(char _Right) 
{ 
if ((this->_Strbuf == (0)) || char_traits< char> ::eq_int_type(char_traits< char> ::eof(), (*(this->_Strbuf)).sputc(_Right))) { 


(this->_Failed) = true; }  
return *this; 
} } 
#line 1545 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocnum"
namespace std { template<> inline ostreambuf_iterator< char, char_traits< char> >  num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::_Rep(ostreambuf_iterator< char, char_traits< char> >  _Dest, char 
_Ch, size_t _Count) const 
{ 
for (; (0) < _Count; (--_Count), (++_Dest)) { 
((*_Dest) = _Ch); }  
return _Dest; 
} }  __CILK_BEGIN_INSTANTIATE_METADATA std::ostreambuf_iterator< char, std::char_traits< char> >  __CILK_END_INSTANTIATE_METADATA
#line 1510
namespace std { template<> inline ostreambuf_iterator< char, char_traits< char> >  num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::_Put(ostreambuf_iterator< char, char_traits< char> >  _Dest, const char *
_Ptr, size_t _Count) const 
{ 
for (; (0) < _Count; ((--_Count), (++_Dest)), (++_Ptr)) { 
((*_Dest) = (*_Ptr)); }  
return _Dest; 
} } 
#line 1124
namespace std { template<> inline __declspec( noinline ) ostreambuf_iterator< char, char_traits< char> >  num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::do_put(ostreambuf_iterator< char, char_traits< char> >  _Dest, ios_base &
_Iosbase, char _Fill, _Bool _Val) const 
{ 
; 
if (!(_Iosbase.flags() & ((_Iosb< int> ::_Fmtflags)16384))) { 
return this->do_put(_Dest, _Iosbase, _Fill, (long)_Val); } else 

{ 
auto const _Mypunct &_Punct_fac = use_facet< numpunct< char> > (_Iosbase.getloc()); 
auto _Mystr _Str; 
if (_Val) { 
_Str.assign(_Punct_fac.truename()); } else { 

_Str.assign(_Punct_fac.falsename()); }  

auto size_t _Fillcount = (((_Iosbase.width() <= 0) || ((size_t)_Iosbase.width() <= _Str.size())) ? (0) : ((size_t)_Iosbase.width() - _Str.size())); 



if ((_Iosbase.flags() & ((_Iosb< int> ::_Fmtflags)448)) != ((_Iosb< int> ::_Fmtflags)64)) 
{ 
_Dest = this->_Rep(_Dest, _Fill, _Fillcount); 
_Fillcount = (0); 
}  
_Dest = this->_Put(_Dest, _Str.c_str(), _Str.size()); 
_Iosbase.width(0); 
return this->_Rep(_Dest, _Fill, _Fillcount); 
}  
} } 
#line 78
namespace std { template<> inline __declspec( noinline ) string numpunct< char> ::grouping() const 
{ 
return this->do_grouping(); 
} } 
#line 1518
namespace std { template<> inline ostreambuf_iterator< char, char_traits< char> >  num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::_Putc(ostreambuf_iterator< char, char_traits< char> >  _Dest, const char *
_Ptr, size_t _Count) const 
{ 
for (; (0) < _Count; ((--_Count), (++_Dest)), (++_Ptr)) { 
((*_Dest) = _Maklocchr(*_Ptr, (char *)0, this->_Cvt)); }  
return _Dest; 
} } 

namespace std { template<> inline __declspec( noinline ) ostreambuf_iterator< char, char_traits< char> >  num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::_Putgrouped(ostreambuf_iterator< char, char_traits< char> >  _Dest, const char *
_Ptr, size_t _Count, char _Kseparator) const 
{ 
for (; ; (++_Ptr), (--_Count)) 
{ 
auto const char *_Pend = ((const char *)::memchr(_Ptr, '\000', _Count)); 

auto size_t _Groupsize = ((_Pend != (0)) ? (_Pend - _Ptr) : _Count); 

_Dest = this->_Putc(_Dest, _Ptr, _Groupsize); 
(_Ptr += _Groupsize), (_Count -= _Groupsize); 
if (_Count == (0)) { 
break; }  
if (_Kseparator != ((char)0)) { 
_Dest = this->_Rep(_Dest, _Kseparator, 1); }  
}  
return _Dest; 
} } 
#line 73
namespace std { template<> inline __declspec( noinline ) char numpunct< char> ::thousands_sep() const 
{ 
return this->do_thousands_sep(); 
} } 
#line 1459
namespace std { template<> inline __declspec( noinline ) ostreambuf_iterator< char, char_traits< char> >  num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::_Iput(ostreambuf_iterator< char, char_traits< char> >  _Dest, ios_base &
_Iosbase, char _Fill, char *_Buf, size_t _Count) const 
{ 
; 
auto const _Mypunct &_Punct_fac = use_facet< numpunct< char> > (_Iosbase.getloc()); 
auto const string _Grouping = _Punct_fac.grouping(); 
auto const size_t _Prefix = (((*_Buf == ('+')) || (*_Buf == ('-'))) ? 1 : (((*_Buf == ('0')) && ((_Buf[1] == ('x')) || (_Buf[1] == ('X')))) ? 2 : 0)); 



if ((*_Grouping.c_str() != 127) && (('\000') < *_Grouping.c_str())) 
{ 
auto const char *_Pg = _Grouping.c_str(); 
auto size_t _Off = _Count; 
while (((*_Pg != 127) && (('\000') < *_Pg)) && ((size_t)(*_Pg) < _Off - _Prefix)) 

{ 
_Off -= *_Pg; 
::memmove_s(_Buf + (_Off + (1)), (_Count + (1)) - _Off, _Buf + _Off, (_Count + (1)) - _Off); 

((_Buf[_Off]) = '\000'), (++_Count); 
if (('\000') < _Pg[1]) { 
++_Pg; }  
}  
}  

auto size_t _Fillcount = (((_Iosbase.width() <= 0) || ((size_t)_Iosbase.width() <= _Count)) ? (0) : ((size_t)_Iosbase.width() - _Count)); 



auto ios_base::fmtflags _Adjustfield = (_Iosbase.flags() & ((_Iosb< int> ::_Fmtflags)448)); 

if ((_Adjustfield != ((_Iosb< int> ::_Fmtflags)64)) && (_Adjustfield != ((_Iosb< int> ::_Fmtflags)256))) 

{ 
_Dest = this->_Rep(_Dest, _Fill, _Fillcount); 
_Fillcount = (0); 
} else { 
if (_Adjustfield == ((_Iosb< int> ::_Fmtflags)256)) 
{ 
_Dest = this->_Putc(_Dest, _Buf, _Prefix); 
(_Buf += _Prefix), (_Count -= _Prefix); 
(_Dest = this->_Rep(_Dest, _Fill, _Fillcount)), (_Fillcount = (0)); 
}  }  

_Dest = this->_Putgrouped(_Dest, _Buf, _Count, _Punct_fac.thousands_sep()); 

_Iosbase.width(0); 
return this->_Rep(_Dest, _Fill, _Fillcount); 
} } 
#line 1432
namespace std { template<> inline char *num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::_Ifmt(char *_Fmt, const char *
_Spec, ios_base::fmtflags _Flags) const 
{ 
auto char *_Ptr = _Fmt; 
(*(_Ptr++)) = '%'; 

if (_Flags & ((_Iosb< int> ::_Fmtflags)32)) { 
(*(_Ptr++)) = '+'; }  
if (_Flags & ((_Iosb< int> ::_Fmtflags)8)) { 
(*(_Ptr++)) = '#'; }  
if (_Spec[0] != ('L')) { 
(*(_Ptr++)) = _Spec[0]; } else 

{ 
(*(_Ptr++)) = 'I'; 
(*(_Ptr++)) = '6'; 
(*(_Ptr++)) = '4'; 
}  

auto ios_base::fmtflags _Basefield = (_Flags & ((_Iosb< int> ::_Fmtflags)3584)); 
(*(_Ptr++)) = (_Basefield == ((_Iosb< int> ::_Fmtflags)1024)) ? 'o' : ((_Basefield != ((_Iosb< int> ::_Fmtflags)2048)) ? (_Spec[1]) : ((_Flags & ((_Iosb< int> ::_Fmtflags)4)) ? 'X' : 'x')); 


(*_Ptr) = '\000'; 
return _Fmt; 
} } 
#line 1154
namespace std { template<> inline __declspec( noinline ) ostreambuf_iterator< char, char_traits< char> >  num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::do_put(ostreambuf_iterator< char, char_traits< char> >  _Dest, ios_base &
_Iosbase, char _Fill, long _Val) const 
{ 
auto const size_t _Buf_size = (2 * 32); 
auto char _Buf[64U]; auto char _Fmt[6]; 
return this->_Iput(_Dest, _Iosbase, _Fill, _Buf, ::sprintf_s(_Buf, _Buf_size, this->_Ifmt(_Fmt, "ld", _Iosbase.flags()), _Val)); 


} } 

namespace std { template<> inline __declspec( noinline ) ostreambuf_iterator< char, char_traits< char> >  num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::do_put(ostreambuf_iterator< char, char_traits< char> >  _Dest, ios_base &
_Iosbase, char _Fill, unsigned long _Val) const 
{ 
auto const size_t _Buf_size = (2 * 32); 
auto char _Buf[64U]; auto char _Fmt[6]; 
return this->_Iput(_Dest, _Iosbase, _Fill, _Buf, ::sprintf_s(_Buf, _Buf_size, this->_Ifmt(_Fmt, "lu", _Iosbase.flags()), _Val)); 


} } 


namespace std { template<> inline __declspec( noinline ) ostreambuf_iterator< char, char_traits< char> >  num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::do_put(ostreambuf_iterator< char, char_traits< char> >  _Dest, ios_base &
_Iosbase, char _Fill, __int64 _Val) const 
{ 
auto const size_t _Buf_size = (2 * 32); 
auto char _Buf[64U]; auto char _Fmt[8]; 
return this->_Iput(_Dest, _Iosbase, _Fill, _Buf, ::sprintf_s(_Buf, _Buf_size, this->_Ifmt(_Fmt, "Ld", _Iosbase.flags()), _Val)); 


} } 

namespace std { template<> inline __declspec( noinline ) ostreambuf_iterator< char, char_traits< char> >  num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::do_put(ostreambuf_iterator< char, char_traits< char> >  _Dest, ios_base &
_Iosbase, char _Fill, unsigned __int64 _Val) const 
{ 
auto const size_t _Buf_size = (2 * 32); 
auto char _Buf[64U]; auto char _Fmt[8]; 
return this->_Iput(_Dest, _Iosbase, _Fill, _Buf, ::sprintf_s(_Buf, _Buf_size, this->_Ifmt(_Fmt, "Lu", _Iosbase.flags()), _Val)); 


} } 
#line 949 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xstring"
namespace std { template<> inline __declspec( noinline ) basic_string< char, char_traits< char> , allocator< char> > ::_Myt &basic_string< char, char_traits< char> , allocator< char> > ::append(const _Myt &_Right, size_type 
_Roff, size_type _Count) 
{ 
if (_Right.size() < _Roff) { 
_String_base::_Xran(); }  
auto size_type _Num = (_Right.size() - _Roff); 
if (_Num < _Count) { 
_Count = _Num; }  
if ((npos - this->_Mysize <= _Count) || (this->_Mysize + _Count < this->_Mysize)) { 
_String_base::_Xlen(); }  

if (((0) < _Count) && this->_Grow(_Num = this->_Mysize + _Count)) 
{ 
_Traits_helper::copy_s< char_traits< char> > (this->_Myptr() + this->_Mysize, this->_Myres - this->_Mysize, _Right._Myptr() + _Roff, _Count); 

this->_Eos(_Num); 
}  
return *this; 
} } 

namespace std { template<> inline __declspec( noinline ) basic_string< char, char_traits< char> , allocator< char> > ::_Myt &basic_string< char, char_traits< char> , allocator< char> > ::append(const char *_Ptr, size_type _Count) 
{ 
#line 977
if (this->_Inside(_Ptr)) { 
return this->append(*this, _Ptr - this->_Myptr(), _Count); }  
if ((npos - this->_Mysize <= _Count) || (this->_Mysize + _Count < this->_Mysize)) { 
_String_base::_Xlen(); }  

auto size_type _Num; 
if (((0) < _Count) && this->_Grow(_Num = this->_Mysize + _Count)) 
{ 
_Traits_helper::copy_s< char_traits< char> > (this->_Myptr() + this->_Mysize, this->_Myres - this->_Mysize, _Ptr, _Count); 
this->_Eos(_Num); 
}  
return *this; 
} } 
#line 2074
namespace std { template<> inline __declspec( noinline ) void basic_string< char, char_traits< char> , allocator< char> > ::_Chassign(size_type _Off, size_type _Count, char _Ch) 
{ 
if (_Count == (1)) { 
char_traits< char> ::assign(*(this->_Myptr() + _Off), _Ch); } else { 

char_traits< char> ::assign(this->_Myptr() + _Off, _Count, _Ch); }  
} } 
#line 997
namespace std { template<> inline __declspec( noinline ) basic_string< char, char_traits< char> , allocator< char> > ::_Myt &basic_string< char, char_traits< char> , allocator< char> > ::append(size_type _Count, char _Ch) 
{ 
if (npos - this->_Mysize <= _Count) { 
_String_base::_Xlen(); }  

auto size_type _Num; 
if (((0) < _Count) && this->_Grow(_Num = this->_Mysize + _Count)) 
{ 
this->_Chassign(this->_Mysize, _Count, _Ch); 
this->_Eos(_Num); 
}  
return *this; 
} } 
#line 1194
namespace std { template<> inline __declspec( noinline ) basic_string< char, char_traits< char> , allocator< char> > ::_Myt &basic_string< char, char_traits< char> , allocator< char> > ::insert(size_type _Off, size_type 
_Count, char _Ch) 
{ 
if (this->_Mysize < _Off) { 
_String_base::_Xran(); }  
if (npos - this->_Mysize <= _Count) { 
_String_base::_Xlen(); }  
auto size_type _Num; 
if (((0) < _Count) && this->_Grow(_Num = this->_Mysize + _Count)) 
{ 
_Traits_helper::move_s< char_traits< char> > ((this->_Myptr() + _Off) + _Count, (this->_Myres - _Off) - _Count, this->_Myptr() + _Off, this->_Mysize - _Off); 

this->_Chassign(_Off, _Count, _Ch); 
this->_Eos(_Num); 
}  
return *this; 
} } 
#line 1556
namespace std { template<> inline __declspec( noinline ) basic_string< char, char_traits< char> , allocator< char> > ::reference basic_string< char, char_traits< char> , allocator< char> > ::operator[](size_type _Off) 
{ 
#line 1570
{ if (!(_Off <= this->_Mysize)) { (void)0; ::_invalid_parameter_noinfo(); }  ; } ; 


return this->_Myptr()[_Off]; 
} } 
#line 68 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocnum"
namespace std { template<> inline __declspec( noinline ) char numpunct< char> ::decimal_point() const 
{ 
return this->do_decimal_point(); 
} } 
#line 1312
namespace std { template<> inline __declspec( noinline ) ostreambuf_iterator< char, char_traits< char> >  num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::_Fput(ostreambuf_iterator< char, char_traits< char> >  _Dest, ios_base &
_Iosbase, char _Fill, const char *_Buf, size_t 
_Beforepoint, size_t _Afterpoint, size_t 
_Trailing, size_t _Count) const 
{ 
; 
auto const _Mypunct &_Punct_fac = use_facet< numpunct< char> > (_Iosbase.getloc()); 
auto const string _Grouping = _Punct_fac.grouping(); 
auto const char _Kseparator = _Punct_fac.thousands_sep(); 
auto string _Groupstring; 
auto const char _E0 = _Maklocchr('0', (char *)0, this->_Cvt); 
auto size_t _Prefix = (((_Buf[0] == ('+')) || (_Buf[0] == ('-'))) ? 1 : 0); 

auto char _Enders[3]; 
((_Enders)[0]) = ((*::localeconv()).decimal_point)[0]; 
((_Enders)[1]) = 'e'; 
((_Enders)[2]) = '\000'; 

auto const char *_Eptr = ((const char *)::memchr(_Buf, 'e', _Count)); 

auto const char *_Pointptr = ((const char *)::memchr(_Buf, (_Enders)[0], _Count)); 

if (_Pointptr == (0)) { 
_Trailing = (0); }  

if ((*_Grouping.c_str() != 127) && (('\000') < *_Grouping.c_str())) 
{ 
_Groupstring.append(_Buf, _Count); 
if (_Eptr == (0)) { 
_Groupstring.append(_Trailing, '0'); } else 

{ 
if (_Pointptr == (0)) 
{ 
_Groupstring.append(_Beforepoint, '0'); 
_Beforepoint = (0); 
}  
_Groupstring.insert(_Eptr - _Buf, _Trailing, '0'); 
}  
_Trailing = (0); 

if (_Pointptr == (0)) { 
_Groupstring.append(_Beforepoint, '0'); } else 

{ 
_Groupstring.insert((_Pointptr - _Buf) + 1, _Afterpoint, '0'); 
_Groupstring.insert(_Pointptr - _Buf, _Beforepoint, '0'); 
_Afterpoint = (0); 
}  
_Beforepoint = (0); 

auto const char *_Pg = _Grouping.c_str(); 
auto size_t _Off = ::strcspn((&_Groupstring[(0)]), (_Enders) + 0); 
while (((*_Pg != 127) && (('\000') < *_Pg)) && ((size_t)(*_Pg) < _Off - _Prefix)) 

{ 
_Groupstring.insert(_Off -= *_Pg, (size_t)1, '\000'); 
if (('\000') < _Pg[1]) { 
++_Pg; }  
}  

_Buf = (&_Groupstring[(0)]); 
_Trailing = (0); 
_Count = _Groupstring.size(); 
}  

auto size_t _Fillcount = (((_Beforepoint + _Afterpoint) + _Trailing) + _Count); 
_Fillcount = ((_Iosbase.width() <= 0) || ((size_t)_Iosbase.width() <= _Fillcount)) ? (0) : ((size_t)_Iosbase.width() - _Fillcount); 


auto ios_base::fmtflags _Adjustfield = (_Iosbase.flags() & ((_Iosb< int> ::_Fmtflags)448)); 

if ((_Adjustfield != ((_Iosb< int> ::_Fmtflags)64)) && (_Adjustfield != ((_Iosb< int> ::_Fmtflags)256))) 

{ 
_Dest = this->_Rep(_Dest, _Fill, _Fillcount); 
_Fillcount = (0); 
} else { 
if (_Adjustfield == ((_Iosb< int> ::_Fmtflags)256)) 
{ 
if ((0) < _Prefix) 
{ 
_Dest = this->_Putc(_Dest, _Buf, 1); 
(++_Buf), (--_Count); 
}  
_Dest = this->_Rep(_Dest, _Fill, _Fillcount); 
_Fillcount = (0); 
}  }  

_Pointptr = (const char *)::memchr(_Buf, (_Enders)[0], _Count); 

if (_Pointptr != (0)) 
{ 
auto size_t _Fracoffset = ((_Pointptr - _Buf) + 1); 
_Dest = this->_Putgrouped(_Dest, _Buf, _Fracoffset - (1), _Kseparator); 
_Dest = this->_Rep(_Dest, _E0, _Beforepoint); 
_Dest = this->_Rep(_Dest, _Punct_fac.decimal_point(), 1); 
_Dest = this->_Rep(_Dest, _E0, _Afterpoint); 
(_Buf += _Fracoffset), (_Count -= _Fracoffset); 
}  

_Eptr = (const char *)::memchr(_Buf, 'e', _Count); 

if (_Eptr != (0)) 
{ 
auto size_t _Expoffset = ((_Eptr - _Buf) + 1); 
_Dest = this->_Putgrouped(_Dest, _Buf, _Expoffset - (1), _Kseparator); 
(_Dest = this->_Rep(_Dest, _E0, _Trailing)), (_Trailing = (0)); 
_Dest = this->_Putc(_Dest, (_Iosbase.flags() & ((_Iosb< int> ::_Fmtflags)4)) ? ((char *)"E") : ((char *)"e"), 1); 

(_Buf += _Expoffset), (_Count -= _Expoffset); 
}  

_Dest = this->_Putgrouped(_Dest, _Buf, _Count, _Kseparator); 

_Dest = this->_Rep(_Dest, _E0, _Trailing); 
_Iosbase.width(0); 
return this->_Rep(_Dest, _Fill, _Fillcount); 
} } 
#line 1289
namespace std { template<> inline char *num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::_Ffmt(char *_Fmt, char 
_Spec, ios_base::fmtflags _Flags) const 
{ 
auto char *_Ptr = _Fmt; 
(*(_Ptr++)) = '%'; 

if (_Flags & ((_Iosb< int> ::_Fmtflags)32)) { 
(*(_Ptr++)) = '+'; }  
if (_Flags & ((_Iosb< int> ::_Fmtflags)16)) { 
(*(_Ptr++)) = '#'; }  
(*(_Ptr++)) = '.'; 
(*(_Ptr++)) = '*'; 
if (_Spec != ('\000')) { 
(*(_Ptr++)) = _Spec; }  

auto ios_base::fmtflags _Ffl = (_Flags & ((_Iosb< int> ::_Fmtflags)12288)); 
(*(_Ptr++)) = (_Ffl == ((_Iosb< int> ::_Fmtflags)8192)) ? 'f' : ((_Ffl == ((_Iosb< int> ::_Fmtflags)12288)) ? 'a' : ((_Ffl == ((_Iosb< int> ::_Fmtflags)4096)) ? 'e' : 'g')); 


(*_Ptr) = '\000'; 
return _Fmt; 
} } 
#line 1196
namespace std { template<> inline __declspec( noinline ) ostreambuf_iterator< char, char_traits< char> >  num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::do_put(ostreambuf_iterator< char, char_traits< char> >  _Dest, ios_base &
_Iosbase, char _Fill, double _Val) const 
{ 
auto const size_t _Buf_size = ((8 + 36) + 64); 
auto char _Buf[108U]; auto char _Fmt[8]; 
auto streamsize _Precision = (((_Iosbase.precision() <= 0) && (!(_Iosbase.flags() & ((_Iosb< int> ::_Fmtflags)8192)))) ? 6 : _Iosbase.precision()); 


auto int _Significance = ((36 < _Precision) ? 36 : _Precision); 

_Precision -= _Significance; 
auto size_t _Beforepoint = (0); 
auto size_t _Afterpoint = (0); 

if (((_Iosbase.flags() & ((_Iosb< int> ::_Fmtflags)12288)) == ((_Iosb< int> ::_Fmtflags)8192)) && (_Val * (0.5) != _Val)) 

{ 
auto bool _Signed = (_Val < (0)); 
if (_Signed) { 
_Val = -_Val; }  

for (; ((9.9999999999999997e+034) <= _Val) && (_Beforepoint < (5000)); _Beforepoint += (10)) { 
_Val /= (10000000000.0); }  

if ((0) < _Val) { 
for (; ((10 <= _Precision) && (_Val <= (1e-035))) && (_Afterpoint < (5000)); _Afterpoint += (10)) 

{ 
_Val *= (10000000000.0); 
_Precision -= 10; 
}  }  

if (_Signed) { 
_Val = -_Val; }  
}  

return this->_Fput(_Dest, _Iosbase, _Fill, _Buf, _Beforepoint, _Afterpoint, _Precision, ::sprintf_s(_Buf, _Buf_size, this->_Ffmt(_Fmt, 0, _Iosbase.flags()), _Significance, _Val)); 



} } 

namespace std { template<> inline __declspec( noinline ) ostreambuf_iterator< char, char_traits< char> >  num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::do_put(ostreambuf_iterator< char, char_traits< char> >  _Dest, ios_base &
_Iosbase, char _Fill, long double _Val) const 
{ 
auto const size_t _Buf_size = ((8 + 36) + 64); 
auto char _Buf[108U]; auto char _Fmt[8]; 
auto streamsize _Precision = (((_Iosbase.precision() <= 0) && (!(_Iosbase.flags() & ((_Iosb< int> ::_Fmtflags)8192)))) ? 6 : _Iosbase.precision()); 


auto int _Significance = ((36 < _Precision) ? 36 : _Precision); 

_Precision -= _Significance; 
auto size_t _Beforepoint = (0); 
auto size_t _Afterpoint = (0); 

if ((_Iosbase.flags() & ((_Iosb< int> ::_Fmtflags)12288)) == ((_Iosb< int> ::_Fmtflags)8192)) 
{ 
auto bool _Signed = (_Val < (0)); 
if (_Signed) { 
_Val = -_Val; }  

for (; (((9.9999999999999997e+034)) <= _Val) && (_Beforepoint < (5000)); _Beforepoint += (10)) { 
_Val /= ((10000000000.0)); }  

if ((0) < _Val) { 
for (; ((10 <= _Precision) && (_Val <= ((1e-035)))) && (_Afterpoint < (5000)); _Afterpoint += (10)) 

{ 
_Val *= ((10000000000.0)); 
_Precision -= 10; 
}  }  

if (_Signed) { 
_Val = -_Val; }  
}  

return this->_Fput(_Dest, _Iosbase, _Fill, _Buf, _Beforepoint, _Afterpoint, _Precision, ::sprintf_s(_Buf, _Buf_size, this->_Ffmt(_Fmt, 'L', _Iosbase.flags()), _Significance, _Val)); 



} } 

namespace std { template<> inline __declspec( noinline ) ostreambuf_iterator< char, char_traits< char> >  num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::do_put(ostreambuf_iterator< char, char_traits< char> >  _Dest, ios_base &
_Iosbase, char _Fill, const void *_Val) const 
{ 
auto const size_t _Buf_size = (2 * 32); 
auto char _Buf[64U]; 
return this->_Iput(_Dest, _Iosbase, _Fill, _Buf, ::sprintf_s(_Buf, _Buf_size, "%p", _Val)); 

} } 
#line 1064
namespace std { template<> inline __declspec( noinline ) num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::num_put(const _Locinfo &_Lobj, size_t _Refs) : locale::facet(_Refs) 

{ 
this->_Init(_Lobj); 
} } 
#line 1031
namespace std { template<> inline __declspec( noinline ) size_t num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::_Getcat(const locale::facet **_Ppf, const locale *
_Ploc) 
{ 
if ((_Ppf != (0)) && (*_Ppf == (0))) { 
(*_Ppf) = (new std::num_put< char, ostreambuf_iterator< char, char_traits< char> > > (((_Locinfo)(_Ploc->name())))); }  

return 4; 
} }  __CILK_BEGIN_INSTANTIATE_METADATA std::num_put< char, std::ostreambuf_iterator< char, std::char_traits< char> > >  __CILK_END_INSTANTIATE_METADATA
#line 483 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocale"
namespace std { template<> inline __declspec( noinline ) const basic_ostream< char, char_traits< char> > ::_Nput &__cdecl use_facet< num_put< char, ostreambuf_iterator< char, char_traits< char> > > > (const locale &_Loc) 


{ 
{ auto _Lockit _Lock(0); 
auto const locale::facet *_Psave = _Facetptr< num_put< char, ostreambuf_iterator< char, char_traits< char> > > > ::_Psave; 


auto size_t _Id = num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::id; 
auto const locale::facet *_Pf = _Loc._Getfacet(_Id); 

if (_Pf != (0)) { 
; } else { 
if (_Psave != (0)) { 
_Pf = _Psave; } else { 
if (num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::_Getcat(&_Psave, (&_Loc)) == ((size_t)(-1))) { 


__cilk_s::throw0<bad_cast >( bad_cast()); } else 
#line 508
{ 
_Pf = _Psave; 
_Facetptr< num_put< char, ostreambuf_iterator< char, char_traits< char> > > > ::_Psave = _Psave; 

auto locale::facet *_Pfmod = ((basic_ostream< char, char_traits< char> > ::_Nput *)_Psave); 
_Pfmod->_Incref(); 
_Pfmod->_Register(); 
}  }  }  

return (const basic_ostream< char, char_traits< char> > ::_Nput &)(*_Pf); 
} 
} } 
#line 581 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\streambuf"
namespace std { template<> inline ostreambuf_iterator< char, char_traits< char> > ::ostreambuf_iterator(streambuf_type *_Sb) throw() : _Failed(false), _Strbuf(_Sb) 

{ 
} } 
#line 104 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ios"
namespace std { template<> inline char basic_ios< char, char_traits< char> > ::fill() const 
{ 
return this->_Fillch; 
} } 
#line 1105 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocnum"
namespace std { template<> inline __declspec( noinline ) ostreambuf_iterator< char, char_traits< char> >  num_put< char, ostreambuf_iterator< char, char_traits< char> > > ::put(ostreambuf_iterator< char, char_traits< char> >  _Dest, ios_base &
_Iosbase, char _Fill, double _Val) const 
{ 
return this->do_put(_Dest, _Iosbase, _Fill, _Val); 
} } 
#line 615 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\streambuf"
namespace std { template<> inline bool ostreambuf_iterator< char, char_traits< char> > ::failed() const throw() 
{ 
return this->_Failed; 
} } 
#line 410 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ostream"
namespace std { template<> inline __declspec( noinline ) basic_ostream< char, char_traits< char> > ::_Myt &basic_ostream< char, char_traits< char> > ::operator<<(double _Val) 
{ 
auto iostate _State = ((_Iostate)0); 
auto const sentry _Ok(*this);  __CILK_BEGIN_INSTANTIATE_METADATA sentry __CILK_END_INSTANTIATE_METADATA

if (_Ok) 
{ 
auto const _Nput &_Nput_fac = use_facet< num_put< char, ostreambuf_iterator< char, char_traits< char> > > > (this->ios_base::getloc()); 

try { 
if (_Nput_fac.put(((_Iter)(this->std::basic_ios< char, char_traits< char> > ::rdbuf())), *this, this->std::basic_ios< char, char_traits< char> > ::fill(), _Val).failed()) { 

_State |= ((_Iostate)4); }  
} catch (...) { this->std::basic_ios< char, char_traits< char> > ::setstate((_Iostate)4, true); }  
}  

this->std::basic_ios< char, char_traits< char> > ::setstate(_State); 
return *this; 
} } 
#line 507
namespace std { template<> inline __declspec( noinline ) basic_ostream< char, char_traits< char> > ::_Myt &basic_ostream< char, char_traits< char> > ::put(char _Ch) 
{ 
auto iostate _State = ((_Iostate)0); 
auto const sentry _Ok(*this); 

if (!_Ok) { 
_State |= ((_Iostate)4); } else 

{ 
try { 
if (char_traits< char> ::eq_int_type(char_traits< char> ::eof(), (*this->std::basic_ios< char, char_traits< char> > ::rdbuf()).sputc(_Ch))) { 

_State |= ((_Iostate)4); }  
} catch (...) { this->std::basic_ios< char, char_traits< char> > ::setstate((_Iostate)4, true); }  
}  

this->std::basic_ios< char, char_traits< char> > ::setstate(_State); 
return *this; 
} } 
#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\streambuf"
namespace std { template<> inline __declspec( noinline ) int basic_streambuf< char, char_traits< char> > ::pubsync() 
{ 
return this->sync(); 
} } 
#line 549 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ostream"
namespace std { template<> inline __declspec( noinline ) basic_ostream< char, char_traits< char> > ::_Myt &basic_ostream< char, char_traits< char> > ::flush() 
{ 
auto iostate _State = ((_Iostate)0); 
if ((!this->ios_base::fail()) && ((*this->std::basic_ios< char, char_traits< char> > ::rdbuf()).pubsync() == (-1))) { 
_State |= ((_Iostate)4); }  
this->std::basic_ios< char, char_traits< char> > ::setstate(_State); 
return *this; 
} } 
#line 171 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\streambuf"
namespace std { template<> inline __declspec( noinline ) void basic_streambuf< __wchar_t, char_traits< __wchar_t> > ::_Lock() 
{ 
(this->_Mylock)._Lock(); 
} } 
#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ostream"
namespace std { template<> inline __declspec( noinline ) basic_ostream< __wchar_t, char_traits< __wchar_t> > ::_Sentry_base::_Sentry_base(_Myt &_Ostr) : _Myostr(_Ostr) 

{ 
if ((this->_Myostr).rdbuf() != (0)) { 
(*(this->_Myostr).rdbuf())._Lock(); }  
} } 
#line 176 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\streambuf"
namespace std { template<> inline __declspec( noinline ) void basic_streambuf< __wchar_t, char_traits< __wchar_t> > ::_Unlock() 
{ 
(this->_Mylock)._Unlock(); 
} } 
#line 80 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ostream"
namespace std { template<> inline __declspec( noinline ) basic_ostream< __wchar_t, char_traits< __wchar_t> > ::_Sentry_base::~_Sentry_base() 
{ 
if ((this->_Myostr).rdbuf() != (0)) { 
(*(this->_Myostr).rdbuf())._Unlock(); }  
} } 
#line 71 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ios"
namespace std { template<> inline basic_ios< __wchar_t, char_traits< __wchar_t> > ::_Myos *basic_ios< __wchar_t, char_traits< __wchar_t> > ::tie() const 
{ 
return this->_Tiestr; 
} } 
#line 93 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ostream"
namespace std { template<> inline __declspec( noinline ) basic_ostream< __wchar_t, char_traits< __wchar_t> > ::sentry::sentry(_Myt &_Ostr) : _Sentry_base(_Ostr) 

{ 
if (_Ostr.good() && (_Ostr.tie() != (0))) { 
(*_Ostr.tie()).flush(); }  
(this->_Ok) = _Ostr.good(); 
} }  __CILK_BEGIN_INSTANTIATE_METADATA std::basic_ostream< __wchar_t, std::char_traits< __wchar_t> > ::_Sentry_base __CILK_END_INSTANTIATE_METADATA
#line 138
namespace std { template<> inline __declspec( noinline ) void basic_ostream< __wchar_t, char_traits< __wchar_t> > ::_Osfx() 
{ 
try { 
if (this->ios_base::flags() & ((_Fmtflags)2)) { 
this->flush(); }  
} catch (...) { 
}  
} } 
#line 101
namespace std { template<> inline __declspec( noinline ) basic_ostream< __wchar_t, char_traits< __wchar_t> > ::sentry::~sentry() 
{ 


if (!std::uncaught_exception()) { 
(this->_Myostr)._Osfx(); }  
} } 
#line 114
namespace std { template<> inline basic_ostream< __wchar_t, char_traits< __wchar_t> > ::sentry::operator bool() const 
{ 
return this->_Ok; 
} } 
#line 275 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\streambuf"
namespace std { template<> inline streamsize basic_streambuf< __wchar_t, char_traits< __wchar_t> > ::_Pnavail() const 
{ 
return (*(this->_IPnext) != (0)) ? (*(this->_IPcount)) : 0; 
} } 
#line 269
namespace std { template<> inline __wchar_t *basic_streambuf< __wchar_t, char_traits< __wchar_t> > ::_Pninc() 
{ 
--(*(this->_IPcount)); 
return (*(this->_IPnext))++; 
} } 
#line 159
namespace std { template<> inline __declspec( noinline ) basic_streambuf< __wchar_t, char_traits< __wchar_t> > ::int_type basic_streambuf< __wchar_t, char_traits< __wchar_t> > ::sputc(__wchar_t _Ch) 
{ 
return (0 < this->_Pnavail()) ? char_traits< __wchar_t> ::to_int_type((*this->_Pninc()) = _Ch) : this->overflow(char_traits< __wchar_t> ::to_int_type(_Ch)); 


} } 
#line 507 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ostream"
namespace std { template<> inline __declspec( noinline ) basic_ostream< __wchar_t, char_traits< __wchar_t> > ::_Myt &basic_ostream< __wchar_t, char_traits< __wchar_t> > ::put(__wchar_t _Ch) 
{ 
auto iostate _State = ((_Iostate)0); 
auto const sentry _Ok(*this);  __CILK_BEGIN_INSTANTIATE_METADATA sentry __CILK_END_INSTANTIATE_METADATA

if (!_Ok) { 
_State |= ((_Iostate)4); } else 

{ 
try { 
if (char_traits< __wchar_t> ::eq_int_type(char_traits< __wchar_t> ::eof(), (*this->std::basic_ios< __wchar_t, char_traits< __wchar_t> > ::rdbuf()).sputc(_Ch))) { 

_State |= ((_Iostate)4); }  
} catch (...) { this->std::basic_ios< __wchar_t, char_traits< __wchar_t> > ::setstate((_Iostate)4, true); }  
}  

this->std::basic_ios< __wchar_t, char_traits< __wchar_t> > ::setstate(_State); 
return *this; 
} } 
#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\streambuf"
namespace std { template<> inline __declspec( noinline ) int basic_streambuf< __wchar_t, char_traits< __wchar_t> > ::pubsync() 
{ 
return this->sync(); 
} } 
#line 549 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ostream"
namespace std { template<> inline __declspec( noinline ) basic_ostream< __wchar_t, char_traits< __wchar_t> > ::_Myt &basic_ostream< __wchar_t, char_traits< __wchar_t> > ::flush() 
{ 
auto iostate _State = ((_Iostate)0); 
if ((!this->ios_base::fail()) && ((*this->std::basic_ios< __wchar_t, char_traits< __wchar_t> > ::rdbuf()).pubsync() == (-1))) { 
_State |= ((_Iostate)4); }  
this->std::basic_ios< __wchar_t, char_traits< __wchar_t> > ::setstate(_State); 
return *this; 
} } 
#line 483 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocale"
namespace std { template<> inline __declspec( noinline ) const basic_istream< char, char_traits< char> > ::_Nget &__cdecl use_facet< num_get< char, istreambuf_iterator< char, char_traits< char> > > > (const locale &); } 
#line 466
namespace std { template<> const locale::facet *_Facetptr< num_get< char, istreambuf_iterator< char, char_traits< char> > > > ::_Psave = (0); } 
#line 255 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocnum"
namespace std { template<> inline void num_get< char, istreambuf_iterator< char, char_traits< char> > > ::_Init(const _Locinfo &_Lobj) 
{ 
(this->_Cvt) = _Lobj._Getcvt(); 
} } 
#line 250
namespace std { template<> inline __declspec( noinline ) num_get< char, istreambuf_iterator< char, char_traits< char> > > ::~num_get() 
{ 
} } 
#line 1088 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xstring"
namespace std { template<> inline __declspec( noinline ) basic_string< char, char_traits< char> , allocator< char> > ::_Myt &basic_string< char, char_traits< char> , allocator< char> > ::assign(size_type _Count, char _Ch) 
{ 
if (_Count == npos) { 
_String_base::_Xlen(); }  

if (this->_Grow(_Count)) 
{ 
this->_Chassign(0, _Count, _Ch); 
this->_Eos(_Count); 
}  
return *this; 
} } 
#line 663
namespace std { template<> inline __declspec( noinline ) basic_string< char, char_traits< char> , allocator< char> > ::basic_string(size_type _Count, char _Ch) : std::_String_val< char, allocator< char> > () 

{ 
this->_Tidy(); 
this->assign(_Count, _Ch); 
} } 
#line 944
namespace std { template<> inline __declspec( noinline ) basic_string< char, char_traits< char> , allocator< char> > ::_Myt &basic_string< char, char_traits< char> , allocator< char> > ::append(const _Myt &_Right) 
{ 
return this->append(_Right, 0, npos); 
} } 
#line 929
namespace std { template<> inline __declspec( noinline ) basic_string< char, char_traits< char> , allocator< char> > ::_Myt &basic_string< char, char_traits< char> , allocator< char> > ::operator+=(const _Myt &_Right) 
{ 
return this->append(_Right); 
} } 
#line 939
namespace std { template<> inline __declspec( noinline ) basic_string< char, char_traits< char> , allocator< char> > ::_Myt &basic_string< char, char_traits< char> , allocator< char> > ::operator+=(char _Ch) 
{ 
return this->append((size_type)1, _Ch); 
} } 
#line 531 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocale"
namespace std { template<> inline __declspec( noinline ) int __cdecl _Getloctxt(istreambuf_iterator< char, char_traits< char> >  &, istreambuf_iterator< char, char_traits< char> >  &, size_t, const char *); } 
#line 517 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\streambuf"
namespace std { template<> inline __declspec( noinline ) void istreambuf_iterator< char, char_traits< char> > ::_Inc() 
{ 
if ((this->_Strbuf == (0)) || char_traits< char> ::eq_int_type(char_traits< char> ::eof(), (*(this->_Strbuf)).sbumpc())) { 


((this->_Strbuf) = (0)), ((this->_Got) = true); } else { 

(this->_Got) = false; }  
} } 
#line 485
namespace std { template<> inline istreambuf_iterator< char, char_traits< char> > ::_Myt &istreambuf_iterator< char, char_traits< char> > ::operator++() 
{ 
#line 493
this->_Inc(); 
return *this; 
} } 
#line 548
namespace std { template<> inline bool operator==(const istreambuf_iterator< char, char_traits< char> >  &, const istreambuf_iterator< char, char_traits< char> >  &); } 
#line 527
namespace std { template<> inline __declspec( noinline ) char istreambuf_iterator< char, char_traits< char> > ::_Peek() 
{ 
auto int_type _Meta; 
if ((this->_Strbuf == (0)) || char_traits< char> ::eq_int_type(char_traits< char> ::eof(), _Meta = (*(this->_Strbuf)).sgetc())) { 


(this->_Strbuf) = (0); } else { 

(this->_Val) = char_traits< char> ::to_char_type(_Meta); }  
(this->_Got) = true; 
return this->_Val; 
} } 
#line 506
namespace std { template<> inline bool istreambuf_iterator< char, char_traits< char> > ::equal(const _Myt &_Right) const 
{ 
if (!(this->_Got)) { 
((_Myt &)(*this))._Peek(); }  
if (!(_Right._Got)) { 
((_Myt &)_Right)._Peek(); }  
return ((this->_Strbuf == (0)) && (_Right._Strbuf == (0))) || ((this->_Strbuf != (0)) && (_Right._Strbuf != (0))); 

} } 
#line 548
namespace std { template<> inline bool operator==(const istreambuf_iterator< char, char_traits< char> >  &
_Left, const istreambuf_iterator< char, char_traits< char> >  &
_Right) 
{ 
return _Left.equal(_Right); 
} } 
#line 472
namespace std { template<> inline char istreambuf_iterator< char, char_traits< char> > ::operator*() const 
{ 
if (!(this->_Got)) { 
((_Myt &)(*this))._Peek(); }  
#line 482
return this->_Val; 
} } 
#line 531 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocale"
namespace std { template<> inline __declspec( noinline ) int __cdecl _Getloctxt(istreambuf_iterator< char, char_traits< char> >  &_First, istreambuf_iterator< char, char_traits< char> >  &_Last, size_t _Numfields, const char *
_Ptr) 
{ 
for (size_t _Off = (0); _Ptr[_Off] != ((char)0); ++_Off) { 
if (_Ptr[_Off] == _Ptr[0]) { 
++_Numfields; }  }  
auto string _Str(_Numfields, '\000'); 

auto int _Ans = (-2); 
for (size_t _Column = (1); ; ((++_Column), (++_First)), (_Ans = (-1))) 
{ 
auto bool _Prefix = false; 
auto size_t _Off = (0); 
auto size_t _Field = (0); 

for (; _Field < _Numfields; ++_Field) 
{ 
for (; (_Ptr[_Off] != ((char)0)) && (_Ptr[_Off] != _Ptr[0]); ++_Off) { 
; }  

if (_Str[_Field] != ('\000')) { 
_Off += _Str[_Field]; } else { 
if ((_Ptr[_Off += _Column] == _Ptr[0]) || (_Ptr[_Off] == ((char)0))) 

{ 
_Str[_Field] = (char)((_Column < (127)) ? _Column : (127)); 

_Ans = (int)_Field; 
} else { 
if ((_First == _Last) || (_Ptr[_Off] != (*_First))) { 
_Str[_Field] = (char)((_Column < (127)) ? _Column : (127)); } else { 


_Prefix = true; }  }  }  
}  

if ((!_Prefix) || (_First == _Last)) { 
break; }  
}  
return _Ans; 
} } 
#line 557 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\streambuf"
namespace std { template<> inline bool operator!=(const istreambuf_iterator< char, char_traits< char> >  &
_Left, const istreambuf_iterator< char, char_traits< char> >  &
_Right) 
{ 
return !(_Left == _Right); 
} } 
#line 578 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocale"
namespace std { template<> inline char __cdecl _Maklocbyte(char _Char, const _Locinfo::_Cvtvec &__T22293380) 

{ 
return (char)((unsigned char)_Char); 
} } 
#line 616 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocnum"
namespace std { template<> inline __declspec( noinline ) int num_get< char, istreambuf_iterator< char, char_traits< char> > > ::_Getifld(char *_Ac, istreambuf_iterator< char, char_traits< char> >  &
_First, istreambuf_iterator< char, char_traits< char> >  &_Last, ios_base::fmtflags _Basefield, const locale &
_Loc) const 
{ 
auto const _Mypunct &_Punct_fac = use_facet< numpunct< char> > (_Loc); 
auto const string _Grouping = _Punct_fac.grouping(); 
auto const char _Kseparator = ((_Grouping.size() == (0)) ? ((char)0) : _Punct_fac.thousands_sep()); 

auto const char _E0 = _Maklocchr('0', (char *)0, this->_Cvt); 
auto char *_Ptr = _Ac; 

if ((_First == _Last)) { 
; } else { 
if ((*_First) == _Maklocchr('+', (char *)0, this->_Cvt)) { 
((*(_Ptr++)) = '+'), (++_First); } else { 
if ((*_First) == _Maklocchr('-', (char *)0, this->_Cvt)) { 
((*(_Ptr++)) = '-'), (++_First); }  }  }  

_Basefield &= ((_Iosb< int> ::_Fmtflags)3584); 
auto int _Base = ((_Basefield == ((_Iosb< int> ::_Fmtflags)1024)) ? 8 : ((_Basefield == ((_Iosb< int> ::_Fmtflags)2048)) ? 16 : ((_Basefield == (ios_base::_Fmtzero)) ? 0 : 10))); 



auto bool _Seendigit = false; 
auto bool _Nonzero = false; 

if ((_First != _Last) && ((*_First) == _E0)) 
{ 
(_Seendigit = true), (++_First); 
if (((_First != _Last) && (((*_First) == _Maklocchr('x', (char *)0, this->_Cvt)) || ((*_First) == _Maklocchr('X', (char *)0, this->_Cvt)))) && ((_Base == 0) || (_Base == 16))) { 


((_Base = 16), (_Seendigit = false)), (++_First); } else { 
if (_Base == 0) { 
_Base = 8; }  }  
}  

auto int _Dlen = (((_Base == 0) || (_Base == 10)) ? 10 : ((_Base == 8) ? 8 : (16 + 6))); 

auto string _Groups((size_t)1, (char)_Seendigit); 
auto size_t _Group = (0); 

for (char *const _Pe = (_Ac + (32 - 1)); (_First != _Last); (++_First)) { 

if (::memchr((const char *)("0123456789abcdefABCDEF"), (*_Ptr) = _Maklocbyte((char)(*_First), this->_Cvt), _Dlen) != (0)) 

{ 
if ((_Nonzero || (*_Ptr != ('0'))) && (_Ptr < _Pe)) { 
(++_Ptr), (_Nonzero = true); }  
_Seendigit = true; 
if (_Groups[_Group] != 127) { 
++_Groups[_Group]; }  
} else { 
if (((_Groups[_Group] == ('\000')) || (_Kseparator == ((char)0))) || ((*_First) != _Kseparator)) { 


break; } else 

{ 
_Groups.append((basic_string< char, char_traits< char> , allocator< char> > ::size_type)1, '\000'); 
++_Group; 
}  }  }  

if (_Group == (0)) { 
; } else { 
if (('\000') < _Groups[_Group]) { 
++_Group; } else { 

_Seendigit = false; }  }  

for (const char *_Pg = _Grouping.c_str(); _Seendigit && ((0) < _Group);) { 
if (*_Pg == 127) { 
break; } else { 
if ((((0) < --_Group) && (*_Pg != _Groups[_Group])) || (((0) == _Group) && (*_Pg < _Groups[_Group]))) { 

_Seendigit = false; } else { 
if (('\000') < _Pg[1]) { 
++_Pg; }  }  }  }  

if (_Seendigit && (!_Nonzero)) { 
(*(_Ptr++)) = '0'; } else { 
if (!_Seendigit) { 
_Ptr = _Ac; }  }  
(*_Ptr) = '\000'; 
return _Base; 
} } 
#line 360
namespace std { template<> inline __declspec( noinline ) istreambuf_iterator< char, char_traits< char> >  num_get< char, istreambuf_iterator< char, char_traits< char> > > ::do_get(istreambuf_iterator< char, char_traits< char> >  _First, istreambuf_iterator< char, char_traits< char> >  _Last, ios_base &
_Iosbase, ios_base::iostate &_State, _Bool &
_Val) const 
{ 
; 
auto int _Ans = (-1);  __CILK_BEGIN_INSTANTIATE_METADATA istreambuf_iterator< char, char_traits< char> >  __CILK_END_INSTANTIATE_METADATA

if (_Iosbase.flags() & ((_Iosb< int> ::_Fmtflags)16384)) 
{ 
typedef basic_string< char, char_traits< char> , allocator< char> > ::size_type _Mystrsize; 
auto const _Mypunct &_Punct_fac = use_facet< numpunct< char> > (_Iosbase.getloc()); 
auto _Mystr _Str((_Mystrsize)1, (char_type)0); 
(_Str += _Punct_fac.falsename()); 
(_Str += (((char_type)0))); 
(_Str += _Punct_fac.truename()); 
_Ans = _Getloctxt(_First, _Last, (size_t)2, _Str.c_str()); 
} else 

{ 
auto char _Ac[32]; auto char *_Ep; 
auto int _Errno = 0; 
auto const unsigned long _Ulo = ::_Stoulx(_Ac, &_Ep, this->_Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()), &_Errno); 


if (((_Ep != (_Ac)) && (_Errno == 0)) && (_Ulo <= (1))) { 
_Ans = _Ulo; }  
}  

if ((_First == _Last)) { 
_State |= ((_Iosb< int> ::_Iostate)1); }  
if (_Ans < 0) { 
_State |= ((_Iosb< int> ::_Iostate)2); } else { 

_Val = _Ans != 0; }  
return _First; 
} } 

namespace std { template<> inline __declspec( noinline ) istreambuf_iterator< char, char_traits< char> >  num_get< char, istreambuf_iterator< char, char_traits< char> > > ::do_get(istreambuf_iterator< char, char_traits< char> >  _First, istreambuf_iterator< char, char_traits< char> >  _Last, ios_base &
_Iosbase, ios_base::iostate &_State, unsigned short &
_Val) const 
{ 
; 
auto char _Ac[32]; auto char *_Ep; 
auto int _Errno = 0; 
auto int _Base = this->_Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); 

auto char *_Ptr = (((_Ac)[0] == ('-')) ? ((_Ac) + 1) : (_Ac)); 
auto const unsigned long _Ans = ::_Stoulx(_Ptr, &_Ep, _Base, &_Errno); 


if ((_First == _Last)) { 
_State |= ((_Iosb< int> ::_Iostate)1); }  
if (((_Ep == _Ptr) || (_Errno != 0)) || ((65535) < _Ans)) { 
_State |= ((_Iosb< int> ::_Iostate)2); } else { 

_Val = (unsigned short)(((_Ac)[0] == ('-')) ? ((0) - _Ans) : _Ans); }  

return _First; 
} } 

namespace std { template<> inline __declspec( noinline ) istreambuf_iterator< char, char_traits< char> >  num_get< char, istreambuf_iterator< char, char_traits< char> > > ::do_get(istreambuf_iterator< char, char_traits< char> >  _First, istreambuf_iterator< char, char_traits< char> >  _Last, ios_base &
_Iosbase, ios_base::iostate &_State, unsigned &
_Val) const 
{ 
; 
auto char _Ac[32]; auto char *_Ep; 
auto int _Errno = 0; 
auto int _Base = this->_Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); 

auto char *_Ptr = (((_Ac)[0] == ('-')) ? ((_Ac) + 1) : (_Ac)); 
auto const unsigned long _Ans = ::_Stoulx(_Ptr, &_Ep, _Base, &_Errno); 


if ((_First == _Last)) { 
_State |= ((_Iosb< int> ::_Iostate)1); }  
if (((_Ep == _Ptr) || (_Errno != 0)) || ((4294967295U) < _Ans)) { 
_State |= ((_Iosb< int> ::_Iostate)2); } else { 

_Val = ((_Ac)[0] == ('-')) ? ((0) - _Ans) : _Ans; }  
return _First; 
} } 

namespace std { template<> inline __declspec( noinline ) istreambuf_iterator< char, char_traits< char> >  num_get< char, istreambuf_iterator< char, char_traits< char> > > ::do_get(istreambuf_iterator< char, char_traits< char> >  _First, istreambuf_iterator< char, char_traits< char> >  _Last, ios_base &
_Iosbase, ios_base::iostate &_State, long &
_Val) const 
{ 
; 
auto char _Ac[32]; auto char *_Ep; 
auto int _Errno = 0; 
auto const long _Ans = ::_Stolx(_Ac, &_Ep, this->_Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()), &_Errno); 



if ((_First == _Last)) { 
_State |= ((_Iosb< int> ::_Iostate)1); }  
if ((_Ep == (_Ac)) || (_Errno != 0)) { 
_State |= ((_Iosb< int> ::_Iostate)2); } else { 

_Val = _Ans; }  
return _First; 
} } 

namespace std { template<> inline __declspec( noinline ) istreambuf_iterator< char, char_traits< char> >  num_get< char, istreambuf_iterator< char, char_traits< char> > > ::do_get(istreambuf_iterator< char, char_traits< char> >  _First, istreambuf_iterator< char, char_traits< char> >  _Last, ios_base &
_Iosbase, ios_base::iostate &_State, unsigned long &
_Val) const 
{ 
; 
auto char _Ac[32]; auto char *_Ep; 
auto int _Errno = 0; 
auto const unsigned long _Ans = ::_Stoulx(_Ac, &_Ep, this->_Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()), &_Errno); 



if ((_First == _Last)) { 
_State |= ((_Iosb< int> ::_Iostate)1); }  
if ((_Ep == (_Ac)) || (_Errno != 0)) { 
_State |= ((_Iosb< int> ::_Iostate)2); } else { 

_Val = _Ans; }  
return _First; 
} } 


namespace std { template<> inline __declspec( noinline ) istreambuf_iterator< char, char_traits< char> >  num_get< char, istreambuf_iterator< char, char_traits< char> > > ::do_get(istreambuf_iterator< char, char_traits< char> >  _First, istreambuf_iterator< char, char_traits< char> >  _Last, ios_base &
_Iosbase, ios_base::iostate &_State, __int64 &
_Val) const 
{ 
; 
auto char _Ac[32]; auto char *_Ep; 
auto int _Errno = 0; 
auto const __int64 _Ans = ::_Stollx(_Ac, &_Ep, this->_Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()), &_Errno); 



if ((_First == _Last)) { 
_State |= ((_Iosb< int> ::_Iostate)1); }  
if ((_Ep == (_Ac)) || (_Errno != 0)) { 
_State |= ((_Iosb< int> ::_Iostate)2); } else { 

_Val = _Ans; }  
return _First; 
} } 

namespace std { template<> inline __declspec( noinline ) istreambuf_iterator< char, char_traits< char> >  num_get< char, istreambuf_iterator< char, char_traits< char> > > ::do_get(istreambuf_iterator< char, char_traits< char> >  _First, istreambuf_iterator< char, char_traits< char> >  _Last, ios_base &
_Iosbase, ios_base::iostate &_State, unsigned __int64 &
_Val) const 
{ 
; 
auto char _Ac[32]; auto char *_Ep; 
auto int _Errno = 0; 
auto const unsigned __int64 _Ans = ::_Stoullx(_Ac, &_Ep, this->_Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()), &_Errno); 



if ((_First == _Last)) { 
_State |= ((_Iosb< int> ::_Iostate)1); }  
if ((_Ep == (_Ac)) || (_Errno != 0)) { 
_State |= ((_Iosb< int> ::_Iostate)2); } else { 

_Val = _Ans; }  
return _First; 
} } 
#line 703
namespace std { template<> inline __declspec( noinline ) int num_get< char, istreambuf_iterator< char, char_traits< char> > > ::_Getffld(char *_Ac, istreambuf_iterator< char, char_traits< char> >  &
_First, istreambuf_iterator< char, char_traits< char> >  &_Last, const locale &_Loc) const 
{ 
auto const _Mypunct &_Punct_fac = use_facet< numpunct< char> > (_Loc); 
auto const string _Grouping = _Punct_fac.grouping(); 
auto const char _E0 = _Maklocchr('0', (char *)0, this->_Cvt); 
auto char *_Ptr = _Ac; 
auto bool _Bad = false; 

if ((_First == _Last)) { 
; } else { 
if ((*_First) == _Maklocchr('+', (char *)0, this->_Cvt)) { 
((*(_Ptr++)) = '+'), (++_First); } else { 
if ((*_First) == _Maklocchr('-', (char *)0, this->_Cvt)) { 
((*(_Ptr++)) = '-'), (++_First); }  }  }  

auto bool _Seendigit = false; 
auto int _Significant = 0; 
auto int _Pten = 0; 

if ((*_Grouping.c_str() == 127) || (*_Grouping.c_str() <= ('\000'))) { 
for (; ((_First != _Last) && (_E0 <= (*_First))) && ((*_First) <= _E0 + 9); (_Seendigit = true), (++_First)) { 


if (36 <= _Significant) { 
++_Pten; } else { 
if (((*_First) == _E0) && (_Significant == 0)) { 
; } else 

{ 
(*(_Ptr++)) = (char)(((*_First) - _E0) + ('0')); 
++_Significant; 
}  }  }  } else 

{ 
auto const char _Kseparator = _Punct_fac.thousands_sep(); 

auto string _Groups((size_t)1, '\000'); 
auto size_t _Group = (0); 

for (; (_First != _Last); (++_First)) { 
if ((_E0 <= (*_First)) && ((*_First) <= _E0 + 9)) 
{ 
_Seendigit = true; 
if (36 <= _Significant) { 
++_Pten; } else { 
if (((*_First) == _E0) && (_Significant == 0)) { 
; } else 

{ 
(*(_Ptr++)) = (char)(((*_First) - _E0) + ('0')); 
++_Significant; 
}  }  
if (_Groups[_Group] != 127) { 
++_Groups[_Group]; }  
} else { 
if (((_Groups[_Group] == ('\000')) || (_Kseparator == ((char)0))) || ((*_First) != _Kseparator)) { 


break; } else 

{ 
_Groups.append((size_t)1, '\000'); 
++_Group; 
}  }  }  
if (_Group == (0)) { 
; } else { 
if (('\000') < _Groups[_Group]) { 
++_Group; } else { 

_Bad = true; }  }  

for (const char *_Pg = _Grouping.c_str(); (!_Bad) && ((0) < _Group);) { 

if (*_Pg == 127) { 
break; } else { 
if ((((0) < --_Group) && (*_Pg != _Groups[_Group])) || (((0) == _Group) && (*_Pg < _Groups[_Group]))) { 

_Bad = true; } else { 
if (('\000') < _Pg[1]) { 
++_Pg; }  }  }  }  
}  

if (_Seendigit && (_Significant == 0)) { 
(*(_Ptr++)) = '0'; }  

if ((_First != _Last) && ((*_First) == _Punct_fac.decimal_point())) { 
((*(_Ptr++)) = ((*localeconv()).decimal_point)[0]), (++_First); }  

if (_Significant == 0) 
{ 
for (; (_First != _Last) && ((*_First) == _E0); (_Seendigit = true), (++_First)) { 

--_Pten; }  
if (_Pten < 0) { 
((*(_Ptr++)) = '0'), (++_Pten); }  
}  

for (; ((_First != _Last) && (_E0 <= (*_First))) && ((*_First) <= _E0 + 9); (_Seendigit = true), (++_First)) { 


if (_Significant < 36) 
{ 
(*(_Ptr++)) = (char)(((*_First) - _E0) + ('0')); 
++_Significant; 
}  }  

if ((_Seendigit && (_First != _Last)) && (((*_First) == _Maklocchr('e', (char *)0, this->_Cvt)) || ((*_First) == _Maklocchr('E', (char *)0, this->_Cvt)))) 


{ 
((*(_Ptr++)) = 'e'), (++_First); 
(_Seendigit = false), (_Significant = 0); 

if ((_First == _Last)) { 
; } else { 
if ((*_First) == _Maklocchr('+', (char *)0, this->_Cvt)) { 
((*(_Ptr++)) = '+'), (++_First); } else { 
if ((*_First) == _Maklocchr('-', (char *)0, this->_Cvt)) { 
((*(_Ptr++)) = '-'), (++_First); }  }  }  
for (; (_First != _Last) && ((*_First) == _E0);) { 
(_Seendigit = true), (++_First); }  
if (_Seendigit) { 
(*(_Ptr++)) = '0'; }  
for (; ((_First != _Last) && (_E0 <= (*_First))) && ((*_First) <= _E0 + 9); (_Seendigit = true), (++_First)) { 


if (_Significant < 8) 
{ 
(*(_Ptr++)) = (char)(((*_First) - _E0) + ('0')); 
++_Significant; 
}  }  
}  

if (_Bad || (!_Seendigit)) { 
_Ptr = _Ac; }  
(*_Ptr) = '\000'; 
return _Pten; 
} } 
#line 524
namespace std { template<> inline __declspec( noinline ) istreambuf_iterator< char, char_traits< char> >  num_get< char, istreambuf_iterator< char, char_traits< char> > > ::do_get(istreambuf_iterator< char, char_traits< char> >  _First, istreambuf_iterator< char, char_traits< char> >  _Last, ios_base &
_Iosbase, ios_base::iostate &_State, float &
_Val) const 
{ 
; 
auto char _Ac[((8 + 36) + 16)]; auto char *_Ep; 
auto int _Errno = 0; 
auto const float _Ans = ::_Stofx(_Ac, &_Ep, this->_Getffld(_Ac, _First, _Last, _Iosbase.getloc()), &_Errno); 



if ((_First == _Last)) { 
_State |= ((_Iosb< int> ::_Iostate)1); }  
if ((_Ep == (_Ac)) || (_Errno != 0)) { 
_State |= ((_Iosb< int> ::_Iostate)2); } else { 

_Val = _Ans; }  
return _First; 
} } 

namespace std { template<> inline __declspec( noinline ) istreambuf_iterator< char, char_traits< char> >  num_get< char, istreambuf_iterator< char, char_traits< char> > > ::do_get(istreambuf_iterator< char, char_traits< char> >  _First, istreambuf_iterator< char, char_traits< char> >  _Last, ios_base &
_Iosbase, ios_base::iostate &_State, double &
_Val) const 
{ 
; 
auto char _Ac[((8 + 36) + 16)]; auto char *_Ep; 
auto int _Errno = 0; 
auto const double _Ans = ::_Stodx(_Ac, &_Ep, this->_Getffld(_Ac, _First, _Last, _Iosbase.getloc()), &_Errno); 



if ((_First == _Last)) { 
_State |= ((_Iosb< int> ::_Iostate)1); }  
if ((_Ep == (_Ac)) || (_Errno != 0)) { 
_State |= ((_Iosb< int> ::_Iostate)2); } else { 

_Val = _Ans; }  
return _First; 
} } 

namespace std { template<> inline __declspec( noinline ) istreambuf_iterator< char, char_traits< char> >  num_get< char, istreambuf_iterator< char, char_traits< char> > > ::do_get(istreambuf_iterator< char, char_traits< char> >  _First, istreambuf_iterator< char, char_traits< char> >  _Last, ios_base &
_Iosbase, ios_base::iostate &_State, long double &
_Val) const 
{ 
; 
auto char _Ac[((8 + 36) + 16)]; auto char *_Ep; 
auto int _Errno = 0; 
auto const long double _Ans = ::_Stoldx(_Ac, &_Ep, this->_Getffld(_Ac, _First, _Last, _Iosbase.getloc()), &_Errno); 



if ((_First == _Last)) { 
_State |= ((_Iosb< int> ::_Iostate)1); }  
if ((_Ep == (_Ac)) || (_Errno != 0)) { 
_State |= ((_Iosb< int> ::_Iostate)2); } else { 

_Val = _Ans; }  
return _First; 
} } 

namespace std { template<> inline __declspec( noinline ) istreambuf_iterator< char, char_traits< char> >  num_get< char, istreambuf_iterator< char, char_traits< char> > > ::do_get(istreambuf_iterator< char, char_traits< char> >  _First, istreambuf_iterator< char, char_traits< char> >  _Last, ios_base &
_Iosbase, ios_base::iostate &_State, void *&
_Val) const 
{ 
; 
auto char _Ac[32]; auto char *_Ep; 
auto int _Errno = 0; 


auto int _Base = this->_Getifld(_Ac, _First, _Last, (_Iosb< int> ::_Fmtflags)2048, _Iosbase.getloc()); 

auto const unsigned __int64 _Ans = ((sizeof(void *) == sizeof(unsigned long)) ? ((unsigned __int64)::_Stoulx(_Ac, &_Ep, _Base, &_Errno)) : ::_Stoullx(_Ac, &_Ep, _Base, &_Errno)); 
#line 606
if ((_First == _Last)) { 
_State |= ((_Iosb< int> ::_Iostate)1); }  
if ((_Ep == (_Ac)) || (_Errno != 0)) { 
_State |= ((_Iosb< int> ::_Iostate)2); } else { 

_Val = (void *)(((char *)0) + _Ans); }  
return _First; 
} } 
#line 271
namespace std { template<> inline __declspec( noinline ) num_get< char, istreambuf_iterator< char, char_traits< char> > > ::num_get(const _Locinfo &_Lobj, size_t _Refs) : locale::facet(_Refs) 

{ 
this->_Init(_Lobj); 
} } 
#line 238
namespace std { template<> inline __declspec( noinline ) size_t num_get< char, istreambuf_iterator< char, char_traits< char> > > ::_Getcat(const locale::facet **_Ppf, const locale *
_Ploc) 
{ 
if ((_Ppf != (0)) && (*_Ppf == (0))) { 
(*_Ppf) = (new std::num_get< char, istreambuf_iterator< char, char_traits< char> > > (((_Locinfo)(_Ploc->name())))); }  

return 4; 
} }  __CILK_BEGIN_INSTANTIATE_METADATA std::num_get< char, std::istreambuf_iterator< char, std::char_traits< char> > >  __CILK_END_INSTANTIATE_METADATA
#line 483 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocale"
namespace std { template<> inline __declspec( noinline ) const basic_istream< char, char_traits< char> > ::_Nget &__cdecl use_facet< num_get< char, istreambuf_iterator< char, char_traits< char> > > > (const locale &_Loc) 


{ 
{ auto _Lockit _Lock(0); 
auto const locale::facet *_Psave = _Facetptr< num_get< char, istreambuf_iterator< char, char_traits< char> > > > ::_Psave; 


auto size_t _Id = num_get< char, istreambuf_iterator< char, char_traits< char> > > ::id; 
auto const locale::facet *_Pf = _Loc._Getfacet(_Id); 

if (_Pf != (0)) { 
; } else { 
if (_Psave != (0)) { 
_Pf = _Psave; } else { 
if (num_get< char, istreambuf_iterator< char, char_traits< char> > > ::_Getcat(&_Psave, (&_Loc)) == ((size_t)(-1))) { 


__cilk_s::throw0<bad_cast >( bad_cast()); } else 
#line 508
{ 
_Pf = _Psave; 
_Facetptr< num_get< char, istreambuf_iterator< char, char_traits< char> > > > ::_Psave = _Psave; 

auto locale::facet *_Pfmod = ((basic_istream< char, char_traits< char> > ::_Nget *)_Psave); 
_Pfmod->_Incref(); 
_Pfmod->_Register(); 
}  }  }  

return (const basic_istream< char, char_traits< char> > ::_Nget &)(*_Pf); 
} 
} } 
#line 462 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\streambuf"
namespace std { template<> inline istreambuf_iterator< char, char_traits< char> > ::istreambuf_iterator(streambuf_type *_Sb) throw() : _Strbuf(_Sb), _Got((_Sb == (0))) 

{ 
} } 
#line 301 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocnum"
namespace std { template<> inline __declspec( noinline ) istreambuf_iterator< char, char_traits< char> >  num_get< char, istreambuf_iterator< char, char_traits< char> > > ::get(istreambuf_iterator< char, char_traits< char> >  _First, istreambuf_iterator< char, char_traits< char> >  _Last, ios_base &
_Iosbase, ios_base::iostate &_State, long &
_Val) const 
{ 
return this->do_get(_First, _Last, _Iosbase, _State, _Val); 
} } 
#line 247 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\istream"
namespace std { template<> inline __declspec( noinline ) basic_istream< char, char_traits< char> > ::_Myt &basic_istream< char, char_traits< char> > ::operator>>(int &_Val) 
{ 
auto iostate _State = ((_Iostate)0); 
auto const sentry _Ok(*this); 

if (_Ok) 
{ 
auto long _Tmp = (0); 
auto const _Nget &_Nget_fac = use_facet< num_get< char, istreambuf_iterator< char, char_traits< char> > > > (this->ios_base::getloc()); 

try { 
_Nget_fac.get(((_Iter)(this->std::basic_ios< char, char_traits< char> > ::rdbuf())), ((_Iter)(0)), *this, _State, _Tmp); 

} catch (...) { this->std::basic_ios< char, char_traits< char> > ::setstate((_Iostate)4, true); }  

if (((_State & ((_Iostate)2)) || (_Tmp < ((-2147483647) - 1))) || ((2147483647) < _Tmp)) { 

_State |= ((_Iostate)2); } else { 

_Val = _Tmp; }  
}  

this->std::basic_ios< char, char_traits< char> > ::setstate(_State); 
return *this; 
} } 
#line 60
namespace std { template<> inline __declspec( noinline ) basic_istream< char, char_traits< char> > ::_Sentry_base::~_Sentry_base() 
{ 
if ((this->_Myistr).rdbuf() != (0)) { 
(*(this->_Myistr).rdbuf())._Unlock(); }  
} } 
#line 53
namespace std { template<> inline __declspec( noinline ) basic_istream< char, char_traits< char> > ::_Sentry_base::_Sentry_base(_Myt &_Istr) : _Myistr(_Istr) 

{ 
if ((this->_Myistr).rdbuf() != (0)) { 
(*(this->_Myistr).rdbuf())._Lock(); }  
} } 
#line 91
namespace std { template<> inline __declspec( noinline ) bool basic_istream< char, char_traits< char> > ::_Ipfx(bool _Noskip) 
{ 
if (this->ios_base::good()) 
{ 
if (this->std::basic_ios< char, char_traits< char> > ::tie() != (0)) { 
(*this->std::basic_ios< char, char_traits< char> > ::tie()).flush(); }  

if ((!_Noskip) && (this->ios_base::flags() & ((_Fmtflags)1))) 
{ 
auto const _Ctype &_Ctype_fac = use_facet< ctype< char> > (this->ios_base::getloc()); 

try { 
auto int_type _Meta = (*this->std::basic_ios< char, char_traits< char> > ::rdbuf()).sgetc(); 

for (; ; _Meta = (*this->std::basic_ios< char, char_traits< char> > ::rdbuf()).snextc()) { 
if (char_traits< char> ::eq_int_type(char_traits< char> ::eof(), _Meta)) 
{ 
this->std::basic_ios< char, char_traits< char> > ::setstate((_Iostate)1); 
break; 
} else { 
if (!_Ctype_fac.is(ctype_base::space, char_traits< char> ::to_char_type(_Meta))) { 

break; }  }  }  
} catch (...) { this->std::basic_ios< char, char_traits< char> > ::setstate((_Iostate)4, true); }  
}  

if (this->ios_base::good()) { 
return true; }  
}  
this->std::basic_ios< char, char_traits< char> > ::setstate((_Iostate)2); 
return false; 
} } 
#line 73
namespace std { template<> inline __declspec( noinline ) basic_istream< char, char_traits< char> > ::sentry::sentry(_Myt &_Istr, bool _Noskip) : _Sentry_base(_Istr) 

{ 
(this->_Ok) = (this->_Myistr)._Ipfx(_Noskip); 
} }  __CILK_BEGIN_INSTANTIATE_METADATA std::basic_istream< char, std::char_traits< char> > ::_Sentry_base __CILK_END_INSTANTIATE_METADATA

namespace std { template<> inline basic_istream< char, char_traits< char> > ::sentry::operator bool() const 
{ 
return this->_Ok; 
} } 
#line 60
namespace std { template<> inline __declspec( noinline ) basic_istream< __wchar_t, char_traits< __wchar_t> > ::_Sentry_base::~_Sentry_base() 
{ 
if ((this->_Myistr).rdbuf() != (0)) { 
(*(this->_Myistr).rdbuf())._Unlock(); }  
} } 
#line 53
namespace std { template<> inline __declspec( noinline ) basic_istream< __wchar_t, char_traits< __wchar_t> > ::_Sentry_base::_Sentry_base(_Myt &_Istr) : _Myistr(_Istr) 

{ 
if ((this->_Myistr).rdbuf() != (0)) { 
(*(this->_Myistr).rdbuf())._Lock(); }  
} } 
#line 91
namespace std { template<> inline __declspec( noinline ) bool basic_istream< __wchar_t, char_traits< __wchar_t> > ::_Ipfx(bool _Noskip) 
{ 
if (this->ios_base::good()) 
{ 
if (this->std::basic_ios< __wchar_t, char_traits< __wchar_t> > ::tie() != (0)) { 
(*this->std::basic_ios< __wchar_t, char_traits< __wchar_t> > ::tie()).flush(); }  

if ((!_Noskip) && (this->ios_base::flags() & ((_Fmtflags)1))) 
{ 
auto const _Ctype &_Ctype_fac = use_facet< ctype< __wchar_t> > (this->ios_base::getloc()); 

try { 
auto int_type _Meta = (*this->std::basic_ios< __wchar_t, char_traits< __wchar_t> > ::rdbuf()).sgetc(); 

for (; ; _Meta = (*this->std::basic_ios< __wchar_t, char_traits< __wchar_t> > ::rdbuf()).snextc()) { 
if (char_traits< __wchar_t> ::eq_int_type(char_traits< __wchar_t> ::eof(), _Meta)) 
{ 
this->std::basic_ios< __wchar_t, char_traits< __wchar_t> > ::setstate((_Iostate)1); 
break; 
} else { 
if (!_Ctype_fac.is(ctype_base::space, char_traits< __wchar_t> ::to_char_type(_Meta))) { 

break; }  }  }  
} catch (...) { this->std::basic_ios< __wchar_t, char_traits< __wchar_t> > ::setstate((_Iostate)4, true); }  
}  

if (this->ios_base::good()) { 
return true; }  
}  
this->std::basic_ios< __wchar_t, char_traits< __wchar_t> > ::setstate((_Iostate)2); 
return false; 
} } 
#line 73
namespace std { template<> inline __declspec( noinline ) basic_istream< __wchar_t, char_traits< __wchar_t> > ::sentry::sentry(_Myt &_Istr, bool _Noskip) : _Sentry_base(_Istr) 

{ 
(this->_Ok) = (this->_Myistr)._Ipfx(_Noskip); 
} }  __CILK_BEGIN_INSTANTIATE_METADATA std::basic_istream< __wchar_t, std::char_traits< __wchar_t> > ::_Sentry_base __CILK_END_INSTANTIATE_METADATA

namespace std { template<> inline basic_istream< __wchar_t, char_traits< __wchar_t> > ::sentry::operator bool() const 
{ 
return this->_Ok; 
} } 
#line 466 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\xlocale"
namespace std { template<> const locale::facet *_Facetptr< ctype< __wchar_t> > ::_Psave = (0); } 
#line 483
namespace std { template<> inline __declspec( noinline ) const ctype< __wchar_t>  &__cdecl use_facet< ctype< __wchar_t> > (const locale &_Loc) 


{ 
{ auto _Lockit _Lock(0); 
auto const locale::facet *_Psave = _Facetptr< ctype< __wchar_t> > ::_Psave; 


auto size_t _Id = ctype< __wchar_t> ::id; 
auto const locale::facet *_Pf = _Loc._Getfacet(_Id); 

if (_Pf != (0)) { 
; } else { 
if (_Psave != (0)) { 
_Pf = _Psave; } else { 
if (ctype< __wchar_t> ::_Getcat(&_Psave, (&_Loc)) == ((size_t)(-1))) { 


__cilk_s::throw0<bad_cast >( bad_cast()); } else 
#line 508
{ 
_Pf = _Psave; 
_Facetptr< ctype< __wchar_t> > ::_Psave = _Psave; 

auto locale::facet *_Pfmod = ((ctype< __wchar_t>  *)_Psave); 
_Pfmod->_Incref(); 
_Pfmod->_Register(); 
}  }  }  

return (const ctype< __wchar_t>  &)(*_Pf); 
} 
} } 
#line 166 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\streambuf"
namespace std { template<> inline __declspec( noinline ) streamsize basic_streambuf< char, char_traits< char> > ::sputn(const char *_Ptr, streamsize _Count) 
{ 
return this->xsputn(_Ptr, _Count); 
} } 
#line 738 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\ostream"
namespace std { template<> inline __declspec( noinline ) basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  &
_Ostr, const char *
_Val) 
{ 
typedef char _Elem; 
typedef basic_ostream< char, char_traits< char> >  _Myos; 
auto ios_base::iostate _State = ((_Iosb< int> ::_Iostate)0); 
auto streamsize _Count = ((streamsize)char_traits< char> ::length(_Val)); 
auto streamsize _Pad = (((_Ostr.width() <= 0) || (_Ostr.width() <= _Count)) ? 0 : (_Ostr.width() - _Count)); 

auto const basic_ostream< char, char_traits< char> > ::sentry _Ok(_Ostr); 

if (!_Ok) { 
_State |= ((_Iosb< int> ::_Iostate)4); } else 

{ 
try { 
if ((_Ostr.flags() & ((_Iosb< int> ::_Fmtflags)448)) != ((_Iosb< int> ::_Fmtflags)64)) { 
for (; 0 < _Pad; --_Pad) { 
if (char_traits< char> ::eq_int_type(char_traits< char> ::eof(), (*_Ostr.rdbuf()).sputc(_Ostr.fill()))) 

{ 
_State |= ((_Iosb< int> ::_Iostate)4); 
break; 
}  }  }  

if ((_State == ((_Iosb< int> ::_Iostate)0)) && ((*_Ostr.rdbuf()).sputn(_Val, _Count) != _Count)) { 

_State |= ((_Iosb< int> ::_Iostate)4); }  

if (_State == ((_Iosb< int> ::_Iostate)0)) { 
for (; 0 < _Pad; --_Pad) { 
if (char_traits< char> ::eq_int_type(char_traits< char> ::eof(), (*_Ostr.rdbuf()).sputc(_Ostr.fill()))) 

{ 
_State |= ((_Iosb< int> ::_Iostate)4); 
break; 
}  }  }  
_Ostr.width(0); 
} catch (...) { _Ostr.setstate((_Iosb< int> ::_Iostate)4, true); }  
}  

_Ostr.setstate(_State); 
return _Ostr; 
} } 
__CILK_MAIN0(main, char)
